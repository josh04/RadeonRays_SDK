/* This is an auto-generated file. Do not edit manually*/

static const char g_bxdf_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef BXDF_CL \n"\
"#define BXDF_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"#define DENOM_EPS 0.0f \n"\
"#define ROUGHNESS_EPS 0.0001f \n"\
" \n"\
"enum Bxdf \n"\
"{ \n"\
"    kZero, \n"\
"    kLambert, \n"\
"    kIdealReflect, \n"\
"    kIdealRefract, \n"\
"    kMicrofacetBlinn, \n"\
"    kMicrofacetBeckmann, \n"\
"    kMicrofacetGGX, \n"\
"    kLayered, \n"\
"    kFresnelBlend, \n"\
"    kMix, \n"\
"    kEmissive, \n"\
"    kPassthrough, \n"\
"    kTranslucent, \n"\
"    kMicrofacetRefractionGGX, \n"\
"    kMicrofacetRefractionBeckmann \n"\
"}; \n"\
" \n"\
"enum BxdfFlags \n"\
"{ \n"\
"    kReflection = (1 << 0), \n"\
"    kTransmission = (1 << 1), \n"\
"    kDiffuse = (1 << 2), \n"\
"    kSpecular = (1 << 3), \n"\
"    kGlossy = (1 << 4), \n"\
"    kAllReflection = kReflection | kDiffuse | kSpecular | kGlossy, \n"\
"    kAllTransmission = kTransmission | kDiffuse | kSpecular | kGlossy, \n"\
"    kAll = kReflection | kTransmission | kDiffuse | kSpecular | kGlossy \n"\
"}; \n"\
" \n"\
" \n"\
"/// Schlick's approximation of Fresnel equtions \n"\
"float SchlickFresnel(float eta, float ndotw) \n"\
"{ \n"\
"    const float f = ((1.f - eta) / (1.f + eta)) * ((1.f - eta) / (1.f + eta)); \n"\
"    const float m = 1.f - fabs(ndotw); \n"\
"    const float m2 = m*m; \n"\
"    return f + (1.f - f) * m2 * m2 * m; \n"\
"} \n"\
" \n"\
"/// Full Fresnel equations \n"\
"float FresnelDielectric(float etai, float etat, float ndotwi, float ndotwt) \n"\
"{ \n"\
"    // Parallel and perpendicular polarization \n"\
"    float rparl = ((etat * ndotwi) - (etai * ndotwt)) / ((etat * ndotwi) + (etai * ndotwt)); \n"\
"    float rperp = ((etai * ndotwi) - (etat * ndotwt)) / ((etai * ndotwi) + (etat * ndotwt)); \n"\
"    return (rparl*rparl + rperp*rperp) * 0.5f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Microfacet Beckmann \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Beckmann_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = dot(m, n); \n"\
" \n"\
"    if (ndotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = sinmn / ndotm; \n"\
"    float a2 = roughness * roughness; \n"\
" \n"\
"    return (1.f / (PI * a2 * ndotm2 * ndotm2)) * native_exp(-tanmn * tanmn / a2); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Beckmann_GetPdf( \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 m = normalize(wi + wo); \n"\
"    float wodotm = dot(wo, m); \n"\
" \n"\
"    if (wodotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    // \n"\
"    float mpdf = MicrofacetDistribution_Beckmann_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
" \n"\
"    return mpdf / (4.f * wodotm); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_Sample(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_SampleNormal(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"float MicrofacetDistribution_Beckmann_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = sinnv / ndotv; \n"\
"    float a = tannv > DENOM_EPS ? 1.f / (roughness * tannv) : 0.f; \n"\
"    float a2 = a * a; \n"\
" \n"\
"    if (a < 1.6f) \n"\
"        return 1.f; \n"\
" \n"\
"    return (3.535f * a + 2.181f * a2) / (1.f + 2.276f * a + 2.577f * a2); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Beckmann_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_Beckmann_G1(roughness, wi, wh, n) * MicrofacetDistribution_Beckmann_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
" \n"\
"float3 MicrofacetBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = 4.f * costhetao * costhetai; \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    return MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    MicrofacetDistribution_Beckmann_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet GGX \n"\
" */ \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_GGX_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = fabs(dot(m, n)); \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = ndotm > DENOM_EPS ? sinmn / ndotm : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    float denom = (PI * ndotm2 * ndotm2 * (a2 + tanmn * tanmn) * (a2 + tanmn * tanmn)); \n"\
"    return denom > DENOM_EPS ? (a2 / denom) : 0.f; \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_GGX_GetPdf( \n"\
"    // Halfway vector \n"\
"    float3 m, \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float mpdf = MicrofacetDistribution_GGX_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (4.f * fabs(dot(wo, m))); \n"\
" \n"\
"    return denom > DENOM_EPS ? mpdf / denom : 0.f; \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_Sample( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*fabs(dot(wi, wh)) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_SampleNormal( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Differential geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"// \n"\
"float MicrofacetDistribution_GGX_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = ndotv > 0.f ? sinnv / ndotv : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    return 2.f / (1.f + native_sqrt(1.f + a2 * tannv * tannv)); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_GGX_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_GGX_G1(roughness, wi, wh, n) * MicrofacetDistribution_GGX_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > 0.f ? F * ks * MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float3 wh = normalize(wo + wi); \n"\
" \n"\
"    return MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    MicrofacetDistribution_GGX_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
" \n"\
"    return MicrofacetGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet Blinn \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Blinn_D(float shininess, float3 w, float3 n) \n"\
"{ \n"\
"    float ndotw = fabs(dot(n, w)); \n"\
"    return (1.f / (2 * PI)) * (shininess + 2) * native_powr(ndotw, shininess); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Blinn_GetPdf(// Shininess \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 wh = normalize(wi + wo); \n"\
"    // costheta \n"\
"    float ndotwh = dot(dg->n, wh); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (2.f * PI * 4.f * dot(wo, wh)); \n"\
"    return denom > DENOM_EPS ? ((shininess + 1.f) * native_powr(ndotwh, shininess)) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Blinn_Sample(// Shininess param \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    // \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float costheta = native_powr(r1, 1.f / (shininess + 1.f)); \n"\
"    float sintheta = native_sqrt(1.f - costheta * costheta); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - cosphi * cosphi); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Blinn_G(float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    float ndotwh = fabs(dot(n, wh)); \n"\
"    float ndotwo = fabs(dot(n, wo)); \n"\
"    float ndotwi = fabs(dot(n, wi)); \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    return min(1.f, min(2.f * ndotwh * ndotwo / wodotwh, 2.f * ndotwh * ndotwi / wodotwh)); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF evaluation \n"\
"float3 MicrofacetBlinn_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
"    const float shininess = dg->mat.ns; \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Blinn_G(wi, wo, wh, dg->n) * MicrofacetDistribution_Blinn_D(shininess, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float MicrofacetBlinn_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float shininess = dg->mat.ns; \n"\
"    return MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 MicrofacetBlinn_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    if (dot(dg->n, wi) <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float shininess = dg->mat.ns; \n"\
"    MicrofacetDistribution_Blinn_Sample(shininess, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBlinn_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/* \n"\
" Lambert BRDF \n"\
" */ \n"\
" /// Lambert BRDF evaluation \n"\
"float3 Lambert_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Lambert_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return fabs(dot(dg->n, wo)) / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Lambert_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    *wo = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *pdf = fabs(dot(dg->n, *wo)) / PI; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal reflection BRDF \n"\
" */ \n"\
"float3 IdealReflect_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Translucent_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float3 n = ndotwi > DENOM_EPS ? -dg->n : dg->n; \n"\
" \n"\
"    *wo = normalize(Sample_MapToHemisphere(sample, n, 1.f)); \n"\
" \n"\
"    *pdf = fabs(dot(n, *wo)) / PI; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"// Lambert BRDF evaluation \n"\
"float3 Translucent_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Translucent_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0) \n"\
"        return 0.f; \n"\
" \n"\
"    return fabs(ndotwo) / PI; \n"\
"} \n"\
" \n"\
"float IdealReflect_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealReflect_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    // Mirror reflect wi \n"\
"    *wo = normalize(2.f * ndotwi * dg->n - wi); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // Return reflectance value \n"\
"    return coswo > DENOM_EPS ? (F * ks * (1.f / coswo)) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal refraction BTDF \n"\
" */ \n"\
" \n"\
"float3 IdealRefract_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float IdealRefract_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealRefract_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float cosi = dot(dg->n, wi); \n"\
" \n"\
"    bool entering = cosi > 0.f; \n"\
"    float3 n = dg->n; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (!entering) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        n = -dg->n; \n"\
"        cosi = -cosi; \n"\
"    } \n"\
" \n"\
"    float eta = etai / etat; \n"\
"    float sini2 = 1.f - cosi * cosi; \n"\
" \n"\
"    float sint2 = eta * eta * sini2; \n"\
" \n"\
"    if (sint2 >= 1.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
" \n"\
"    // Transmitted ray \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *wo = normalize(-n * cost + normalize(n * cosi - wi) * native_sqrt(max(sint2, 0.f))); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    return cost > 0.0001f ? F * (((etai * etai) / (etat * etat)) * ks / cost) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_GGX_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi == 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_GGX_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionGGX_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_Beckmann_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionBeckmann_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 Passthrough_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
" \n"\
"    *wo = -wi; \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    //  \n"\
"    return coswo > 0.0001f ? (1.f / coswo) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Dispatch functions \n"\
" */ \n"\
"float3 Bxdf_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 Bxdf_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at w \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kPassthrough: \n"\
"        return Passthrough_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Bxdf_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kPassthrough: \n"\
"        return 0.f; \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Emissive BRDF sampling \n"\
"float3 Emissive_GetLe( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    return kd; \n"\
"} \n"\
" \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsSingular(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealReflect || dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough; \n"\
"} \n"\
" \n"\
"/// BxDF emission check \n"\
"bool Bxdf_IsEmissive(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kEmissive; \n"\
"} \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsBtdf(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough || dg->mat.type == kTranslucent || \n"\
"        dg->mat.type == kMicrofacetRefractionGGX || dg->mat.type == kMicrofacetRefractionBeckmann; \n"\
"} \n"\
" \n"\
"#endif // BXDF_CL \n"\
;
static const char g_camera_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef CAMERA_CL \n"\
"#define CAMERA_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SAMPLING_CL \n"\
"#define SAMPLING_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToHemisphere( \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Hemisphere normal \n"\
"                        float3 n, \n"\
"                        // Cos power \n"\
"                        float e \n"\
"                        ) \n"\
"{ \n"\
"    // Construct basis \n"\
"    float3 u = GetOrthoVector(n); \n"\
"    float3 v = cross(u, n); \n"\
"    u = cross(n, v); \n"\
"     \n"\
"    // Calculate 2D sample \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
"     \n"\
"    // Transform to spherical coordinates \n"\
"    float sinpsi = sin(2*PI*r1); \n"\
"    float cospsi = cos(2*PI*r1); \n"\
"    float costheta = pow(1.f - r2, 1.f/(e + 1.f)); \n"\
"    float sintheta = sqrt(1.f - costheta * costheta); \n"\
"     \n"\
"    // Return the result \n"\
"    return normalize(u * sintheta * cospsi + v * sintheta * sinpsi + n * costheta); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDisk( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float r = native_sqrt(sample.x);  \n"\
"    float theta = 2 * PI * sample.y; \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDiskConcentric( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float2 offset = 2.f * sample - make_float2(1.f, 1.f); \n"\
" \n"\
"    if (offset.x == 0 && offset.y == 0) return 0.f; \n"\
" \n"\
"    float theta, r; \n"\
" \n"\
"    if (fabs(offset.x) > fabs(offset.y))  \n"\
"    { \n"\
"        r = offset.x; \n"\
"        theta = PI / 4.f * (offset.y / offset.x); \n"\
"    } \n"\
"    else  \n"\
"    { \n"\
"        r = offset.y; \n"\
"        theta = PI / 2.f * ( 1.f - 0.5f * (offset.x / offset.y)); \n"\
"    } \n"\
"     \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToSphere( \n"\
"                        // Sample \n"\
"                        float2 sample \n"\
"                        ) \n"\
"{ \n"\
"    float z = 1.f - 2.f * sample.x; \n"\
"    float r = native_sqrt(max(0.f, 1.f - z*z)); \n"\
"    float phi = 2.f * PI * sample.y; \n"\
"    float x = cos(phi); \n"\
"    float y = sin(phi); \n"\
"     \n"\
"    // Return the result \n"\
"    return make_float3(x,y,z); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToPolygon(int n, float2 sample, float sample1) \n"\
"{ \n"\
"    float theta = 2.f * PI / n; \n"\
" \n"\
"    int edge = clamp((int)(sample1 * n), 0, n - 1); \n"\
" \n"\
"    float t = native_sqrt(sample.x); \n"\
"    float u = 1.f - t; \n"\
"    float v = t * sample.y; \n"\
" \n"\
"    float2 v1 = make_float2(native_cos(theta * edge), native_sin(theta * edge)); \n"\
"    float2 v2 = make_float2(native_cos(theta * (edge + 1)), native_sin(theta * (edge + 1))); \n"\
" \n"\
" \n"\
"    return u*v1 + v*v2;; \n"\
"} \n"\
" \n"\
"/// Power heuristic for multiple importance sampling \n"\
"float PowerHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f*f) / (f*f + g*g); \n"\
"} \n"\
" \n"\
"/// Balance heuristic for multiple importance sampling \n"\
"float BalanceHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f) / (f + g); \n"\
"} \n"\
" \n"\
"typedef struct \n"\
"{ \n"\
"    uint seq; \n"\
"    uint s0; \n"\
"    uint s1; \n"\
"    uint s2; \n"\
"} SobolSampler; \n"\
" \n"\
"float2 UniformSampler_Sample2D(Rng* rng) \n"\
"{ \n"\
"    float2 sample; \n"\
"    sample.x = RandFloat(rng); \n"\
"    sample.y = RandFloat(rng); \n"\
"    return sample; \n"\
"} \n"\
" \n"\
"#define MATSIZE 52 \n"\
" \n"\
"// The code is taken from: http://gruenschloss.org/sobol/kuo-2d-proj-single-precision.zip \n"\
"//  \n"\
"float SobolSampler_Sample1D(uint index, uint dimension, uint scramble, __global uint const* mat) \n"\
"{ \n"\
"    uint result = scramble; \n"\
"    for (uint i = dimension * MATSIZE; index; index >>= 1, ++i) \n"\
"    { \n"\
"        if (index & 1) \n"\
"            result ^= mat[i]; \n"\
"    } \n"\
" \n"\
"    return result * (1.f / (1UL << 32)); \n"\
"} \n"\
" \n"\
" \n"\
"#endif // SAMPLING_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Camera descriptor \n"\
"/// \n"\
"typedef struct _Camera \n"\
"    { \n"\
"        // Camera coordinate frame \n"\
"        float3 forward; \n"\
"        float3 right; \n"\
"        float3 up; \n"\
"        float3 p; \n"\
" \n"\
"        // Image plane width & height in current units \n"\
"        float2 dim; \n"\
" \n"\
"        // Near and far Z \n"\
"        float2 zcap; \n"\
"        // Focal lenght \n"\
"        float focal_length; \n"\
"        // Camera aspect ratio \n"\
"        float aspect; \n"\
"        float focus_distance; \n"\
"        float aperture; \n"\
"    } Camera; \n"\
" \n"\
" \n"\
"/// Ray generation kernel for perspective camera. \n"\
"/// Rays are generated from camera position to viewing plane \n"\
"/// using random sample distribution within the pixel. \n"\
"/// \n"\
"__kernel void PerspectiveCamera_GeneratePaths( \n"\
"                             // Camera descriptor \n"\
"                             __global Camera const* camera, \n"\
"                             // Image resolution \n"\
"                             int imgwidth, \n"\
"                             int imgheight, \n"\
"                             // RNG seed value \n"\
"                             int randseed, \n"\
"                             // Output rays \n"\
"                             __global ray* rays, \n"\
"                             __global SobolSampler* samplers, \n"\
"                             __global uint const* sobolmat, \n"\
"                             int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"                             ,__global Path* paths \n"\
"#endif \n"\
"        ) \n"\
"{ \n"\
"    int2 globalid; \n"\
"    globalid.x  = get_global_id(0); \n"\
"    globalid.y  = get_global_id(1); \n"\
" \n"\
"    // Check borders \n"\
"    if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"    { \n"\
"        // Get pointer to ray to handle \n"\
"        __global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        __global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"        // Prepare RNG \n"\
"        Rng rng; \n"\
"        InitRng(randseed +  globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"#ifdef SOBOL \n"\
"        __global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"        if (reset) \n"\
"        { \n"\
"            sampler->seq = 0; \n"\
"            sampler->s0 = RandUint(&rng); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            sampler->seq++; \n"\
"        } \n"\
" \n"\
"        float2 sample0; \n"\
"        sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"        sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
"#else \n"\
"        float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"        // Calculate [0..1] image plane sample \n"\
"        float2 imgsample; \n"\
"        imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"        imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"        // Transform into [-0.5, 0.5] \n"\
"        float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"        // Transform into [-dim/2, dim/2] \n"\
"        float2 csample = hsample * camera->dim; \n"\
" \n"\
"        // Calculate direction to image plane \n"\
"        myray->d.xyz = normalize(camera->focal_length * camera->forward + csample.x * camera->right + csample.y * camera->up); \n"\
"        // Origin == camera position + nearz * d \n"\
"        myray->o.xyz = camera->p + camera->zcap.x * myray->d.xyz; \n"\
"        // Max T value = zfar - znear since we moved origin to znear \n"\
"        myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"        // Generate random time from 0 to 1 \n"\
"        myray->d.w = sample0.x; \n"\
"        // Set ray max \n"\
"        myray->extra.x = 0xFFFFFFFF; \n"\
"        myray->extra.y = 0xFFFFFFFF; \n"\
"        Ray_SetExtra(myray, 1.f); \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"        mypath->volume = -1; \n"\
"        mypath->flags = 0; \n"\
"        mypath->active = 0xFF; \n"\
"#endif \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Ray generation kernel for perspective camera. \n"\
"/// Rays are generated from camera position to viewing plane \n"\
"/// using random sample distribution within the pixel. \n"\
"/// \n"\
"__kernel void PerspectiveCameraDof_GeneratePaths( \n"\
"    // Camera descriptor \n"\
"    __global Camera const* camera, \n"\
"    // Image resolution \n"\
"    int imgwidth, \n"\
"    int imgheight, \n"\
"    // RNG seed value \n"\
"    int randseed, \n"\
"    // Output rays \n"\
"    __global ray* rays, \n"\
"    __global SobolSampler* samplers, \n"\
"    __global uint const* sobolmat, \n"\
"    int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"    , __global Path* paths \n"\
"#endif \n"\
"    ) \n"\
"{ \n"\
"    int2 globalid; \n"\
"    globalid.x = get_global_id(0); \n"\
"    globalid.y = get_global_id(1); \n"\
" \n"\
"    // Check borders \n"\
"    if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"    { \n"\
"        // Get pointer to ray to handle \n"\
"        __global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        __global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"        // Prepare RNG \n"\
"        Rng rng; \n"\
"        InitRng(randseed + globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"        // \n"\
"#ifdef SOBOL \n"\
"        __global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"        if (reset) \n"\
"        { \n"\
"            sampler->seq = 0; \n"\
"            sampler->s0 = RandUint(&rng); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            sampler->seq++; \n"\
"        } \n"\
" \n"\
"        float2 sample0; \n"\
"        sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"        sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
" \n"\
"        float2 sample1; \n"\
"        sample1.x = SobolSampler_Sample1D(sampler->seq, kLensX, sampler->s0, sobolmat); \n"\
"        sample1.y = SobolSampler_Sample1D(sampler->seq, kLensY, sampler->s0, sobolmat); \n"\
"#else \n"\
"        float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"        float2 sample1 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"        // Calculate [0..1] image plane sample \n"\
"        float2 imgsample; \n"\
"        imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"        imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"        // Transform into [-0.5, 0.5] \n"\
"        float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"        // Transform into [-dim/2, dim/2] \n"\
"        float2 csample = hsample * camera->dim; \n"\
" \n"\
" \n"\
"        float2 lsample = camera->aperture * Sample_MapToDiskConcentric(sample1); \n"\
"        float2 fpsample = csample * camera->focus_distance / camera->focal_length; \n"\
"        float2 cdir = fpsample - lsample; \n"\
" \n"\
"        float3 o = camera->p + lsample.x * camera->right + lsample.y * camera->up; \n"\
"        float3 d = normalize(camera->forward * camera->focus_distance + camera->right * cdir.x + camera->up * cdir.y); \n"\
" \n"\
" \n"\
"        // Calculate direction to image plane \n"\
"        myray->d.xyz = d; \n"\
"        // Origin == camera position + nearz * d \n"\
"        myray->o.xyz = o; \n"\
"        // Max T value = zfar - znear since we moved origin to znear \n"\
"        myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"        // Generate random time from 0 to 1 \n"\
"        myray->d.w = sample0.x; \n"\
"        // Set ray max \n"\
"        myray->extra.x = 0xFFFFFFFF; \n"\
"        myray->extra.y = 0xFFFFFFFF; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"        mypath->volume = -1; \n"\
"        mypath->flags = 0; \n"\
"        mypath->active = 0xFF; \n"\
"#endif \n"\
"    } \n"\
"} \n"\
" \n"\
"#define M_PI 3.14159265358979323846 \n"\
" \n"\
"/// Ray generation kernel for spherical camera. \n"\
"/// \n"\
"__kernel void SphericalCamera_GeneratePaths( \n"\
"	// Camera descriptor \n"\
"	__global Camera const* camera, \n"\
"	// Image resolution \n"\
"	int imgwidth, \n"\
"	int imgheight, \n"\
"	// RNG seed value \n"\
"	int randseed, \n"\
"	// Output rays \n"\
"	__global ray* rays, \n"\
"	__global SobolSampler* samplers, \n"\
"	__global uint const* sobolmat, \n"\
"	int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"	, __global Path* paths \n"\
"#endif \n"\
") \n"\
"{ \n"\
"	int2 globalid; \n"\
"	globalid.x = get_global_id(0); \n"\
"	globalid.y = get_global_id(1); \n"\
" \n"\
"	// Check borders \n"\
"	if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"	{ \n"\
"		// Get pointer to ray to handle \n"\
"		__global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"		__global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"		// Prepare RNG \n"\
"		Rng rng; \n"\
"		InitRng(randseed + globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"#ifdef SOBOL \n"\
"		__global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"		if (reset) \n"\
"		{ \n"\
"			sampler->seq = 0; \n"\
"			sampler->s0 = RandUint(&rng); \n"\
"		} else \n"\
"		{ \n"\
"			sampler->seq++; \n"\
"		} \n"\
" \n"\
"		float2 sample0; \n"\
"		sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"		sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
"#else \n"\
"		float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"		// Calculate [0..1] image plane sample \n"\
"		float2 imgsample; \n"\
"		imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"		imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"		// Transform into [-0.5, 0.5] \n"\
"		float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"		// Transform into [-dim/2, dim/2] \n"\
"		float2 csample = hsample * camera->dim; \n"\
" \n"\
" \n"\
"		float phi = (2.0 * M_PI) * (imgsample.x); \n"\
"		float theta = (M_PI) * (imgsample.y); \n"\
" \n"\
"		float4 m1, m2, m3, m4; \n"\
"		float4 n1, n2, n3, n4; \n"\
" \n"\
"		m1 = (float4) { cos(phi), 0.0, -sin(phi), 0.0 }; \n"\
"		m2 = (float4) { 0.0, 1.0, 0.0, 0.0 }; \n"\
"		m3 = (float4) { sin(phi), 0.0, cos(phi), 0.0 }; \n"\
"		m4 = (float4) { 0.0, 0.0, 0.0, 1.0 }; \n"\
" \n"\
" \n"\
"		n1 = (float4) { cos(theta), sin(theta), 0.0, 0.0 }; \n"\
"		n2 = (float4) { -sin(theta), cos(theta), 0.0, 0.0 }; \n"\
"		n3 = (float4) { 0.0, 0.0, 1.0, 0.0 }; \n"\
"		n4 = (float4) { 0.0, 0.0, 0.0, 1.0 }; \n"\
" \n"\
"		//myray->d.xyz = normalize(camera->focal_length * transform_vector(transform_vector(-camera->up.xyz, n1, n2, n3, n4), m1, m2, m3, m4)); \n"\
"		myray->d.xyz = normalize(camera->focal_length * transform_vector(transform_vector(-(float3) { 0, 1, 0 }, n1, n2, n3, n4), m1, m2, m3, m4)); \n"\
" \n"\
"		// Calculate direction to image plane \n"\
"		//myray->d.xyz = normalize(camera->focal_length * camera->forward + csample.x * camera->right + csample.y * camera->up); \n"\
"		// Origin == camera position + nearz * d \n"\
"		myray->o.xyz = camera->p + camera->zcap.x * myray->d.xyz; \n"\
"		// Max T value = zfar - znear since we moved origin to znear \n"\
"		myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"		// Generate random time from 0 to 1 \n"\
"		myray->d.w = sample0.x; \n"\
"		// Set ray max \n"\
"		myray->extra.x = 0xFFFFFFFF; \n"\
"		myray->extra.y = 0xFFFFFFFF; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"		mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"		mypath->volume = -1; \n"\
"		mypath->flags = 0; \n"\
"		mypath->active = 0xFF; \n"\
"#endif \n"\
"	} \n"\
"} \n"\
" \n"\
" \n"\
"#endif // CAMERA_CL \n"\
;
static const char g_integrator_ao_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SAMPLING_CL \n"\
"#define SAMPLING_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToHemisphere( \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Hemisphere normal \n"\
"                        float3 n, \n"\
"                        // Cos power \n"\
"                        float e \n"\
"                        ) \n"\
"{ \n"\
"    // Construct basis \n"\
"    float3 u = GetOrthoVector(n); \n"\
"    float3 v = cross(u, n); \n"\
"    u = cross(n, v); \n"\
"     \n"\
"    // Calculate 2D sample \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
"     \n"\
"    // Transform to spherical coordinates \n"\
"    float sinpsi = sin(2*PI*r1); \n"\
"    float cospsi = cos(2*PI*r1); \n"\
"    float costheta = pow(1.f - r2, 1.f/(e + 1.f)); \n"\
"    float sintheta = sqrt(1.f - costheta * costheta); \n"\
"     \n"\
"    // Return the result \n"\
"    return normalize(u * sintheta * cospsi + v * sintheta * sinpsi + n * costheta); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDisk( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float r = native_sqrt(sample.x);  \n"\
"    float theta = 2 * PI * sample.y; \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDiskConcentric( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float2 offset = 2.f * sample - make_float2(1.f, 1.f); \n"\
" \n"\
"    if (offset.x == 0 && offset.y == 0) return 0.f; \n"\
" \n"\
"    float theta, r; \n"\
" \n"\
"    if (fabs(offset.x) > fabs(offset.y))  \n"\
"    { \n"\
"        r = offset.x; \n"\
"        theta = PI / 4.f * (offset.y / offset.x); \n"\
"    } \n"\
"    else  \n"\
"    { \n"\
"        r = offset.y; \n"\
"        theta = PI / 2.f * ( 1.f - 0.5f * (offset.x / offset.y)); \n"\
"    } \n"\
"     \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToSphere( \n"\
"                        // Sample \n"\
"                        float2 sample \n"\
"                        ) \n"\
"{ \n"\
"    float z = 1.f - 2.f * sample.x; \n"\
"    float r = native_sqrt(max(0.f, 1.f - z*z)); \n"\
"    float phi = 2.f * PI * sample.y; \n"\
"    float x = cos(phi); \n"\
"    float y = sin(phi); \n"\
"     \n"\
"    // Return the result \n"\
"    return make_float3(x,y,z); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToPolygon(int n, float2 sample, float sample1) \n"\
"{ \n"\
"    float theta = 2.f * PI / n; \n"\
" \n"\
"    int edge = clamp((int)(sample1 * n), 0, n - 1); \n"\
" \n"\
"    float t = native_sqrt(sample.x); \n"\
"    float u = 1.f - t; \n"\
"    float v = t * sample.y; \n"\
" \n"\
"    float2 v1 = make_float2(native_cos(theta * edge), native_sin(theta * edge)); \n"\
"    float2 v2 = make_float2(native_cos(theta * (edge + 1)), native_sin(theta * (edge + 1))); \n"\
" \n"\
" \n"\
"    return u*v1 + v*v2;; \n"\
"} \n"\
" \n"\
"/// Power heuristic for multiple importance sampling \n"\
"float PowerHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f*f) / (f*f + g*g); \n"\
"} \n"\
" \n"\
"/// Balance heuristic for multiple importance sampling \n"\
"float BalanceHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f) / (f + g); \n"\
"} \n"\
" \n"\
"typedef struct \n"\
"{ \n"\
"    uint seq; \n"\
"    uint s0; \n"\
"    uint s1; \n"\
"    uint s2; \n"\
"} SobolSampler; \n"\
" \n"\
"float2 UniformSampler_Sample2D(Rng* rng) \n"\
"{ \n"\
"    float2 sample; \n"\
"    sample.x = RandFloat(rng); \n"\
"    sample.y = RandFloat(rng); \n"\
"    return sample; \n"\
"} \n"\
" \n"\
"#define MATSIZE 52 \n"\
" \n"\
"// The code is taken from: http://gruenschloss.org/sobol/kuo-2d-proj-single-precision.zip \n"\
"//  \n"\
"float SobolSampler_Sample1D(uint index, uint dimension, uint scramble, __global uint const* mat) \n"\
"{ \n"\
"    uint result = scramble; \n"\
"    for (uint i = dimension * MATSIZE; index; index >>= 1, ++i) \n"\
"    { \n"\
"        if (index & 1) \n"\
"            result ^= mat[i]; \n"\
"    } \n"\
" \n"\
"    return result * (1.f / (1UL << 32)); \n"\
"} \n"\
" \n"\
" \n"\
"#endif // SAMPLING_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef NORMALMAP_CL \n"\
"#define NORMALMAP_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"void ApplyNormalMap(DifferentialGeometry* dg, TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    int nmapidx = dg->mat.nmapidx; \n"\
"    if (nmapidx != -1) \n"\
"    { \n"\
"        // Now n, dpdu, dpdv is orthonormal basis \n"\
"        float3 mappednormal = 2.f * Texture_Sample2D(dg->uv, TEXTURE_ARGS_IDX(nmapidx)).xyz - make_float3(1.f, 1.f, 1.f); \n"\
" \n"\
"        // Return mapped version \n"\
"        dg->n = normalize(mappednormal.z *  dg->n * 0.5f + mappednormal.x * dg->dpdu + mappednormal.y * dg->dpdv); \n"\
"    } \n"\
"} \n"\
" \n"\
"void ApplyBumpMap(DifferentialGeometry* dg, TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    int nmapidx = dg->mat.nmapidx; \n"\
"    if (nmapidx != -1) \n"\
"    { \n"\
"        // Now n, dpdu, dpdv is orthonormal basis \n"\
"        float3 mappednormal = 2.f * Texture_SampleBump(dg->uv, TEXTURE_ARGS_IDX(nmapidx)) - make_float3(1.f, 1.f, 1.f); \n"\
" \n"\
"        // Return mapped version \n"\
"        dg->n = normalize(mappednormal.z * dg->n + mappednormal.x * dg->dpdu + mappednormal.y * dg->dpdv); \n"\
"    } \n"\
"} \n"\
" \n"\
"#endif // NORMALMAP_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef BXDF_CL \n"\
"#define BXDF_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"#define DENOM_EPS 0.0f \n"\
"#define ROUGHNESS_EPS 0.0001f \n"\
" \n"\
"enum Bxdf \n"\
"{ \n"\
"    kZero, \n"\
"    kLambert, \n"\
"    kIdealReflect, \n"\
"    kIdealRefract, \n"\
"    kMicrofacetBlinn, \n"\
"    kMicrofacetBeckmann, \n"\
"    kMicrofacetGGX, \n"\
"    kLayered, \n"\
"    kFresnelBlend, \n"\
"    kMix, \n"\
"    kEmissive, \n"\
"    kPassthrough, \n"\
"    kTranslucent, \n"\
"    kMicrofacetRefractionGGX, \n"\
"    kMicrofacetRefractionBeckmann \n"\
"}; \n"\
" \n"\
"enum BxdfFlags \n"\
"{ \n"\
"    kReflection = (1 << 0), \n"\
"    kTransmission = (1 << 1), \n"\
"    kDiffuse = (1 << 2), \n"\
"    kSpecular = (1 << 3), \n"\
"    kGlossy = (1 << 4), \n"\
"    kAllReflection = kReflection | kDiffuse | kSpecular | kGlossy, \n"\
"    kAllTransmission = kTransmission | kDiffuse | kSpecular | kGlossy, \n"\
"    kAll = kReflection | kTransmission | kDiffuse | kSpecular | kGlossy \n"\
"}; \n"\
" \n"\
" \n"\
"/// Schlick's approximation of Fresnel equtions \n"\
"float SchlickFresnel(float eta, float ndotw) \n"\
"{ \n"\
"    const float f = ((1.f - eta) / (1.f + eta)) * ((1.f - eta) / (1.f + eta)); \n"\
"    const float m = 1.f - fabs(ndotw); \n"\
"    const float m2 = m*m; \n"\
"    return f + (1.f - f) * m2 * m2 * m; \n"\
"} \n"\
" \n"\
"/// Full Fresnel equations \n"\
"float FresnelDielectric(float etai, float etat, float ndotwi, float ndotwt) \n"\
"{ \n"\
"    // Parallel and perpendicular polarization \n"\
"    float rparl = ((etat * ndotwi) - (etai * ndotwt)) / ((etat * ndotwi) + (etai * ndotwt)); \n"\
"    float rperp = ((etai * ndotwi) - (etat * ndotwt)) / ((etai * ndotwi) + (etat * ndotwt)); \n"\
"    return (rparl*rparl + rperp*rperp) * 0.5f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Microfacet Beckmann \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Beckmann_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = dot(m, n); \n"\
" \n"\
"    if (ndotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = sinmn / ndotm; \n"\
"    float a2 = roughness * roughness; \n"\
" \n"\
"    return (1.f / (PI * a2 * ndotm2 * ndotm2)) * native_exp(-tanmn * tanmn / a2); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Beckmann_GetPdf( \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 m = normalize(wi + wo); \n"\
"    float wodotm = dot(wo, m); \n"\
" \n"\
"    if (wodotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    // \n"\
"    float mpdf = MicrofacetDistribution_Beckmann_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
" \n"\
"    return mpdf / (4.f * wodotm); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_Sample(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_SampleNormal(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"float MicrofacetDistribution_Beckmann_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = sinnv / ndotv; \n"\
"    float a = tannv > DENOM_EPS ? 1.f / (roughness * tannv) : 0.f; \n"\
"    float a2 = a * a; \n"\
" \n"\
"    if (a < 1.6f) \n"\
"        return 1.f; \n"\
" \n"\
"    return (3.535f * a + 2.181f * a2) / (1.f + 2.276f * a + 2.577f * a2); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Beckmann_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_Beckmann_G1(roughness, wi, wh, n) * MicrofacetDistribution_Beckmann_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
" \n"\
"float3 MicrofacetBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = 4.f * costhetao * costhetai; \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    return MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    MicrofacetDistribution_Beckmann_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet GGX \n"\
" */ \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_GGX_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = fabs(dot(m, n)); \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = ndotm > DENOM_EPS ? sinmn / ndotm : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    float denom = (PI * ndotm2 * ndotm2 * (a2 + tanmn * tanmn) * (a2 + tanmn * tanmn)); \n"\
"    return denom > DENOM_EPS ? (a2 / denom) : 0.f; \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_GGX_GetPdf( \n"\
"    // Halfway vector \n"\
"    float3 m, \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float mpdf = MicrofacetDistribution_GGX_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (4.f * fabs(dot(wo, m))); \n"\
" \n"\
"    return denom > DENOM_EPS ? mpdf / denom : 0.f; \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_Sample( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*fabs(dot(wi, wh)) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_SampleNormal( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Differential geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"// \n"\
"float MicrofacetDistribution_GGX_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = ndotv > 0.f ? sinnv / ndotv : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    return 2.f / (1.f + native_sqrt(1.f + a2 * tannv * tannv)); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_GGX_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_GGX_G1(roughness, wi, wh, n) * MicrofacetDistribution_GGX_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > 0.f ? F * ks * MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float3 wh = normalize(wo + wi); \n"\
" \n"\
"    return MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    MicrofacetDistribution_GGX_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
" \n"\
"    return MicrofacetGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet Blinn \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Blinn_D(float shininess, float3 w, float3 n) \n"\
"{ \n"\
"    float ndotw = fabs(dot(n, w)); \n"\
"    return (1.f / (2 * PI)) * (shininess + 2) * native_powr(ndotw, shininess); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Blinn_GetPdf(// Shininess \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 wh = normalize(wi + wo); \n"\
"    // costheta \n"\
"    float ndotwh = dot(dg->n, wh); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (2.f * PI * 4.f * dot(wo, wh)); \n"\
"    return denom > DENOM_EPS ? ((shininess + 1.f) * native_powr(ndotwh, shininess)) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Blinn_Sample(// Shininess param \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    // \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float costheta = native_powr(r1, 1.f / (shininess + 1.f)); \n"\
"    float sintheta = native_sqrt(1.f - costheta * costheta); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - cosphi * cosphi); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Blinn_G(float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    float ndotwh = fabs(dot(n, wh)); \n"\
"    float ndotwo = fabs(dot(n, wo)); \n"\
"    float ndotwi = fabs(dot(n, wi)); \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    return min(1.f, min(2.f * ndotwh * ndotwo / wodotwh, 2.f * ndotwh * ndotwi / wodotwh)); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF evaluation \n"\
"float3 MicrofacetBlinn_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
"    const float shininess = dg->mat.ns; \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Blinn_G(wi, wo, wh, dg->n) * MicrofacetDistribution_Blinn_D(shininess, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float MicrofacetBlinn_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float shininess = dg->mat.ns; \n"\
"    return MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 MicrofacetBlinn_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    if (dot(dg->n, wi) <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float shininess = dg->mat.ns; \n"\
"    MicrofacetDistribution_Blinn_Sample(shininess, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBlinn_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/* \n"\
" Lambert BRDF \n"\
" */ \n"\
" /// Lambert BRDF evaluation \n"\
"float3 Lambert_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Lambert_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return fabs(dot(dg->n, wo)) / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Lambert_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    *wo = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *pdf = fabs(dot(dg->n, *wo)) / PI; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal reflection BRDF \n"\
" */ \n"\
"float3 IdealReflect_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Translucent_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float3 n = ndotwi > DENOM_EPS ? -dg->n : dg->n; \n"\
" \n"\
"    *wo = normalize(Sample_MapToHemisphere(sample, n, 1.f)); \n"\
" \n"\
"    *pdf = fabs(dot(n, *wo)) / PI; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"// Lambert BRDF evaluation \n"\
"float3 Translucent_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Translucent_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0) \n"\
"        return 0.f; \n"\
" \n"\
"    return fabs(ndotwo) / PI; \n"\
"} \n"\
" \n"\
"float IdealReflect_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealReflect_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    // Mirror reflect wi \n"\
"    *wo = normalize(2.f * ndotwi * dg->n - wi); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // Return reflectance value \n"\
"    return coswo > DENOM_EPS ? (F * ks * (1.f / coswo)) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal refraction BTDF \n"\
" */ \n"\
" \n"\
"float3 IdealRefract_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float IdealRefract_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealRefract_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float cosi = dot(dg->n, wi); \n"\
" \n"\
"    bool entering = cosi > 0.f; \n"\
"    float3 n = dg->n; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (!entering) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        n = -dg->n; \n"\
"        cosi = -cosi; \n"\
"    } \n"\
" \n"\
"    float eta = etai / etat; \n"\
"    float sini2 = 1.f - cosi * cosi; \n"\
" \n"\
"    float sint2 = eta * eta * sini2; \n"\
" \n"\
"    if (sint2 >= 1.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
" \n"\
"    // Transmitted ray \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *wo = normalize(-n * cost + normalize(n * cosi - wi) * native_sqrt(max(sint2, 0.f))); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    return cost > 0.0001f ? F * (((etai * etai) / (etat * etat)) * ks / cost) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_GGX_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi == 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_GGX_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionGGX_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_Beckmann_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionBeckmann_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 Passthrough_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
" \n"\
"    *wo = -wi; \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    //  \n"\
"    return coswo > 0.0001f ? (1.f / coswo) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Dispatch functions \n"\
" */ \n"\
"float3 Bxdf_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 Bxdf_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at w \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kPassthrough: \n"\
"        return Passthrough_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Bxdf_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kPassthrough: \n"\
"        return 0.f; \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Emissive BRDF sampling \n"\
"float3 Emissive_GetLe( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    return kd; \n"\
"} \n"\
" \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsSingular(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealReflect || dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough; \n"\
"} \n"\
" \n"\
"/// BxDF emission check \n"\
"bool Bxdf_IsEmissive(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kEmissive; \n"\
"} \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsBtdf(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough || dg->mat.type == kTranslucent || \n"\
"        dg->mat.type == kMicrofacetRefractionGGX || dg->mat.type == kMicrofacetRefractionBeckmann; \n"\
"} \n"\
" \n"\
"#endif // BXDF_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef LIGHT_CL \n"\
"#define LIGHT_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
" \n"\
" \n"\
"bool IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, float* a, float* b) \n"\
"{ \n"\
"    const float3 e1 = v2 - v1; \n"\
"    const float3 e2 = v3 - v1; \n"\
"    const float3 s1 = cross(r->d.xyz, e2); \n"\
"    const float  invd = native_recip(dot(s1, e1)); \n"\
"    const float3 d = r->o.xyz - v1; \n"\
"    const float  b1 = dot(d, s1) * invd; \n"\
"    const float3 s2 = cross(d, e1); \n"\
"    const float  b2 = dot(r->d.xyz, s2) * invd; \n"\
"    const float temp = dot(e2, s2) * invd; \n"\
" \n"\
"    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f) \n"\
"    { \n"\
"        return false; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *a = b1; \n"\
"        *b = b2; \n"\
"        return true; \n"\
"    } \n"\
"} \n"\
" \n"\
"/* \n"\
" Environment light \n"\
" */ \n"\
"/// Get intensity for a given direction \n"\
"float3 EnvironmentLight_GetLe(// Light \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3* wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    // Sample envmap \n"\
"    *wo *= 100000.f; \n"\
"    // \n"\
"    return scene->envmapmul * Texture_SampleEnvMap(normalize(*wo), TEXTURE_ARGS_IDX(scene->envmapidx)); \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 EnvironmentLight_Sample(// Light \n"\
"                               Light const* light, \n"\
"                               // Scene \n"\
"                               Scene const* scene, \n"\
"                               // Geometry \n"\
"                               DifferentialGeometry const* dg, \n"\
"                               // Textures \n"\
"                               TEXTURE_ARG_LIST, \n"\
"                               // Sample \n"\
"                               float2 sample, \n"\
"                               // Direction to light source \n"\
"                               float3* wo, \n"\
"                               // PDF \n"\
"                               float* pdf \n"\
"                              ) \n"\
"{ \n"\
"    float3 d = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    // Generate direction \n"\
"    *wo = 100000.f * d; \n"\
" \n"\
"    // Envmap PDF \n"\
"    *pdf = fabs(dot(dg->n, normalize(d))) / PI; \n"\
" \n"\
"    // Sample envmap \n"\
"    return scene->envmapmul * Texture_SampleEnvMap(d, TEXTURE_ARGS_IDX(scene->envmapidx)); \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float EnvironmentLight_GetPdf( \n"\
"                              // Light \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3 wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return max(0.f, fabs(dot(dg->n, normalize(wo)))/ PI); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Area light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 AreaLight_GetLe(// Emissive object \n"\
"                       Light const* light, \n"\
"                       // Scene \n"\
"                       Scene const* scene, \n"\
"                       // Geometry \n"\
"                       DifferentialGeometry const* dg, \n"\
"                       // Direction to light source \n"\
"                       float3* wo, \n"\
"                       // Textures \n"\
"                       TEXTURE_ARG_LIST \n"\
"                       ) \n"\
"{ \n"\
"    ray r; \n"\
"    r.o.xyz = dg->p; \n"\
"    r.d.xyz = normalize(*wo); \n"\
" \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
" \n"\
" \n"\
"    // Intersect ray against this area light \n"\
" \n"\
"    float a, b; \n"\
"    if (IntersectTriangle(&r, v0, v1, v2, &a, &b)) \n"\
"    { \n"\
"        float3 n = normalize(transform_vector((1.f - a - b) * n0 + a * n1 + b * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"        float3 p = transform_point((1.f - a - b) * v0 + a * v1 + b * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float2 tx = (1.f - a - b) * uv0 + a * uv1 + b * uv2; \n"\
" \n"\
"        float3 d = p - dg->p; \n"\
"        float  ld = length(d); \n"\
"        *wo = p - dg->p; \n"\
" \n"\
"        int matidx = scene->materialids[shape.startidx / 3 + primidx]; \n"\
"        Material mat = scene->materials[matidx]; \n"\
" \n"\
"        const float3 ke = Texture_GetValue3f(mat.kx.xyz, tx, TEXTURE_ARGS_IDX(mat.kxmapidx)); \n"\
"        float ndotv = dot(n, -(normalize(d))); \n"\
"        return  ke; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 AreaLight_Sample(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST, \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Direction to light source \n"\
"                        float3* wo, \n"\
"                        // PDF \n"\
"                        float* pdf) \n"\
"{ \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
" \n"\
"    // Generate sample on triangle \n"\
"    float r0 = sample.x; \n"\
"    float r1 = sample.y; \n"\
" \n"\
"    // Convert random to barycentric coords \n"\
"    float2 uv; \n"\
"    uv.x = native_sqrt(r0) * (1.f - r1); \n"\
"    uv.y = native_sqrt(r0) * r1; \n"\
" \n"\
"    // Calculate barycentric position and normal \n"\
"    float3 n = normalize((1.f - uv.x - uv.y) * n0 + uv.x * n1 + uv.y * n2); \n"\
"    float3 p = (1.f - uv.x - uv.y) * v0 + uv.x * v1 + uv.y * v2; \n"\
"    float2 tx = (1.f - uv.x - uv.y) * uv0 + uv.x * uv1 + uv.y * uv2; \n"\
" \n"\
"    *wo = p - dg->p; \n"\
"    *pdf = 1.f / (length(cross(v2 - v0, v2 - v1)) * 0.5f); \n"\
" \n"\
"    int matidx = scene->materialids[shape.startidx / 3 + primidx]; \n"\
"    Material mat = scene->materials[matidx]; \n"\
" \n"\
"    const float3 ke = Texture_GetValue3f(mat.kx.xyz, tx, TEXTURE_ARGS_IDX(mat.kxmapidx)); \n"\
" \n"\
"    float3 v = -normalize(*wo); \n"\
" \n"\
"    float ndotv = dot(n, v); \n"\
" \n"\
"    if (ndotv > 0.f) \n"\
"    { \n"\
"        float denom = (length(*wo) * length(*wo)); \n"\
"        return denom > 0.f ? ke * ndotv / denom : 0.f; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float AreaLight_GetPdf(// Emissive object \n"\
"                       Light const* light, \n"\
"                       // Scene \n"\
"                       Scene const* scene, \n"\
"                       // Geometry \n"\
"                       DifferentialGeometry const* dg, \n"\
"                       // Direction to light source \n"\
"                       float3 wo, \n"\
"                       // Textures \n"\
"                       TEXTURE_ARG_LIST \n"\
"                       ) \n"\
"{ \n"\
"    ray r; \n"\
"    r.o.xyz = dg->p; \n"\
"    r.d.xyz = wo; \n"\
" \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Intersect ray against this area light \n"\
"    float a, b; \n"\
"    if (IntersectTriangle(&r, v0, v1, v2, &a, &b)) \n"\
"    { \n"\
"        float3 n = normalize(transform_vector((1.f - a - b) * n0 + a * n1 + b * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"        float3 p = transform_point((1.f - a - b) * v0 + a * v1 + b * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 d = p - dg->p; \n"\
"        float  ld = length(d); \n"\
" \n"\
"        float3 p0 = transform_point(v0, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 p1 = transform_point(v1, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 p2 = transform_point(v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
" \n"\
"        float area = 0.5f * length(cross(p2 - p0, p2 - p1)); \n"\
"        float denom = (fabs(dot(normalize(d), dg->n)) * area); \n"\
" \n"\
"        return denom > 0.f ? ld * ld / denom : 0.f; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/* \n"\
"Directional light \n"\
"*/ \n"\
"// Get intensity for a given direction \n"\
"float3 DirectionalLight_GetLe(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Direction to light source \n"\
"    float3* wo, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST \n"\
") \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 DirectionalLight_Sample(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Direction to light source \n"\
"    float3* wo, \n"\
"    // PDF \n"\
"    float* pdf) \n"\
"{ \n"\
"    *wo = 100000.f * -light->d; \n"\
"    *pdf = 1.f; \n"\
"    return light->intensity; \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float DirectionalLight_GetPdf(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Direction to light source \n"\
"    float3 wo, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST \n"\
") \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Point light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 PointLight_GetLe(// Emissive object \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3* wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 PointLight_Sample(// Emissive object \n"\
"                               Light const* light, \n"\
"                               // Scene \n"\
"                               Scene const* scene, \n"\
"                               // Geometry \n"\
"                               DifferentialGeometry const* dg, \n"\
"                               // Textures \n"\
"                               TEXTURE_ARG_LIST, \n"\
"                               // Sample \n"\
"                               float2 sample, \n"\
"                               // Direction to light source \n"\
"                               float3* wo, \n"\
"                               // PDF \n"\
"                               float* pdf) \n"\
"{ \n"\
"    *wo = light->p - dg->p; \n"\
"    *pdf = 1.f; \n"\
"    return light->intensity; \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float PointLight_GetPdf(// Emissive object \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3 wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Spot light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 SpotLight_GetLe(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Direction to light source \n"\
"                        float3* wo, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST \n"\
"                        ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 SpotLight_Sample(// Emissive object \n"\
"                         Light const* light, \n"\
"                         // Scene \n"\
"                         Scene const* scene, \n"\
"                         // Geometry \n"\
"                         DifferentialGeometry const* dg, \n"\
"                         // Textures \n"\
"                         TEXTURE_ARG_LIST, \n"\
"                         // Sample \n"\
"                         float2 sample, \n"\
"                         // Direction to light source \n"\
"                         float3* wo, \n"\
"                         // PDF \n"\
"                         float* pdf) \n"\
"{ \n"\
"    *wo = light->p - dg->p; \n"\
"    float ddotwo = dot(-normalize(*wo), light->d); \n"\
"     \n"\
"    if (ddotwo > light->oa) \n"\
"    { \n"\
"        *pdf = 1.f; \n"\
"        return ddotwo > light->ia ? light->intensity : light->intensity * (1.f - (light->ia - ddotwo) / (light->ia - light->oa)); \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float SpotLight_GetPdf(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Direction to light source \n"\
"                        float3 wo, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST \n"\
"                        ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/* \n"\
" Dispatch calls \n"\
" */ \n"\
" \n"\
"/// Get intensity for a given direction \n"\
"float3 Light_GetLe(// Light index \n"\
"                   int idx, \n"\
"                   // Scene \n"\
"                   Scene const* scene, \n"\
"                   // Geometry \n"\
"                   DifferentialGeometry const* dg, \n"\
"                   // Direction to light source \n"\
"                   float3* wo, \n"\
"                   // Textures \n"\
"                   TEXTURE_ARG_LIST \n"\
"                   ) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kArea: \n"\
"            return AreaLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kPoint: \n"\
"            return PointLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kSpot: \n"\
"            return SpotLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 Light_Sample(// Light index \n"\
"                    int idx, \n"\
"                    // Scene \n"\
"                    Scene const* scene, \n"\
"                    // Geometry \n"\
"                    DifferentialGeometry const* dg, \n"\
"                    // Textures \n"\
"                    TEXTURE_ARG_LIST, \n"\
"                    // Sample \n"\
"                    float2 sample, \n"\
"                    // Direction to light source \n"\
"                    float3* wo, \n"\
"                    // PDF \n"\
"                    float* pdf) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kArea: \n"\
"            return AreaLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kPoint: \n"\
"            return PointLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kSpot: \n"\
"            return SpotLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float Light_GetPdf(// Light index \n"\
"                   int idx, \n"\
"                   // Scene \n"\
"                   Scene const* scene, \n"\
"                   // Geometry \n"\
"                   DifferentialGeometry const* dg, \n"\
"                   // Direction to light source \n"\
"                   float3 wo, \n"\
"                   // Textures \n"\
"                   TEXTURE_ARG_LIST \n"\
"                   ) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kArea: \n"\
"            return AreaLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kPoint: \n"\
"            return PointLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kSpot: \n"\
"            return SpotLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Check if the light is singular \n"\
"bool Light_IsSingular(__global Light const* light) \n"\
"{ \n"\
"    return light->type == kPoint || \n"\
"        light->type == kSpot || \n"\
"        light->type == kDirectional; \n"\
"} \n"\
" \n"\
"#endif // LIGHT_CLnv \n"\
" \n"\
"#define NO_PATH_DATA \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef CAMERA_CL \n"\
"#define CAMERA_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SAMPLING_CL \n"\
"#define SAMPLING_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToHemisphere( \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Hemisphere normal \n"\
"                        float3 n, \n"\
"                        // Cos power \n"\
"                        float e \n"\
"                        ) \n"\
"{ \n"\
"    // Construct basis \n"\
"    float3 u = GetOrthoVector(n); \n"\
"    float3 v = cross(u, n); \n"\
"    u = cross(n, v); \n"\
"     \n"\
"    // Calculate 2D sample \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
"     \n"\
"    // Transform to spherical coordinates \n"\
"    float sinpsi = sin(2*PI*r1); \n"\
"    float cospsi = cos(2*PI*r1); \n"\
"    float costheta = pow(1.f - r2, 1.f/(e + 1.f)); \n"\
"    float sintheta = sqrt(1.f - costheta * costheta); \n"\
"     \n"\
"    // Return the result \n"\
"    return normalize(u * sintheta * cospsi + v * sintheta * sinpsi + n * costheta); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDisk( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float r = native_sqrt(sample.x);  \n"\
"    float theta = 2 * PI * sample.y; \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDiskConcentric( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float2 offset = 2.f * sample - make_float2(1.f, 1.f); \n"\
" \n"\
"    if (offset.x == 0 && offset.y == 0) return 0.f; \n"\
" \n"\
"    float theta, r; \n"\
" \n"\
"    if (fabs(offset.x) > fabs(offset.y))  \n"\
"    { \n"\
"        r = offset.x; \n"\
"        theta = PI / 4.f * (offset.y / offset.x); \n"\
"    } \n"\
"    else  \n"\
"    { \n"\
"        r = offset.y; \n"\
"        theta = PI / 2.f * ( 1.f - 0.5f * (offset.x / offset.y)); \n"\
"    } \n"\
"     \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToSphere( \n"\
"                        // Sample \n"\
"                        float2 sample \n"\
"                        ) \n"\
"{ \n"\
"    float z = 1.f - 2.f * sample.x; \n"\
"    float r = native_sqrt(max(0.f, 1.f - z*z)); \n"\
"    float phi = 2.f * PI * sample.y; \n"\
"    float x = cos(phi); \n"\
"    float y = sin(phi); \n"\
"     \n"\
"    // Return the result \n"\
"    return make_float3(x,y,z); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToPolygon(int n, float2 sample, float sample1) \n"\
"{ \n"\
"    float theta = 2.f * PI / n; \n"\
" \n"\
"    int edge = clamp((int)(sample1 * n), 0, n - 1); \n"\
" \n"\
"    float t = native_sqrt(sample.x); \n"\
"    float u = 1.f - t; \n"\
"    float v = t * sample.y; \n"\
" \n"\
"    float2 v1 = make_float2(native_cos(theta * edge), native_sin(theta * edge)); \n"\
"    float2 v2 = make_float2(native_cos(theta * (edge + 1)), native_sin(theta * (edge + 1))); \n"\
" \n"\
" \n"\
"    return u*v1 + v*v2;; \n"\
"} \n"\
" \n"\
"/// Power heuristic for multiple importance sampling \n"\
"float PowerHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f*f) / (f*f + g*g); \n"\
"} \n"\
" \n"\
"/// Balance heuristic for multiple importance sampling \n"\
"float BalanceHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f) / (f + g); \n"\
"} \n"\
" \n"\
"typedef struct \n"\
"{ \n"\
"    uint seq; \n"\
"    uint s0; \n"\
"    uint s1; \n"\
"    uint s2; \n"\
"} SobolSampler; \n"\
" \n"\
"float2 UniformSampler_Sample2D(Rng* rng) \n"\
"{ \n"\
"    float2 sample; \n"\
"    sample.x = RandFloat(rng); \n"\
"    sample.y = RandFloat(rng); \n"\
"    return sample; \n"\
"} \n"\
" \n"\
"#define MATSIZE 52 \n"\
" \n"\
"// The code is taken from: http://gruenschloss.org/sobol/kuo-2d-proj-single-precision.zip \n"\
"//  \n"\
"float SobolSampler_Sample1D(uint index, uint dimension, uint scramble, __global uint const* mat) \n"\
"{ \n"\
"    uint result = scramble; \n"\
"    for (uint i = dimension * MATSIZE; index; index >>= 1, ++i) \n"\
"    { \n"\
"        if (index & 1) \n"\
"            result ^= mat[i]; \n"\
"    } \n"\
" \n"\
"    return result * (1.f / (1UL << 32)); \n"\
"} \n"\
" \n"\
" \n"\
"#endif // SAMPLING_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Camera descriptor \n"\
"/// \n"\
"typedef struct _Camera \n"\
"    { \n"\
"        // Camera coordinate frame \n"\
"        float3 forward; \n"\
"        float3 right; \n"\
"        float3 up; \n"\
"        float3 p; \n"\
" \n"\
"        // Image plane width & height in current units \n"\
"        float2 dim; \n"\
" \n"\
"        // Near and far Z \n"\
"        float2 zcap; \n"\
"        // Focal lenght \n"\
"        float focal_length; \n"\
"        // Camera aspect ratio \n"\
"        float aspect; \n"\
"        float focus_distance; \n"\
"        float aperture; \n"\
"    } Camera; \n"\
" \n"\
" \n"\
"/// Ray generation kernel for perspective camera. \n"\
"/// Rays are generated from camera position to viewing plane \n"\
"/// using random sample distribution within the pixel. \n"\
"/// \n"\
"__kernel void PerspectiveCamera_GeneratePaths( \n"\
"                             // Camera descriptor \n"\
"                             __global Camera const* camera, \n"\
"                             // Image resolution \n"\
"                             int imgwidth, \n"\
"                             int imgheight, \n"\
"                             // RNG seed value \n"\
"                             int randseed, \n"\
"                             // Output rays \n"\
"                             __global ray* rays, \n"\
"                             __global SobolSampler* samplers, \n"\
"                             __global uint const* sobolmat, \n"\
"                             int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"                             ,__global Path* paths \n"\
"#endif \n"\
"        ) \n"\
"{ \n"\
"    int2 globalid; \n"\
"    globalid.x  = get_global_id(0); \n"\
"    globalid.y  = get_global_id(1); \n"\
" \n"\
"    // Check borders \n"\
"    if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"    { \n"\
"        // Get pointer to ray to handle \n"\
"        __global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        __global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"        // Prepare RNG \n"\
"        Rng rng; \n"\
"        InitRng(randseed +  globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"#ifdef SOBOL \n"\
"        __global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"        if (reset) \n"\
"        { \n"\
"            sampler->seq = 0; \n"\
"            sampler->s0 = RandUint(&rng); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            sampler->seq++; \n"\
"        } \n"\
" \n"\
"        float2 sample0; \n"\
"        sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"        sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
"#else \n"\
"        float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"        // Calculate [0..1] image plane sample \n"\
"        float2 imgsample; \n"\
"        imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"        imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"        // Transform into [-0.5, 0.5] \n"\
"        float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"        // Transform into [-dim/2, dim/2] \n"\
"        float2 csample = hsample * camera->dim; \n"\
" \n"\
"        // Calculate direction to image plane \n"\
"        myray->d.xyz = normalize(camera->focal_length * camera->forward + csample.x * camera->right + csample.y * camera->up); \n"\
"        // Origin == camera position + nearz * d \n"\
"        myray->o.xyz = camera->p + camera->zcap.x * myray->d.xyz; \n"\
"        // Max T value = zfar - znear since we moved origin to znear \n"\
"        myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"        // Generate random time from 0 to 1 \n"\
"        myray->d.w = sample0.x; \n"\
"        // Set ray max \n"\
"        myray->extra.x = 0xFFFFFFFF; \n"\
"        myray->extra.y = 0xFFFFFFFF; \n"\
"        Ray_SetExtra(myray, 1.f); \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"        mypath->volume = -1; \n"\
"        mypath->flags = 0; \n"\
"        mypath->active = 0xFF; \n"\
"#endif \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Ray generation kernel for perspective camera. \n"\
"/// Rays are generated from camera position to viewing plane \n"\
"/// using random sample distribution within the pixel. \n"\
"/// \n"\
"__kernel void PerspectiveCameraDof_GeneratePaths( \n"\
"    // Camera descriptor \n"\
"    __global Camera const* camera, \n"\
"    // Image resolution \n"\
"    int imgwidth, \n"\
"    int imgheight, \n"\
"    // RNG seed value \n"\
"    int randseed, \n"\
"    // Output rays \n"\
"    __global ray* rays, \n"\
"    __global SobolSampler* samplers, \n"\
"    __global uint const* sobolmat, \n"\
"    int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"    , __global Path* paths \n"\
"#endif \n"\
"    ) \n"\
"{ \n"\
"    int2 globalid; \n"\
"    globalid.x = get_global_id(0); \n"\
"    globalid.y = get_global_id(1); \n"\
" \n"\
"    // Check borders \n"\
"    if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"    { \n"\
"        // Get pointer to ray to handle \n"\
"        __global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        __global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"        // Prepare RNG \n"\
"        Rng rng; \n"\
"        InitRng(randseed + globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"        // \n"\
"#ifdef SOBOL \n"\
"        __global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"        if (reset) \n"\
"        { \n"\
"            sampler->seq = 0; \n"\
"            sampler->s0 = RandUint(&rng); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            sampler->seq++; \n"\
"        } \n"\
" \n"\
"        float2 sample0; \n"\
"        sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"        sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
" \n"\
"        float2 sample1; \n"\
"        sample1.x = SobolSampler_Sample1D(sampler->seq, kLensX, sampler->s0, sobolmat); \n"\
"        sample1.y = SobolSampler_Sample1D(sampler->seq, kLensY, sampler->s0, sobolmat); \n"\
"#else \n"\
"        float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"        float2 sample1 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"        // Calculate [0..1] image plane sample \n"\
"        float2 imgsample; \n"\
"        imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"        imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"        // Transform into [-0.5, 0.5] \n"\
"        float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"        // Transform into [-dim/2, dim/2] \n"\
"        float2 csample = hsample * camera->dim; \n"\
" \n"\
" \n"\
"        float2 lsample = camera->aperture * Sample_MapToDiskConcentric(sample1); \n"\
"        float2 fpsample = csample * camera->focus_distance / camera->focal_length; \n"\
"        float2 cdir = fpsample - lsample; \n"\
" \n"\
"        float3 o = camera->p + lsample.x * camera->right + lsample.y * camera->up; \n"\
"        float3 d = normalize(camera->forward * camera->focus_distance + camera->right * cdir.x + camera->up * cdir.y); \n"\
" \n"\
" \n"\
"        // Calculate direction to image plane \n"\
"        myray->d.xyz = d; \n"\
"        // Origin == camera position + nearz * d \n"\
"        myray->o.xyz = o; \n"\
"        // Max T value = zfar - znear since we moved origin to znear \n"\
"        myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"        // Generate random time from 0 to 1 \n"\
"        myray->d.w = sample0.x; \n"\
"        // Set ray max \n"\
"        myray->extra.x = 0xFFFFFFFF; \n"\
"        myray->extra.y = 0xFFFFFFFF; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"        mypath->volume = -1; \n"\
"        mypath->flags = 0; \n"\
"        mypath->active = 0xFF; \n"\
"#endif \n"\
"    } \n"\
"} \n"\
" \n"\
"#define M_PI 3.14159265358979323846 \n"\
" \n"\
"/// Ray generation kernel for spherical camera. \n"\
"/// \n"\
"__kernel void SphericalCamera_GeneratePaths( \n"\
"	// Camera descriptor \n"\
"	__global Camera const* camera, \n"\
"	// Image resolution \n"\
"	int imgwidth, \n"\
"	int imgheight, \n"\
"	// RNG seed value \n"\
"	int randseed, \n"\
"	// Output rays \n"\
"	__global ray* rays, \n"\
"	__global SobolSampler* samplers, \n"\
"	__global uint const* sobolmat, \n"\
"	int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"	, __global Path* paths \n"\
"#endif \n"\
") \n"\
"{ \n"\
"	int2 globalid; \n"\
"	globalid.x = get_global_id(0); \n"\
"	globalid.y = get_global_id(1); \n"\
" \n"\
"	// Check borders \n"\
"	if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"	{ \n"\
"		// Get pointer to ray to handle \n"\
"		__global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"		__global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"		// Prepare RNG \n"\
"		Rng rng; \n"\
"		InitRng(randseed + globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"#ifdef SOBOL \n"\
"		__global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"		if (reset) \n"\
"		{ \n"\
"			sampler->seq = 0; \n"\
"			sampler->s0 = RandUint(&rng); \n"\
"		} else \n"\
"		{ \n"\
"			sampler->seq++; \n"\
"		} \n"\
" \n"\
"		float2 sample0; \n"\
"		sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"		sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
"#else \n"\
"		float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"		// Calculate [0..1] image plane sample \n"\
"		float2 imgsample; \n"\
"		imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"		imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"		// Transform into [-0.5, 0.5] \n"\
"		float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"		// Transform into [-dim/2, dim/2] \n"\
"		float2 csample = hsample * camera->dim; \n"\
" \n"\
" \n"\
"		float phi = (2.0 * M_PI) * (imgsample.x); \n"\
"		float theta = (M_PI) * (imgsample.y); \n"\
" \n"\
"		float4 m1, m2, m3, m4; \n"\
"		float4 n1, n2, n3, n4; \n"\
" \n"\
"		m1 = (float4) { cos(phi), 0.0, -sin(phi), 0.0 }; \n"\
"		m2 = (float4) { 0.0, 1.0, 0.0, 0.0 }; \n"\
"		m3 = (float4) { sin(phi), 0.0, cos(phi), 0.0 }; \n"\
"		m4 = (float4) { 0.0, 0.0, 0.0, 1.0 }; \n"\
" \n"\
" \n"\
"		n1 = (float4) { cos(theta), sin(theta), 0.0, 0.0 }; \n"\
"		n2 = (float4) { -sin(theta), cos(theta), 0.0, 0.0 }; \n"\
"		n3 = (float4) { 0.0, 0.0, 1.0, 0.0 }; \n"\
"		n4 = (float4) { 0.0, 0.0, 0.0, 1.0 }; \n"\
" \n"\
"		//myray->d.xyz = normalize(camera->focal_length * transform_vector(transform_vector(-camera->up.xyz, n1, n2, n3, n4), m1, m2, m3, m4)); \n"\
"		myray->d.xyz = normalize(camera->focal_length * transform_vector(transform_vector(-(float3) { 0, 1, 0 }, n1, n2, n3, n4), m1, m2, m3, m4)); \n"\
" \n"\
"		// Calculate direction to image plane \n"\
"		//myray->d.xyz = normalize(camera->focal_length * camera->forward + csample.x * camera->right + csample.y * camera->up); \n"\
"		// Origin == camera position + nearz * d \n"\
"		myray->o.xyz = camera->p + camera->zcap.x * myray->d.xyz; \n"\
"		// Max T value = zfar - znear since we moved origin to znear \n"\
"		myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"		// Generate random time from 0 to 1 \n"\
"		myray->d.w = sample0.x; \n"\
"		// Set ray max \n"\
"		myray->extra.x = 0xFFFFFFFF; \n"\
"		myray->extra.y = 0xFFFFFFFF; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"		mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"		mypath->volume = -1; \n"\
"		mypath->flags = 0; \n"\
"		mypath->active = 0xFF; \n"\
"#endif \n"\
"	} \n"\
"} \n"\
" \n"\
" \n"\
"#endif // CAMERA_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SCENE_CL \n"\
"#define SCENE_CL \n"\
" \n"\
" \n"\
"/// Fill DifferentialGeometry structure based on intersection info from RadeonRays \n"\
"void FillDifferentialGeometry(// Scene \n"\
"                              Scene const* scene, \n"\
"                              // RadeonRays intersection \n"\
"                              Intersection const* isect, \n"\
"                              // Differential geometry \n"\
"                              DifferentialGeometry* diffgeo \n"\
"                              ) \n"\
"{ \n"\
"    // Determine shape and polygon \n"\
"    int shapeid = isect->shapeid - 1; \n"\
"    int primid = isect->primid; \n"\
"     \n"\
"    // Get barycentrics \n"\
"    float2 uv = isect->uvwt.xy; \n"\
"     \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeid]; \n"\
"    //float3 linearvelocity = shape.linearvelocity; \n"\
"    //float4 angularvelocity = shape.angularvelocity; \n"\
"     \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primid]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primid + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primid + 2]; \n"\
"     \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
"     \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
"     \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
"     \n"\
"    // Calculate barycentric position and normal \n"\
"    diffgeo->n = normalize(transform_vector((1.f - uv.x - uv.y) * n0 + uv.x * n1 + uv.y * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"    diffgeo->p = transform_point((1.f - uv.x - uv.y) * v0 + uv.x * v1 + uv.y * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    diffgeo->uv = (1.f - uv.x - uv.y) * uv0 + uv.x * uv1 + uv.y * uv2; \n"\
"     \n"\
"    // Get material at shading point \n"\
"    int matidx = scene->materialids[shape.startidx / 3 + primid]; \n"\
"    diffgeo->mat = scene->materials[matidx]; \n"\
" \n"\
"    /// From PBRT book \n"\
"    /// Construct tangent basis on the fly and apply normal map \n"\
"    float du1 = uv0.x - uv2.x; \n"\
"    float du2 = uv1.x - uv2.x; \n"\
"    float dv1 = uv0.y - uv2.y; \n"\
"    float dv2 = uv1.y - uv2.y; \n"\
"     \n"\
"    float3 dp1 = v0 - v2; \n"\
"    float3 dp2 = v1 - v2; \n"\
"     \n"\
"    float det = du1 * dv2 - dv1 * du2; \n"\
"     \n"\
"    if (0 && det != 0.f) \n"\
"    { \n"\
"        float invdet = 1.f / det; \n"\
"        diffgeo->dpdu = normalize( (dv2 * dp1 - dv1 * dp2) * invdet ); \n"\
"        diffgeo->dpdv = normalize( (-du2 * dp1 + du1 * dp2) * invdet ); \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        diffgeo->dpdu = normalize(GetOrthoVector(diffgeo->n)); \n"\
"        diffgeo->dpdv = normalize(cross(diffgeo->n, diffgeo->dpdu)); \n"\
"    } \n"\
"     \n"\
"    diffgeo->ng = normalize(cross(diffgeo->dpdv, diffgeo->dpdu)); \n"\
" \n"\
"    //if (dot(diffgeo->ng, diffgeo->n) < 0.f) \n"\
"        //diffgeo->ng = -diffgeo->ng; \n"\
" \n"\
"    // Fix all to be orthogonal \n"\
"    //diffgeo->dpdv = normalize(cross(diffgeo->ng, diffgeo->dpdu)); \n"\
"    //diffgeo->dpdu = normalize(cross(diffgeo->dpdv, diffgeo->ng)); \n"\
" \n"\
"    float3 p0 = transform_point(v0, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    float3 p1 = transform_point(v1, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    float3 p2 = transform_point(v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
" \n"\
"    diffgeo->area = 0.5f * length(cross(p2 - p0, p2 - p1)); \n"\
"     \n"\
"    // Apply transform & linear motion blur \n"\
"    //v += (linearvelocity * time); \n"\
"    // MT^-1 should be used if scale is present \n"\
"    //n = rotate_vector(n, angularvelocity); \n"\
"} \n"\
" \n"\
"int Scene_SampleLight(Scene const* scene, float sample, float* pdf) \n"\
"{ \n"\
"    int num_lights = scene->num_lights; \n"\
"    int light_idx = clamp((int)(sample * num_lights), 0, num_lights - 1); \n"\
"    *pdf = 1.f / num_lights; \n"\
"    return light_idx; \n"\
"} \n"\
" \n"\
" \n"\
"#endif \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef MATERIAL_CL \n"\
"#define MATERIAL_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef BXDF_CL \n"\
"#define BXDF_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"#define DENOM_EPS 0.0f \n"\
"#define ROUGHNESS_EPS 0.0001f \n"\
" \n"\
"enum Bxdf \n"\
"{ \n"\
"    kZero, \n"\
"    kLambert, \n"\
"    kIdealReflect, \n"\
"    kIdealRefract, \n"\
"    kMicrofacetBlinn, \n"\
"    kMicrofacetBeckmann, \n"\
"    kMicrofacetGGX, \n"\
"    kLayered, \n"\
"    kFresnelBlend, \n"\
"    kMix, \n"\
"    kEmissive, \n"\
"    kPassthrough, \n"\
"    kTranslucent, \n"\
"    kMicrofacetRefractionGGX, \n"\
"    kMicrofacetRefractionBeckmann \n"\
"}; \n"\
" \n"\
"enum BxdfFlags \n"\
"{ \n"\
"    kReflection = (1 << 0), \n"\
"    kTransmission = (1 << 1), \n"\
"    kDiffuse = (1 << 2), \n"\
"    kSpecular = (1 << 3), \n"\
"    kGlossy = (1 << 4), \n"\
"    kAllReflection = kReflection | kDiffuse | kSpecular | kGlossy, \n"\
"    kAllTransmission = kTransmission | kDiffuse | kSpecular | kGlossy, \n"\
"    kAll = kReflection | kTransmission | kDiffuse | kSpecular | kGlossy \n"\
"}; \n"\
" \n"\
" \n"\
"/// Schlick's approximation of Fresnel equtions \n"\
"float SchlickFresnel(float eta, float ndotw) \n"\
"{ \n"\
"    const float f = ((1.f - eta) / (1.f + eta)) * ((1.f - eta) / (1.f + eta)); \n"\
"    const float m = 1.f - fabs(ndotw); \n"\
"    const float m2 = m*m; \n"\
"    return f + (1.f - f) * m2 * m2 * m; \n"\
"} \n"\
" \n"\
"/// Full Fresnel equations \n"\
"float FresnelDielectric(float etai, float etat, float ndotwi, float ndotwt) \n"\
"{ \n"\
"    // Parallel and perpendicular polarization \n"\
"    float rparl = ((etat * ndotwi) - (etai * ndotwt)) / ((etat * ndotwi) + (etai * ndotwt)); \n"\
"    float rperp = ((etai * ndotwi) - (etat * ndotwt)) / ((etai * ndotwi) + (etat * ndotwt)); \n"\
"    return (rparl*rparl + rperp*rperp) * 0.5f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Microfacet Beckmann \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Beckmann_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = dot(m, n); \n"\
" \n"\
"    if (ndotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = sinmn / ndotm; \n"\
"    float a2 = roughness * roughness; \n"\
" \n"\
"    return (1.f / (PI * a2 * ndotm2 * ndotm2)) * native_exp(-tanmn * tanmn / a2); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Beckmann_GetPdf( \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 m = normalize(wi + wo); \n"\
"    float wodotm = dot(wo, m); \n"\
" \n"\
"    if (wodotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    // \n"\
"    float mpdf = MicrofacetDistribution_Beckmann_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
" \n"\
"    return mpdf / (4.f * wodotm); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_Sample(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_SampleNormal(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"float MicrofacetDistribution_Beckmann_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = sinnv / ndotv; \n"\
"    float a = tannv > DENOM_EPS ? 1.f / (roughness * tannv) : 0.f; \n"\
"    float a2 = a * a; \n"\
" \n"\
"    if (a < 1.6f) \n"\
"        return 1.f; \n"\
" \n"\
"    return (3.535f * a + 2.181f * a2) / (1.f + 2.276f * a + 2.577f * a2); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Beckmann_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_Beckmann_G1(roughness, wi, wh, n) * MicrofacetDistribution_Beckmann_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
" \n"\
"float3 MicrofacetBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = 4.f * costhetao * costhetai; \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    return MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    MicrofacetDistribution_Beckmann_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet GGX \n"\
" */ \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_GGX_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = fabs(dot(m, n)); \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = ndotm > DENOM_EPS ? sinmn / ndotm : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    float denom = (PI * ndotm2 * ndotm2 * (a2 + tanmn * tanmn) * (a2 + tanmn * tanmn)); \n"\
"    return denom > DENOM_EPS ? (a2 / denom) : 0.f; \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_GGX_GetPdf( \n"\
"    // Halfway vector \n"\
"    float3 m, \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float mpdf = MicrofacetDistribution_GGX_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (4.f * fabs(dot(wo, m))); \n"\
" \n"\
"    return denom > DENOM_EPS ? mpdf / denom : 0.f; \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_Sample( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*fabs(dot(wi, wh)) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_SampleNormal( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Differential geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"// \n"\
"float MicrofacetDistribution_GGX_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = ndotv > 0.f ? sinnv / ndotv : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    return 2.f / (1.f + native_sqrt(1.f + a2 * tannv * tannv)); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_GGX_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_GGX_G1(roughness, wi, wh, n) * MicrofacetDistribution_GGX_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > 0.f ? F * ks * MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float3 wh = normalize(wo + wi); \n"\
" \n"\
"    return MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    MicrofacetDistribution_GGX_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
" \n"\
"    return MicrofacetGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet Blinn \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Blinn_D(float shininess, float3 w, float3 n) \n"\
"{ \n"\
"    float ndotw = fabs(dot(n, w)); \n"\
"    return (1.f / (2 * PI)) * (shininess + 2) * native_powr(ndotw, shininess); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Blinn_GetPdf(// Shininess \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 wh = normalize(wi + wo); \n"\
"    // costheta \n"\
"    float ndotwh = dot(dg->n, wh); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (2.f * PI * 4.f * dot(wo, wh)); \n"\
"    return denom > DENOM_EPS ? ((shininess + 1.f) * native_powr(ndotwh, shininess)) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Blinn_Sample(// Shininess param \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    // \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float costheta = native_powr(r1, 1.f / (shininess + 1.f)); \n"\
"    float sintheta = native_sqrt(1.f - costheta * costheta); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - cosphi * cosphi); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Blinn_G(float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    float ndotwh = fabs(dot(n, wh)); \n"\
"    float ndotwo = fabs(dot(n, wo)); \n"\
"    float ndotwi = fabs(dot(n, wi)); \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    return min(1.f, min(2.f * ndotwh * ndotwo / wodotwh, 2.f * ndotwh * ndotwi / wodotwh)); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF evaluation \n"\
"float3 MicrofacetBlinn_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
"    const float shininess = dg->mat.ns; \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Blinn_G(wi, wo, wh, dg->n) * MicrofacetDistribution_Blinn_D(shininess, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float MicrofacetBlinn_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float shininess = dg->mat.ns; \n"\
"    return MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 MicrofacetBlinn_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    if (dot(dg->n, wi) <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float shininess = dg->mat.ns; \n"\
"    MicrofacetDistribution_Blinn_Sample(shininess, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBlinn_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/* \n"\
" Lambert BRDF \n"\
" */ \n"\
" /// Lambert BRDF evaluation \n"\
"float3 Lambert_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Lambert_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return fabs(dot(dg->n, wo)) / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Lambert_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    *wo = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *pdf = fabs(dot(dg->n, *wo)) / PI; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal reflection BRDF \n"\
" */ \n"\
"float3 IdealReflect_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Translucent_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float3 n = ndotwi > DENOM_EPS ? -dg->n : dg->n; \n"\
" \n"\
"    *wo = normalize(Sample_MapToHemisphere(sample, n, 1.f)); \n"\
" \n"\
"    *pdf = fabs(dot(n, *wo)) / PI; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"// Lambert BRDF evaluation \n"\
"float3 Translucent_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Translucent_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0) \n"\
"        return 0.f; \n"\
" \n"\
"    return fabs(ndotwo) / PI; \n"\
"} \n"\
" \n"\
"float IdealReflect_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealReflect_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    // Mirror reflect wi \n"\
"    *wo = normalize(2.f * ndotwi * dg->n - wi); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // Return reflectance value \n"\
"    return coswo > DENOM_EPS ? (F * ks * (1.f / coswo)) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal refraction BTDF \n"\
" */ \n"\
" \n"\
"float3 IdealRefract_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float IdealRefract_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealRefract_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float cosi = dot(dg->n, wi); \n"\
" \n"\
"    bool entering = cosi > 0.f; \n"\
"    float3 n = dg->n; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (!entering) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        n = -dg->n; \n"\
"        cosi = -cosi; \n"\
"    } \n"\
" \n"\
"    float eta = etai / etat; \n"\
"    float sini2 = 1.f - cosi * cosi; \n"\
" \n"\
"    float sint2 = eta * eta * sini2; \n"\
" \n"\
"    if (sint2 >= 1.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
" \n"\
"    // Transmitted ray \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *wo = normalize(-n * cost + normalize(n * cosi - wi) * native_sqrt(max(sint2, 0.f))); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    return cost > 0.0001f ? F * (((etai * etai) / (etat * etat)) * ks / cost) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_GGX_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi == 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_GGX_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionGGX_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_Beckmann_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionBeckmann_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 Passthrough_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
" \n"\
"    *wo = -wi; \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    //  \n"\
"    return coswo > 0.0001f ? (1.f / coswo) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Dispatch functions \n"\
" */ \n"\
"float3 Bxdf_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 Bxdf_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at w \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kPassthrough: \n"\
"        return Passthrough_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Bxdf_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kPassthrough: \n"\
"        return 0.f; \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Emissive BRDF sampling \n"\
"float3 Emissive_GetLe( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    return kd; \n"\
"} \n"\
" \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsSingular(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealReflect || dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough; \n"\
"} \n"\
" \n"\
"/// BxDF emission check \n"\
"bool Bxdf_IsEmissive(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kEmissive; \n"\
"} \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsBtdf(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough || dg->mat.type == kTranslucent || \n"\
"        dg->mat.type == kMicrofacetRefractionGGX || dg->mat.type == kMicrofacetRefractionBeckmann; \n"\
"} \n"\
" \n"\
"#endif // BXDF_CL \n"\
" \n"\
"void Material_Select( \n"\
"    // Scene data \n"\
"    Scene const* scene, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
" \n"\
"#ifdef SOBOL \n"\
"    // Sampler state \n"\
"    __global SobolSampler* sampler, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Current bounce \n"\
"    int bounce, \n"\
"#else \n"\
"    Rng* rng, \n"\
"#endif \n"\
" \n"\
"    // Geometry \n"\
"    DifferentialGeometry* dg \n"\
") \n"\
"{ \n"\
"    // Check material type \n"\
"    int type = dg->mat.type; \n"\
" \n"\
"    // If material is regular BxDF we do not have to sample it \n"\
"    if (type != kFresnelBlend && type != kMix) \n"\
"    { \n"\
"        // If fresnel > 0 here we need to calculate Frensle factor (remove this workaround) \n"\
"        if (dg->mat.fresnel > 0.f) \n"\
"        { \n"\
"            float etai = 1.f; \n"\
"            float etat = dg->mat.ni; \n"\
"            float cosi = dot(dg->n, wi); \n"\
" \n"\
"            // Revert normal and eta if needed \n"\
"            if (cosi < 0.f) \n"\
"            { \n"\
"                float tmp = etai; \n"\
"                etai = etat; \n"\
"                etat = tmp; \n"\
"                cosi = -cosi; \n"\
"            } \n"\
" \n"\
"            float eta = etai / etat; \n"\
"            float sini2 = 1.f - cosi * cosi; \n"\
"            float sint2 = eta * eta * sini2; \n"\
" \n"\
"            float fresnel = 1.f; \n"\
" \n"\
"            if (sint2 < 1.f) \n"\
"            { \n"\
"                float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
"                fresnel = FresnelDielectric(etai, etat, cosi, cost); \n"\
"            } \n"\
" \n"\
"            dg->mat.fresnel = Bxdf_IsBtdf(dg) ? (1.f - fresnel) : fresnel; \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            // Otherwise set multiplier to 1 \n"\
"            dg->mat.fresnel = 1.f; \n"\
"        } \n"\
"    } \n"\
"    // Here we deal with combined material and we have to sample \n"\
"    else \n"\
"    { \n"\
"        // Prefetch current material \n"\
"        Material mat = dg->mat; \n"\
"        int iter = 0; \n"\
" \n"\
"        // Might need several passes of sampling \n"\
"        while (mat.type == kFresnelBlend || mat.type == kMix) \n"\
"        { \n"\
"            if (mat.type == kFresnelBlend) \n"\
"            { \n"\
"                float etai = 1.f; \n"\
"                float etat = mat.ni; \n"\
"                float cosi = dot(dg->n, wi); \n"\
" \n"\
"                // Revert normal and eta if needed \n"\
"                if (cosi < 0.f) \n"\
"                { \n"\
"                    float tmp = etai; \n"\
"                    etai = etat; \n"\
"                    etat = tmp; \n"\
"                    cosi = -cosi; \n"\
"                } \n"\
" \n"\
"                float eta = etai / etat; \n"\
"                float sini2 = 1.f - cosi * cosi; \n"\
"                float sint2 = eta * eta * sini2; \n"\
" \n"\
"                int idx = 0; \n"\
" \n"\
"                float fresnel = 1.f; \n"\
" \n"\
"                if (sint2 < 1.f) \n"\
"                { \n"\
"                    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
"                    fresnel = FresnelDielectric(etai, etat, cosi, cost); \n"\
"                } \n"\
" \n"\
"#ifdef SOBOL \n"\
"                float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kMaterial + iter), sampler->s0, sobolmat); \n"\
"#else \n"\
"                float sample = UniformSampler_Sample2D(rng).x; \n"\
"#endif \n"\
" \n"\
"                if (sample < fresnel) \n"\
"                { \n"\
"                    // Sample top \n"\
"                    idx = mat.brdftopidx; \n"\
"                    //  \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"                else \n"\
"                { \n"\
"                    // Sample base \n"\
"                    idx = mat.brdfbaseidx; \n"\
"                    //  \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"            } \n"\
"            else \n"\
"            { \n"\
" \n"\
"#ifdef SOBOL \n"\
"                float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kMaterial + iter), sampler->s0, sobolmat); \n"\
"#else \n"\
"                float sample = UniformSampler_Sample2D(rng).x; \n"\
"#endif \n"\
"                float weight = Texture_GetValue1f(mat.ns, dg->uv, TEXTURE_ARGS_IDX(mat.nsmapidx)); \n"\
" \n"\
"                if (sample < weight) \n"\
"                { \n"\
"                    // Sample top \n"\
"                    int idx = mat.brdftopidx; \n"\
"                    // \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"                else \n"\
"                { \n"\
"                    // Sample base \n"\
"                    int idx = mat.brdfbaseidx; \n"\
"                    // \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"            } \n"\
"        } \n"\
" \n"\
"        dg->mat = mat; \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"#endif // MATERIAL_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef VOLUMETRICS_CL \n"\
"#define VOLUMETRICS_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
" \n"\
"#define FAKE_SHAPE_SENTINEL 0xFFFFFF \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kEmpty, \n"\
"    kHomogeneous, \n"\
"    kHeterogeneous \n"\
"} VolumeType; \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kUniform, \n"\
"    kRayleigh, \n"\
"    kMieMurky, \n"\
"    kMieHazy, \n"\
"    kHG // this one requires one extra coeff \n"\
"} PhaseFunction; \n"\
" \n"\
"typedef struct _Volume \n"\
"{ \n"\
"    VolumeType type; \n"\
"    PhaseFunction phase_func; \n"\
"     \n"\
"    // Id of volume data if present  \n"\
"    int data; \n"\
"    int extra; \n"\
" \n"\
"    // Absorbtion \n"\
"    float3 sigma_a; \n"\
"    // Scattering \n"\
"    float3 sigma_s; \n"\
"    // Emission \n"\
"    float3 sigma_e; \n"\
"} Volume; \n"\
" \n"\
" \n"\
"// The following functions are taken from PBRT \n"\
"float PhaseFunction_Uniform(float3 wi, float3 wo) \n"\
"{ \n"\
"    return 1.f / (4.f * PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_Rayleigh(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return  3.f / (16.f*PI) * (1 + costheta * costheta); \n"\
"} \n"\
" \n"\
"float PhaseFunction_MieHazy(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return (0.5f + 4.5f * native_powr(0.5f * (1.f + costheta), 8.f)) / (4.f*PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_MieMurky(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return (0.5f + 16.5f * native_powr(0.5f * (1.f + costheta), 32.f)) / (4.f*PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_HG(float3 wi, float3 wo, float g) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return 1.f / (4.f * PI) * \n"\
"        (1.f - g*g) / native_powr(1.f + g*g - 2.f * g * costheta, 1.5f); \n"\
"} \n"\
" \n"\
" \n"\
"// Evaluate volume transmittance along the ray [0, dist] segment \n"\
"float3 Volume_Transmittance(__global Volume const* volume, __global ray const* ray, float dist) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // For homogeneous it is e(-sigma * dist) \n"\
"            float3 sigma_t = volume->sigma_a + volume->sigma_s; \n"\
"            return native_exp(-sigma_t * dist); \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return 1.f; \n"\
"} \n"\
" \n"\
"// Evaluate volume selfemission along the ray [0, dist] segment \n"\
"float3 Volume_Emission(__global Volume const* volume, __global ray const* ray, float dist) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // For homogeneous it is simply Tr * Ev (since sigma_e is constant) \n"\
"            return Volume_Transmittance(volume, ray, dist) * volume->sigma_e; \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"// Sample volume in order to find next scattering event \n"\
"float Volume_SampleDistance(__global Volume const* volume, __global ray const* ray, float maxdist, float sample, float* pdf) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // The PDF = sigma * e(-sigma * x), so the larger sigma the closer we scatter \n"\
"            float sigma = (volume->sigma_s.x + volume->sigma_s.y + volume->sigma_s.z) / 3; \n"\
"            float d = sigma > 0.f ? (-native_log(sample) / sigma) : -1.f; \n"\
"            *pdf = sigma > 0.f ? (sigma * native_exp(-sigma * d)) : 0.f; \n"\
"            return d; \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return -1.f; \n"\
"} \n"\
" \n"\
"// Apply volume effects (absorbtion and emission) and scatter if needed. \n"\
"// The rays we handling here might intersect something or miss,  \n"\
"// since scattering can happen even for missed rays. \n"\
"// That's why this function is called prior to ray compaction. \n"\
"// In case ray has missed geometry (has shapeid < 0) and has been scattered, \n"\
"// we put FAKE_SHAPE_SENTINEL into shapeid to prevent ray from being compacted away. \n"\
"// \n"\
"__kernel void EvaluateVolume( \n"\
"    // Ray batch \n"\
"    __global ray const* rays, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int const* numrays, \n"\
"    // Volumes \n"\
"    __global Volume const* volumes, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG seed \n"\
"    int rngseed, \n"\
"    // Sampler state \n"\
"    __global SobolSampler* samplers, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Current bounce  \n"\
"    int bounce, \n"\
"    // Intersection data \n"\
"    __global Intersection* isects, \n"\
"    // Current paths \n"\
"    __global Path* paths, \n"\
"    // Output \n"\
"    __global float3* output \n"\
"    ) \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
"     \n"\
"    // Only handle active rays \n"\
"    if (globalid < *numrays) \n"\
"    { \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
"         \n"\
"        __global Path* path = paths + pixelidx; \n"\
" \n"\
"        // Path can be dead here since compaction step has not  \n"\
"        // yet been applied \n"\
"        if (!Path_IsAlive(path)) \n"\
"            return; \n"\
" \n"\
"        int volidx = Path_GetVolumeIdx(path); \n"\
" \n"\
"        // Check if we are inside some volume \n"\
"        if (volidx != -1) \n"\
"        { \n"\
"#ifdef SOBOL \n"\
"            __global SobolSampler* sampler = samplers + pixelidx; \n"\
"            float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kVolume), sampler->s0, sobolmat); \n"\
"#else \n"\
"            Rng rng; \n"\
"            InitRng(rngseed + (globalid << 2) * 157 + 13, &rng); \n"\
"            float sample = UniformSampler_Sample2D(&rng).x; \n"\
"#endif \n"\
"            // Try sampling volume for a next scattering event \n"\
"            float pdf = 0.f; \n"\
"            float maxdist = Intersection_GetDistance(isects + globalid); \n"\
"            float d = Volume_SampleDistance(&volumes[volidx], &rays[globalid], maxdist, sample, &pdf); \n"\
"             \n"\
"            // Check if we shall skip the event (it is either outside of a volume or not happened at all) \n"\
"            bool skip = d < 0 || d > maxdist || pdf <= 0.f; \n"\
" \n"\
"            if (skip) \n"\
"            { \n"\
"                // In case we skip we just need to apply volume absorbtion and emission for the segment we went through \n"\
"                // and clear scatter flag \n"\
"                Path_ClearScatterFlag(path); \n"\
"                // Emission contribution accounting for a throughput we have so far \n"\
"                Path_AddContribution(path, output, pixelidx, Volume_Emission(&volumes[volidx], &rays[globalid], maxdist)); \n"\
"                // And finally update the throughput \n"\
"                Path_MulThroughput(path, Volume_Transmittance(&volumes[volidx], &rays[globalid], maxdist)); \n"\
"            } \n"\
"            else \n"\
"            { \n"\
"                // Set scattering flag to notify ShadeVolume kernel to handle this path \n"\
"                Path_SetScatterFlag(path); \n"\
"                // Emission contribution accounting for a throughput we have so far \n"\
"                Path_AddContribution(path, output, pixelidx, Volume_Emission(&volumes[volidx], &rays[globalid], d) / pdf); \n"\
"                // Update the throughput \n"\
"                Path_MulThroughput(path, (Volume_Transmittance(&volumes[volidx], &rays[globalid], d) / pdf)); \n"\
"                // Put fake shape to prevent from being compacted away \n"\
"                isects[globalid].shapeid = FAKE_SHAPE_SENTINEL; \n"\
"                // And keep scattering distance around as well \n"\
"                isects[globalid].uvwt.w = d; \n"\
"            } \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"#endif // VOLUMETRICS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
" \n"\
"#define CRAZY_LOW_THROUGHPUT 0.0f \n"\
"#define CRAZY_HIGH_RADIANCE 10.f \n"\
"#define CRAZY_HIGH_DISTANCE 10000.f \n"\
"#define CRAZY_LOW_DISTANCE 0.001f \n"\
"#define REASONABLE_RADIANCE(x) (clamp((x), 0.f, CRAZY_HIGH_RADIANCE)) \n"\
"#define NON_BLACK(x) (length(x) > 0.f) \n"\
" \n"\
" \n"\
"__kernel void SampleOcclusion( \n"\
"    // Ray batch \n"\
"    __global ray const* rays, \n"\
"    // Intersection data \n"\
"    __global Intersection const* isects, \n"\
"    // Hit indices \n"\
"    __global int const* hitindices, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int const* numhits, \n"\
"    // Vertices \n"\
"    __global float3 const* vertices, \n"\
"    // Normals \n"\
"    __global float3 const* normals, \n"\
"    // UVs \n"\
"    __global float2 const* uvs, \n"\
"    // Indices \n"\
"    __global int const* indices, \n"\
"    // Shapes \n"\
"    __global Shape const* shapes, \n"\
"    // RNG seed \n"\
"    int rngseed, \n"\
"    // Radius \n"\
"    float radius, \n"\
"    // Sampler states \n"\
"    __global SobolSampler* samplers, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Shadow rays \n"\
"    __global ray* shadowrays \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    Scene scene = \n"\
"    { \n"\
"        vertices, \n"\
"        normals, \n"\
"        uvs, \n"\
"        indices, \n"\
"        shapes, \n"\
"        0, \n"\
"        0, \n"\
"        0, \n"\
"        0, \n"\
"        0, \n"\
"        0 \n"\
"    }; \n"\
" \n"\
"    // Only applied to active rays after compaction \n"\
"    if (globalid < *numhits) \n"\
"    { \n"\
"        // Fetch index \n"\
"        int hitidx = hitindices[globalid]; \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
"        Intersection isect = isects[hitidx]; \n"\
" \n"\
"        // Fetch incoming ray direction \n"\
"        float3 wi = -normalize(rays[hitidx].d.xyz); \n"\
"#ifdef SOBOL \n"\
"        // Sample light \n"\
"        __global SobolSampler* sampler = samplers + pixelidx; \n"\
" \n"\
"        float2 sample0; \n"\
"        sample0.x = SobolSampler_Sample1D(sampler->seq, GetSampleDim(0, kBrdf), sampler->s0, sobolmat); \n"\
"        sample0.y = SobolSampler_Sample1D(sampler->seq, GetSampleDim(0, kLight), sampler->s0, sobolmat); \n"\
" \n"\
"#else \n"\
"        // Prepare RNG \n"\
"        Rng rng; \n"\
"        InitRng(rngseed + (globalid << 2) * 157 + 13, &rng); \n"\
"        float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"        // Fill surface data \n"\
"        DifferentialGeometry diffgeo; \n"\
"        FillDifferentialGeometry(&scene, &isect, &diffgeo); \n"\
" \n"\
"        // Check if we are hitting from the inside \n"\
"        float ndotwi = dot(diffgeo.ng, wi); \n"\
"        if (ndotwi < 0.f) \n"\
"        { \n"\
"            // Reverse normal and tangents in this case \n"\
"            // but not for BTDFs, since BTDFs rely \n"\
"            // on normal direction in order to arrange \n"\
"            // indices of refraction \n"\
"            diffgeo.n = -diffgeo.n; \n"\
"            diffgeo.dpdu = -diffgeo.dpdu; \n"\
"            diffgeo.dpdv = -diffgeo.dpdv; \n"\
"        } \n"\
" \n"\
" \n"\
"        float3 wo = radius * Sample_MapToHemisphere(sample0, diffgeo.n, 1.f); \n"\
"        // Generate shadow ray \n"\
"        float shadow_ray_length = (1.f - 2.f * CRAZY_LOW_DISTANCE) * length(wo); \n"\
"        float3 shadow_ray_dir = normalize(wo); \n"\
"        float3 shadow_ray_o = diffgeo.p + CRAZY_LOW_DISTANCE * diffgeo.n; \n"\
"        int shadow_ray_mask = 0xFFFFFFFF; \n"\
" \n"\
"        Ray_Init(shadowrays + globalid, shadow_ray_o, shadow_ray_dir, shadow_ray_length, 0.f, shadow_ray_mask); \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"///< Handle light samples and visibility info and add contribution to final buffer \n"\
"__kernel void GatherOcclusion( \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int* numrays, \n"\
"    // Shadow rays hits \n"\
"    __global int const* shadowhits, \n"\
"    // Radiance sample buffer \n"\
"    __global float4* output \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    if (globalid < *numrays) \n"\
"    { \n"\
"        // Get pixel id for this sample set \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
" \n"\
"        float visibility = (shadowhits[globalid] == 1) ? 0.f : 1.f; \n"\
" \n"\
"        output[pixelidx].xyz += visibility; \n"\
"        output[pixelidx].w += 1; \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"///< Restore pixel indices after compaction \n"\
"__kernel void RestorePixelIndices( \n"\
"    // Compacted indices \n"\
"    __global int const* compacted_indices, \n"\
"    // Number of compacted indices \n"\
"    __global int* numitems, \n"\
"    // Previous pixel indices \n"\
"    __global int const* previndices, \n"\
"    // New pixel indices \n"\
"    __global int* newindices \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    // Handle only working subset \n"\
"    if (globalid < *numitems) \n"\
"    { \n"\
"        newindices[globalid] = previndices[compacted_indices[globalid]]; \n"\
"    } \n"\
"} \n"\
" \n"\
"///< Restore pixel indices after compaction \n"\
"__kernel void FilterPathStream( \n"\
"    // Intersections \n"\
"    __global Intersection const* isects, \n"\
"    // Number of compacted indices \n"\
"    __global int const* numitems, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Predicate \n"\
"    __global int* predicate \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    // Handle only working subset \n"\
"    if (globalid < *numitems) \n"\
"    { \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
"        predicate[globalid] = isects[globalid].shapeid >= 0 ? 1 : 0; \n"\
"    } \n"\
"} \n"\
" \n"\
"// Copy data to interop texture if supported \n"\
"__kernel void AccumulateData( \n"\
"    __global float4 const* srcdata, \n"\
"    int numelems, \n"\
"    __global float4* dstdata \n"\
") \n"\
"{ \n"\
"    int gid = get_global_id(0); \n"\
" \n"\
"    if (gid < numelems) \n"\
"    { \n"\
"        float4 v = srcdata[gid]; \n"\
"        dstdata[gid] += v; \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"// Copy data to interop texture if supported \n"\
"__kernel void ApplyGammaAndCopyData( \n"\
"    __global float4 const* data, \n"\
"    int imgwidth, \n"\
"    int imgheight, \n"\
"    float gamma, \n"\
"    write_only image2d_t img \n"\
") \n"\
"{ \n"\
"    int gid = get_global_id(0); \n"\
" \n"\
"    int gidx = gid % imgwidth; \n"\
"    int gidy = gid / imgwidth; \n"\
" \n"\
"    if (gidx < imgwidth && gidy < imgheight) \n"\
"    { \n"\
"        float4 v = data[gid]; \n"\
"//        float4 val = clamp(native_powr(v / v.w, 1.f / gamma), 0.f, 1.f); \n"\
"        float4 val = max(native_powr(v / v.w, 1.f / gamma), 0.f); \n"\
"        write_imagef(img, make_int2(gidx, gidy), val); \n"\
"    } \n"\
"} \n"\
;
static const char g_integrator_pt_opencl[]= \
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SAMPLING_CL \n"\
"#define SAMPLING_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToHemisphere( \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Hemisphere normal \n"\
"                        float3 n, \n"\
"                        // Cos power \n"\
"                        float e \n"\
"                        ) \n"\
"{ \n"\
"    // Construct basis \n"\
"    float3 u = GetOrthoVector(n); \n"\
"    float3 v = cross(u, n); \n"\
"    u = cross(n, v); \n"\
"     \n"\
"    // Calculate 2D sample \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
"     \n"\
"    // Transform to spherical coordinates \n"\
"    float sinpsi = sin(2*PI*r1); \n"\
"    float cospsi = cos(2*PI*r1); \n"\
"    float costheta = pow(1.f - r2, 1.f/(e + 1.f)); \n"\
"    float sintheta = sqrt(1.f - costheta * costheta); \n"\
"     \n"\
"    // Return the result \n"\
"    return normalize(u * sintheta * cospsi + v * sintheta * sinpsi + n * costheta); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDisk( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float r = native_sqrt(sample.x);  \n"\
"    float theta = 2 * PI * sample.y; \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDiskConcentric( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float2 offset = 2.f * sample - make_float2(1.f, 1.f); \n"\
" \n"\
"    if (offset.x == 0 && offset.y == 0) return 0.f; \n"\
" \n"\
"    float theta, r; \n"\
" \n"\
"    if (fabs(offset.x) > fabs(offset.y))  \n"\
"    { \n"\
"        r = offset.x; \n"\
"        theta = PI / 4.f * (offset.y / offset.x); \n"\
"    } \n"\
"    else  \n"\
"    { \n"\
"        r = offset.y; \n"\
"        theta = PI / 2.f * ( 1.f - 0.5f * (offset.x / offset.y)); \n"\
"    } \n"\
"     \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToSphere( \n"\
"                        // Sample \n"\
"                        float2 sample \n"\
"                        ) \n"\
"{ \n"\
"    float z = 1.f - 2.f * sample.x; \n"\
"    float r = native_sqrt(max(0.f, 1.f - z*z)); \n"\
"    float phi = 2.f * PI * sample.y; \n"\
"    float x = cos(phi); \n"\
"    float y = sin(phi); \n"\
"     \n"\
"    // Return the result \n"\
"    return make_float3(x,y,z); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToPolygon(int n, float2 sample, float sample1) \n"\
"{ \n"\
"    float theta = 2.f * PI / n; \n"\
" \n"\
"    int edge = clamp((int)(sample1 * n), 0, n - 1); \n"\
" \n"\
"    float t = native_sqrt(sample.x); \n"\
"    float u = 1.f - t; \n"\
"    float v = t * sample.y; \n"\
" \n"\
"    float2 v1 = make_float2(native_cos(theta * edge), native_sin(theta * edge)); \n"\
"    float2 v2 = make_float2(native_cos(theta * (edge + 1)), native_sin(theta * (edge + 1))); \n"\
" \n"\
" \n"\
"    return u*v1 + v*v2;; \n"\
"} \n"\
" \n"\
"/// Power heuristic for multiple importance sampling \n"\
"float PowerHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f*f) / (f*f + g*g); \n"\
"} \n"\
" \n"\
"/// Balance heuristic for multiple importance sampling \n"\
"float BalanceHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f) / (f + g); \n"\
"} \n"\
" \n"\
"typedef struct \n"\
"{ \n"\
"    uint seq; \n"\
"    uint s0; \n"\
"    uint s1; \n"\
"    uint s2; \n"\
"} SobolSampler; \n"\
" \n"\
"float2 UniformSampler_Sample2D(Rng* rng) \n"\
"{ \n"\
"    float2 sample; \n"\
"    sample.x = RandFloat(rng); \n"\
"    sample.y = RandFloat(rng); \n"\
"    return sample; \n"\
"} \n"\
" \n"\
"#define MATSIZE 52 \n"\
" \n"\
"// The code is taken from: http://gruenschloss.org/sobol/kuo-2d-proj-single-precision.zip \n"\
"//  \n"\
"float SobolSampler_Sample1D(uint index, uint dimension, uint scramble, __global uint const* mat) \n"\
"{ \n"\
"    uint result = scramble; \n"\
"    for (uint i = dimension * MATSIZE; index; index >>= 1, ++i) \n"\
"    { \n"\
"        if (index & 1) \n"\
"            result ^= mat[i]; \n"\
"    } \n"\
" \n"\
"    return result * (1.f / (1UL << 32)); \n"\
"} \n"\
" \n"\
" \n"\
"#endif // SAMPLING_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef NORMALMAP_CL \n"\
"#define NORMALMAP_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"void ApplyNormalMap(DifferentialGeometry* dg, TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    int nmapidx = dg->mat.nmapidx; \n"\
"    if (nmapidx != -1) \n"\
"    { \n"\
"        // Now n, dpdu, dpdv is orthonormal basis \n"\
"        float3 mappednormal = 2.f * Texture_Sample2D(dg->uv, TEXTURE_ARGS_IDX(nmapidx)).xyz - make_float3(1.f, 1.f, 1.f); \n"\
" \n"\
"        // Return mapped version \n"\
"        dg->n = normalize(mappednormal.z *  dg->n * 0.5f + mappednormal.x * dg->dpdu + mappednormal.y * dg->dpdv); \n"\
"    } \n"\
"} \n"\
" \n"\
"void ApplyBumpMap(DifferentialGeometry* dg, TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    int nmapidx = dg->mat.nmapidx; \n"\
"    if (nmapidx != -1) \n"\
"    { \n"\
"        // Now n, dpdu, dpdv is orthonormal basis \n"\
"        float3 mappednormal = 2.f * Texture_SampleBump(dg->uv, TEXTURE_ARGS_IDX(nmapidx)) - make_float3(1.f, 1.f, 1.f); \n"\
" \n"\
"        // Return mapped version \n"\
"        dg->n = normalize(mappednormal.z * dg->n + mappednormal.x * dg->dpdu + mappednormal.y * dg->dpdv); \n"\
"    } \n"\
"} \n"\
" \n"\
"#endif // NORMALMAP_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef BXDF_CL \n"\
"#define BXDF_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"#define DENOM_EPS 0.0f \n"\
"#define ROUGHNESS_EPS 0.0001f \n"\
" \n"\
"enum Bxdf \n"\
"{ \n"\
"    kZero, \n"\
"    kLambert, \n"\
"    kIdealReflect, \n"\
"    kIdealRefract, \n"\
"    kMicrofacetBlinn, \n"\
"    kMicrofacetBeckmann, \n"\
"    kMicrofacetGGX, \n"\
"    kLayered, \n"\
"    kFresnelBlend, \n"\
"    kMix, \n"\
"    kEmissive, \n"\
"    kPassthrough, \n"\
"    kTranslucent, \n"\
"    kMicrofacetRefractionGGX, \n"\
"    kMicrofacetRefractionBeckmann \n"\
"}; \n"\
" \n"\
"enum BxdfFlags \n"\
"{ \n"\
"    kReflection = (1 << 0), \n"\
"    kTransmission = (1 << 1), \n"\
"    kDiffuse = (1 << 2), \n"\
"    kSpecular = (1 << 3), \n"\
"    kGlossy = (1 << 4), \n"\
"    kAllReflection = kReflection | kDiffuse | kSpecular | kGlossy, \n"\
"    kAllTransmission = kTransmission | kDiffuse | kSpecular | kGlossy, \n"\
"    kAll = kReflection | kTransmission | kDiffuse | kSpecular | kGlossy \n"\
"}; \n"\
" \n"\
" \n"\
"/// Schlick's approximation of Fresnel equtions \n"\
"float SchlickFresnel(float eta, float ndotw) \n"\
"{ \n"\
"    const float f = ((1.f - eta) / (1.f + eta)) * ((1.f - eta) / (1.f + eta)); \n"\
"    const float m = 1.f - fabs(ndotw); \n"\
"    const float m2 = m*m; \n"\
"    return f + (1.f - f) * m2 * m2 * m; \n"\
"} \n"\
" \n"\
"/// Full Fresnel equations \n"\
"float FresnelDielectric(float etai, float etat, float ndotwi, float ndotwt) \n"\
"{ \n"\
"    // Parallel and perpendicular polarization \n"\
"    float rparl = ((etat * ndotwi) - (etai * ndotwt)) / ((etat * ndotwi) + (etai * ndotwt)); \n"\
"    float rperp = ((etai * ndotwi) - (etat * ndotwt)) / ((etai * ndotwi) + (etat * ndotwt)); \n"\
"    return (rparl*rparl + rperp*rperp) * 0.5f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Microfacet Beckmann \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Beckmann_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = dot(m, n); \n"\
" \n"\
"    if (ndotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = sinmn / ndotm; \n"\
"    float a2 = roughness * roughness; \n"\
" \n"\
"    return (1.f / (PI * a2 * ndotm2 * ndotm2)) * native_exp(-tanmn * tanmn / a2); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Beckmann_GetPdf( \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 m = normalize(wi + wo); \n"\
"    float wodotm = dot(wo, m); \n"\
" \n"\
"    if (wodotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    // \n"\
"    float mpdf = MicrofacetDistribution_Beckmann_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
" \n"\
"    return mpdf / (4.f * wodotm); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_Sample(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_SampleNormal(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"float MicrofacetDistribution_Beckmann_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = sinnv / ndotv; \n"\
"    float a = tannv > DENOM_EPS ? 1.f / (roughness * tannv) : 0.f; \n"\
"    float a2 = a * a; \n"\
" \n"\
"    if (a < 1.6f) \n"\
"        return 1.f; \n"\
" \n"\
"    return (3.535f * a + 2.181f * a2) / (1.f + 2.276f * a + 2.577f * a2); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Beckmann_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_Beckmann_G1(roughness, wi, wh, n) * MicrofacetDistribution_Beckmann_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
" \n"\
"float3 MicrofacetBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = 4.f * costhetao * costhetai; \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    return MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    MicrofacetDistribution_Beckmann_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet GGX \n"\
" */ \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_GGX_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = fabs(dot(m, n)); \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = ndotm > DENOM_EPS ? sinmn / ndotm : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    float denom = (PI * ndotm2 * ndotm2 * (a2 + tanmn * tanmn) * (a2 + tanmn * tanmn)); \n"\
"    return denom > DENOM_EPS ? (a2 / denom) : 0.f; \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_GGX_GetPdf( \n"\
"    // Halfway vector \n"\
"    float3 m, \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float mpdf = MicrofacetDistribution_GGX_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (4.f * fabs(dot(wo, m))); \n"\
" \n"\
"    return denom > DENOM_EPS ? mpdf / denom : 0.f; \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_Sample( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*fabs(dot(wi, wh)) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_SampleNormal( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Differential geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"// \n"\
"float MicrofacetDistribution_GGX_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = ndotv > 0.f ? sinnv / ndotv : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    return 2.f / (1.f + native_sqrt(1.f + a2 * tannv * tannv)); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_GGX_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_GGX_G1(roughness, wi, wh, n) * MicrofacetDistribution_GGX_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > 0.f ? F * ks * MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float3 wh = normalize(wo + wi); \n"\
" \n"\
"    return MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    MicrofacetDistribution_GGX_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
" \n"\
"    return MicrofacetGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet Blinn \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Blinn_D(float shininess, float3 w, float3 n) \n"\
"{ \n"\
"    float ndotw = fabs(dot(n, w)); \n"\
"    return (1.f / (2 * PI)) * (shininess + 2) * native_powr(ndotw, shininess); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Blinn_GetPdf(// Shininess \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 wh = normalize(wi + wo); \n"\
"    // costheta \n"\
"    float ndotwh = dot(dg->n, wh); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (2.f * PI * 4.f * dot(wo, wh)); \n"\
"    return denom > DENOM_EPS ? ((shininess + 1.f) * native_powr(ndotwh, shininess)) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Blinn_Sample(// Shininess param \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    // \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float costheta = native_powr(r1, 1.f / (shininess + 1.f)); \n"\
"    float sintheta = native_sqrt(1.f - costheta * costheta); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - cosphi * cosphi); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Blinn_G(float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    float ndotwh = fabs(dot(n, wh)); \n"\
"    float ndotwo = fabs(dot(n, wo)); \n"\
"    float ndotwi = fabs(dot(n, wi)); \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    return min(1.f, min(2.f * ndotwh * ndotwo / wodotwh, 2.f * ndotwh * ndotwi / wodotwh)); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF evaluation \n"\
"float3 MicrofacetBlinn_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
"    const float shininess = dg->mat.ns; \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Blinn_G(wi, wo, wh, dg->n) * MicrofacetDistribution_Blinn_D(shininess, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float MicrofacetBlinn_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float shininess = dg->mat.ns; \n"\
"    return MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 MicrofacetBlinn_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    if (dot(dg->n, wi) <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float shininess = dg->mat.ns; \n"\
"    MicrofacetDistribution_Blinn_Sample(shininess, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBlinn_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/* \n"\
" Lambert BRDF \n"\
" */ \n"\
" /// Lambert BRDF evaluation \n"\
"float3 Lambert_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Lambert_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return fabs(dot(dg->n, wo)) / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Lambert_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    *wo = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *pdf = fabs(dot(dg->n, *wo)) / PI; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal reflection BRDF \n"\
" */ \n"\
"float3 IdealReflect_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Translucent_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float3 n = ndotwi > DENOM_EPS ? -dg->n : dg->n; \n"\
" \n"\
"    *wo = normalize(Sample_MapToHemisphere(sample, n, 1.f)); \n"\
" \n"\
"    *pdf = fabs(dot(n, *wo)) / PI; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"// Lambert BRDF evaluation \n"\
"float3 Translucent_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Translucent_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0) \n"\
"        return 0.f; \n"\
" \n"\
"    return fabs(ndotwo) / PI; \n"\
"} \n"\
" \n"\
"float IdealReflect_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealReflect_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    // Mirror reflect wi \n"\
"    *wo = normalize(2.f * ndotwi * dg->n - wi); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // Return reflectance value \n"\
"    return coswo > DENOM_EPS ? (F * ks * (1.f / coswo)) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal refraction BTDF \n"\
" */ \n"\
" \n"\
"float3 IdealRefract_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float IdealRefract_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealRefract_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float cosi = dot(dg->n, wi); \n"\
" \n"\
"    bool entering = cosi > 0.f; \n"\
"    float3 n = dg->n; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (!entering) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        n = -dg->n; \n"\
"        cosi = -cosi; \n"\
"    } \n"\
" \n"\
"    float eta = etai / etat; \n"\
"    float sini2 = 1.f - cosi * cosi; \n"\
" \n"\
"    float sint2 = eta * eta * sini2; \n"\
" \n"\
"    if (sint2 >= 1.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
" \n"\
"    // Transmitted ray \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *wo = normalize(-n * cost + normalize(n * cosi - wi) * native_sqrt(max(sint2, 0.f))); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    return cost > 0.0001f ? F * (((etai * etai) / (etat * etat)) * ks / cost) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_GGX_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi == 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_GGX_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionGGX_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_Beckmann_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionBeckmann_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 Passthrough_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
" \n"\
"    *wo = -wi; \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    //  \n"\
"    return coswo > 0.0001f ? (1.f / coswo) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Dispatch functions \n"\
" */ \n"\
"float3 Bxdf_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 Bxdf_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at w \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kPassthrough: \n"\
"        return Passthrough_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Bxdf_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kPassthrough: \n"\
"        return 0.f; \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Emissive BRDF sampling \n"\
"float3 Emissive_GetLe( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    return kd; \n"\
"} \n"\
" \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsSingular(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealReflect || dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough; \n"\
"} \n"\
" \n"\
"/// BxDF emission check \n"\
"bool Bxdf_IsEmissive(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kEmissive; \n"\
"} \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsBtdf(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough || dg->mat.type == kTranslucent || \n"\
"        dg->mat.type == kMicrofacetRefractionGGX || dg->mat.type == kMicrofacetRefractionBeckmann; \n"\
"} \n"\
" \n"\
"#endif // BXDF_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef LIGHT_CL \n"\
"#define LIGHT_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
" \n"\
" \n"\
"bool IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, float* a, float* b) \n"\
"{ \n"\
"    const float3 e1 = v2 - v1; \n"\
"    const float3 e2 = v3 - v1; \n"\
"    const float3 s1 = cross(r->d.xyz, e2); \n"\
"    const float  invd = native_recip(dot(s1, e1)); \n"\
"    const float3 d = r->o.xyz - v1; \n"\
"    const float  b1 = dot(d, s1) * invd; \n"\
"    const float3 s2 = cross(d, e1); \n"\
"    const float  b2 = dot(r->d.xyz, s2) * invd; \n"\
"    const float temp = dot(e2, s2) * invd; \n"\
" \n"\
"    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f) \n"\
"    { \n"\
"        return false; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *a = b1; \n"\
"        *b = b2; \n"\
"        return true; \n"\
"    } \n"\
"} \n"\
" \n"\
"/* \n"\
" Environment light \n"\
" */ \n"\
"/// Get intensity for a given direction \n"\
"float3 EnvironmentLight_GetLe(// Light \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3* wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    // Sample envmap \n"\
"    *wo *= 100000.f; \n"\
"    // \n"\
"    return scene->envmapmul * Texture_SampleEnvMap(normalize(*wo), TEXTURE_ARGS_IDX(scene->envmapidx)); \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 EnvironmentLight_Sample(// Light \n"\
"                               Light const* light, \n"\
"                               // Scene \n"\
"                               Scene const* scene, \n"\
"                               // Geometry \n"\
"                               DifferentialGeometry const* dg, \n"\
"                               // Textures \n"\
"                               TEXTURE_ARG_LIST, \n"\
"                               // Sample \n"\
"                               float2 sample, \n"\
"                               // Direction to light source \n"\
"                               float3* wo, \n"\
"                               // PDF \n"\
"                               float* pdf \n"\
"                              ) \n"\
"{ \n"\
"    float3 d = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    // Generate direction \n"\
"    *wo = 100000.f * d; \n"\
" \n"\
"    // Envmap PDF \n"\
"    *pdf = fabs(dot(dg->n, normalize(d))) / PI; \n"\
" \n"\
"    // Sample envmap \n"\
"    return scene->envmapmul * Texture_SampleEnvMap(d, TEXTURE_ARGS_IDX(scene->envmapidx)); \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float EnvironmentLight_GetPdf( \n"\
"                              // Light \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3 wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return max(0.f, fabs(dot(dg->n, normalize(wo)))/ PI); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Area light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 AreaLight_GetLe(// Emissive object \n"\
"                       Light const* light, \n"\
"                       // Scene \n"\
"                       Scene const* scene, \n"\
"                       // Geometry \n"\
"                       DifferentialGeometry const* dg, \n"\
"                       // Direction to light source \n"\
"                       float3* wo, \n"\
"                       // Textures \n"\
"                       TEXTURE_ARG_LIST \n"\
"                       ) \n"\
"{ \n"\
"    ray r; \n"\
"    r.o.xyz = dg->p; \n"\
"    r.d.xyz = normalize(*wo); \n"\
" \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
" \n"\
" \n"\
"    // Intersect ray against this area light \n"\
" \n"\
"    float a, b; \n"\
"    if (IntersectTriangle(&r, v0, v1, v2, &a, &b)) \n"\
"    { \n"\
"        float3 n = normalize(transform_vector((1.f - a - b) * n0 + a * n1 + b * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"        float3 p = transform_point((1.f - a - b) * v0 + a * v1 + b * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float2 tx = (1.f - a - b) * uv0 + a * uv1 + b * uv2; \n"\
" \n"\
"        float3 d = p - dg->p; \n"\
"        float  ld = length(d); \n"\
"        *wo = p - dg->p; \n"\
" \n"\
"        int matidx = scene->materialids[shape.startidx / 3 + primidx]; \n"\
"        Material mat = scene->materials[matidx]; \n"\
" \n"\
"        const float3 ke = Texture_GetValue3f(mat.kx.xyz, tx, TEXTURE_ARGS_IDX(mat.kxmapidx)); \n"\
"        float ndotv = dot(n, -(normalize(d))); \n"\
"        return  ke; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 AreaLight_Sample(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST, \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Direction to light source \n"\
"                        float3* wo, \n"\
"                        // PDF \n"\
"                        float* pdf) \n"\
"{ \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
" \n"\
"    // Generate sample on triangle \n"\
"    float r0 = sample.x; \n"\
"    float r1 = sample.y; \n"\
" \n"\
"    // Convert random to barycentric coords \n"\
"    float2 uv; \n"\
"    uv.x = native_sqrt(r0) * (1.f - r1); \n"\
"    uv.y = native_sqrt(r0) * r1; \n"\
" \n"\
"    // Calculate barycentric position and normal \n"\
"    float3 n = normalize((1.f - uv.x - uv.y) * n0 + uv.x * n1 + uv.y * n2); \n"\
"    float3 p = (1.f - uv.x - uv.y) * v0 + uv.x * v1 + uv.y * v2; \n"\
"    float2 tx = (1.f - uv.x - uv.y) * uv0 + uv.x * uv1 + uv.y * uv2; \n"\
" \n"\
"    *wo = p - dg->p; \n"\
"    *pdf = 1.f / (length(cross(v2 - v0, v2 - v1)) * 0.5f); \n"\
" \n"\
"    int matidx = scene->materialids[shape.startidx / 3 + primidx]; \n"\
"    Material mat = scene->materials[matidx]; \n"\
" \n"\
"    const float3 ke = Texture_GetValue3f(mat.kx.xyz, tx, TEXTURE_ARGS_IDX(mat.kxmapidx)); \n"\
" \n"\
"    float3 v = -normalize(*wo); \n"\
" \n"\
"    float ndotv = dot(n, v); \n"\
" \n"\
"    if (ndotv > 0.f) \n"\
"    { \n"\
"        float denom = (length(*wo) * length(*wo)); \n"\
"        return denom > 0.f ? ke * ndotv / denom : 0.f; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float AreaLight_GetPdf(// Emissive object \n"\
"                       Light const* light, \n"\
"                       // Scene \n"\
"                       Scene const* scene, \n"\
"                       // Geometry \n"\
"                       DifferentialGeometry const* dg, \n"\
"                       // Direction to light source \n"\
"                       float3 wo, \n"\
"                       // Textures \n"\
"                       TEXTURE_ARG_LIST \n"\
"                       ) \n"\
"{ \n"\
"    ray r; \n"\
"    r.o.xyz = dg->p; \n"\
"    r.d.xyz = wo; \n"\
" \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Intersect ray against this area light \n"\
"    float a, b; \n"\
"    if (IntersectTriangle(&r, v0, v1, v2, &a, &b)) \n"\
"    { \n"\
"        float3 n = normalize(transform_vector((1.f - a - b) * n0 + a * n1 + b * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"        float3 p = transform_point((1.f - a - b) * v0 + a * v1 + b * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 d = p - dg->p; \n"\
"        float  ld = length(d); \n"\
" \n"\
"        float3 p0 = transform_point(v0, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 p1 = transform_point(v1, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 p2 = transform_point(v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
" \n"\
"        float area = 0.5f * length(cross(p2 - p0, p2 - p1)); \n"\
"        float denom = (fabs(dot(normalize(d), dg->n)) * area); \n"\
" \n"\
"        return denom > 0.f ? ld * ld / denom : 0.f; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/* \n"\
"Directional light \n"\
"*/ \n"\
"// Get intensity for a given direction \n"\
"float3 DirectionalLight_GetLe(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Direction to light source \n"\
"    float3* wo, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST \n"\
") \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 DirectionalLight_Sample(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Direction to light source \n"\
"    float3* wo, \n"\
"    // PDF \n"\
"    float* pdf) \n"\
"{ \n"\
"    *wo = 100000.f * -light->d; \n"\
"    *pdf = 1.f; \n"\
"    return light->intensity; \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float DirectionalLight_GetPdf(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Direction to light source \n"\
"    float3 wo, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST \n"\
") \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Point light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 PointLight_GetLe(// Emissive object \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3* wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 PointLight_Sample(// Emissive object \n"\
"                               Light const* light, \n"\
"                               // Scene \n"\
"                               Scene const* scene, \n"\
"                               // Geometry \n"\
"                               DifferentialGeometry const* dg, \n"\
"                               // Textures \n"\
"                               TEXTURE_ARG_LIST, \n"\
"                               // Sample \n"\
"                               float2 sample, \n"\
"                               // Direction to light source \n"\
"                               float3* wo, \n"\
"                               // PDF \n"\
"                               float* pdf) \n"\
"{ \n"\
"    *wo = light->p - dg->p; \n"\
"    *pdf = 1.f; \n"\
"    return light->intensity; \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float PointLight_GetPdf(// Emissive object \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3 wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Spot light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 SpotLight_GetLe(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Direction to light source \n"\
"                        float3* wo, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST \n"\
"                        ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 SpotLight_Sample(// Emissive object \n"\
"                         Light const* light, \n"\
"                         // Scene \n"\
"                         Scene const* scene, \n"\
"                         // Geometry \n"\
"                         DifferentialGeometry const* dg, \n"\
"                         // Textures \n"\
"                         TEXTURE_ARG_LIST, \n"\
"                         // Sample \n"\
"                         float2 sample, \n"\
"                         // Direction to light source \n"\
"                         float3* wo, \n"\
"                         // PDF \n"\
"                         float* pdf) \n"\
"{ \n"\
"    *wo = light->p - dg->p; \n"\
"    float ddotwo = dot(-normalize(*wo), light->d); \n"\
"     \n"\
"    if (ddotwo > light->oa) \n"\
"    { \n"\
"        *pdf = 1.f; \n"\
"        return ddotwo > light->ia ? light->intensity : light->intensity * (1.f - (light->ia - ddotwo) / (light->ia - light->oa)); \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float SpotLight_GetPdf(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Direction to light source \n"\
"                        float3 wo, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST \n"\
"                        ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/* \n"\
" Dispatch calls \n"\
" */ \n"\
" \n"\
"/// Get intensity for a given direction \n"\
"float3 Light_GetLe(// Light index \n"\
"                   int idx, \n"\
"                   // Scene \n"\
"                   Scene const* scene, \n"\
"                   // Geometry \n"\
"                   DifferentialGeometry const* dg, \n"\
"                   // Direction to light source \n"\
"                   float3* wo, \n"\
"                   // Textures \n"\
"                   TEXTURE_ARG_LIST \n"\
"                   ) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kArea: \n"\
"            return AreaLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kPoint: \n"\
"            return PointLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kSpot: \n"\
"            return SpotLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 Light_Sample(// Light index \n"\
"                    int idx, \n"\
"                    // Scene \n"\
"                    Scene const* scene, \n"\
"                    // Geometry \n"\
"                    DifferentialGeometry const* dg, \n"\
"                    // Textures \n"\
"                    TEXTURE_ARG_LIST, \n"\
"                    // Sample \n"\
"                    float2 sample, \n"\
"                    // Direction to light source \n"\
"                    float3* wo, \n"\
"                    // PDF \n"\
"                    float* pdf) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kArea: \n"\
"            return AreaLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kPoint: \n"\
"            return PointLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kSpot: \n"\
"            return SpotLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float Light_GetPdf(// Light index \n"\
"                   int idx, \n"\
"                   // Scene \n"\
"                   Scene const* scene, \n"\
"                   // Geometry \n"\
"                   DifferentialGeometry const* dg, \n"\
"                   // Direction to light source \n"\
"                   float3 wo, \n"\
"                   // Textures \n"\
"                   TEXTURE_ARG_LIST \n"\
"                   ) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kArea: \n"\
"            return AreaLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kPoint: \n"\
"            return PointLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kSpot: \n"\
"            return SpotLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Check if the light is singular \n"\
"bool Light_IsSingular(__global Light const* light) \n"\
"{ \n"\
"    return light->type == kPoint || \n"\
"        light->type == kSpot || \n"\
"        light->type == kDirectional; \n"\
"} \n"\
" \n"\
"#endif // LIGHT_CLnv \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef CAMERA_CL \n"\
"#define CAMERA_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SAMPLING_CL \n"\
"#define SAMPLING_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToHemisphere( \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Hemisphere normal \n"\
"                        float3 n, \n"\
"                        // Cos power \n"\
"                        float e \n"\
"                        ) \n"\
"{ \n"\
"    // Construct basis \n"\
"    float3 u = GetOrthoVector(n); \n"\
"    float3 v = cross(u, n); \n"\
"    u = cross(n, v); \n"\
"     \n"\
"    // Calculate 2D sample \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
"     \n"\
"    // Transform to spherical coordinates \n"\
"    float sinpsi = sin(2*PI*r1); \n"\
"    float cospsi = cos(2*PI*r1); \n"\
"    float costheta = pow(1.f - r2, 1.f/(e + 1.f)); \n"\
"    float sintheta = sqrt(1.f - costheta * costheta); \n"\
"     \n"\
"    // Return the result \n"\
"    return normalize(u * sintheta * cospsi + v * sintheta * sinpsi + n * costheta); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDisk( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float r = native_sqrt(sample.x);  \n"\
"    float theta = 2 * PI * sample.y; \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDiskConcentric( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float2 offset = 2.f * sample - make_float2(1.f, 1.f); \n"\
" \n"\
"    if (offset.x == 0 && offset.y == 0) return 0.f; \n"\
" \n"\
"    float theta, r; \n"\
" \n"\
"    if (fabs(offset.x) > fabs(offset.y))  \n"\
"    { \n"\
"        r = offset.x; \n"\
"        theta = PI / 4.f * (offset.y / offset.x); \n"\
"    } \n"\
"    else  \n"\
"    { \n"\
"        r = offset.y; \n"\
"        theta = PI / 2.f * ( 1.f - 0.5f * (offset.x / offset.y)); \n"\
"    } \n"\
"     \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToSphere( \n"\
"                        // Sample \n"\
"                        float2 sample \n"\
"                        ) \n"\
"{ \n"\
"    float z = 1.f - 2.f * sample.x; \n"\
"    float r = native_sqrt(max(0.f, 1.f - z*z)); \n"\
"    float phi = 2.f * PI * sample.y; \n"\
"    float x = cos(phi); \n"\
"    float y = sin(phi); \n"\
"     \n"\
"    // Return the result \n"\
"    return make_float3(x,y,z); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToPolygon(int n, float2 sample, float sample1) \n"\
"{ \n"\
"    float theta = 2.f * PI / n; \n"\
" \n"\
"    int edge = clamp((int)(sample1 * n), 0, n - 1); \n"\
" \n"\
"    float t = native_sqrt(sample.x); \n"\
"    float u = 1.f - t; \n"\
"    float v = t * sample.y; \n"\
" \n"\
"    float2 v1 = make_float2(native_cos(theta * edge), native_sin(theta * edge)); \n"\
"    float2 v2 = make_float2(native_cos(theta * (edge + 1)), native_sin(theta * (edge + 1))); \n"\
" \n"\
" \n"\
"    return u*v1 + v*v2;; \n"\
"} \n"\
" \n"\
"/// Power heuristic for multiple importance sampling \n"\
"float PowerHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f*f) / (f*f + g*g); \n"\
"} \n"\
" \n"\
"/// Balance heuristic for multiple importance sampling \n"\
"float BalanceHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f) / (f + g); \n"\
"} \n"\
" \n"\
"typedef struct \n"\
"{ \n"\
"    uint seq; \n"\
"    uint s0; \n"\
"    uint s1; \n"\
"    uint s2; \n"\
"} SobolSampler; \n"\
" \n"\
"float2 UniformSampler_Sample2D(Rng* rng) \n"\
"{ \n"\
"    float2 sample; \n"\
"    sample.x = RandFloat(rng); \n"\
"    sample.y = RandFloat(rng); \n"\
"    return sample; \n"\
"} \n"\
" \n"\
"#define MATSIZE 52 \n"\
" \n"\
"// The code is taken from: http://gruenschloss.org/sobol/kuo-2d-proj-single-precision.zip \n"\
"//  \n"\
"float SobolSampler_Sample1D(uint index, uint dimension, uint scramble, __global uint const* mat) \n"\
"{ \n"\
"    uint result = scramble; \n"\
"    for (uint i = dimension * MATSIZE; index; index >>= 1, ++i) \n"\
"    { \n"\
"        if (index & 1) \n"\
"            result ^= mat[i]; \n"\
"    } \n"\
" \n"\
"    return result * (1.f / (1UL << 32)); \n"\
"} \n"\
" \n"\
" \n"\
"#endif // SAMPLING_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Camera descriptor \n"\
"/// \n"\
"typedef struct _Camera \n"\
"    { \n"\
"        // Camera coordinate frame \n"\
"        float3 forward; \n"\
"        float3 right; \n"\
"        float3 up; \n"\
"        float3 p; \n"\
" \n"\
"        // Image plane width & height in current units \n"\
"        float2 dim; \n"\
" \n"\
"        // Near and far Z \n"\
"        float2 zcap; \n"\
"        // Focal lenght \n"\
"        float focal_length; \n"\
"        // Camera aspect ratio \n"\
"        float aspect; \n"\
"        float focus_distance; \n"\
"        float aperture; \n"\
"    } Camera; \n"\
" \n"\
" \n"\
"/// Ray generation kernel for perspective camera. \n"\
"/// Rays are generated from camera position to viewing plane \n"\
"/// using random sample distribution within the pixel. \n"\
"/// \n"\
"__kernel void PerspectiveCamera_GeneratePaths( \n"\
"                             // Camera descriptor \n"\
"                             __global Camera const* camera, \n"\
"                             // Image resolution \n"\
"                             int imgwidth, \n"\
"                             int imgheight, \n"\
"                             // RNG seed value \n"\
"                             int randseed, \n"\
"                             // Output rays \n"\
"                             __global ray* rays, \n"\
"                             __global SobolSampler* samplers, \n"\
"                             __global uint const* sobolmat, \n"\
"                             int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"                             ,__global Path* paths \n"\
"#endif \n"\
"        ) \n"\
"{ \n"\
"    int2 globalid; \n"\
"    globalid.x  = get_global_id(0); \n"\
"    globalid.y  = get_global_id(1); \n"\
" \n"\
"    // Check borders \n"\
"    if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"    { \n"\
"        // Get pointer to ray to handle \n"\
"        __global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        __global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"        // Prepare RNG \n"\
"        Rng rng; \n"\
"        InitRng(randseed +  globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"#ifdef SOBOL \n"\
"        __global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"        if (reset) \n"\
"        { \n"\
"            sampler->seq = 0; \n"\
"            sampler->s0 = RandUint(&rng); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            sampler->seq++; \n"\
"        } \n"\
" \n"\
"        float2 sample0; \n"\
"        sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"        sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
"#else \n"\
"        float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"        // Calculate [0..1] image plane sample \n"\
"        float2 imgsample; \n"\
"        imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"        imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"        // Transform into [-0.5, 0.5] \n"\
"        float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"        // Transform into [-dim/2, dim/2] \n"\
"        float2 csample = hsample * camera->dim; \n"\
" \n"\
"        // Calculate direction to image plane \n"\
"        myray->d.xyz = normalize(camera->focal_length * camera->forward + csample.x * camera->right + csample.y * camera->up); \n"\
"        // Origin == camera position + nearz * d \n"\
"        myray->o.xyz = camera->p + camera->zcap.x * myray->d.xyz; \n"\
"        // Max T value = zfar - znear since we moved origin to znear \n"\
"        myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"        // Generate random time from 0 to 1 \n"\
"        myray->d.w = sample0.x; \n"\
"        // Set ray max \n"\
"        myray->extra.x = 0xFFFFFFFF; \n"\
"        myray->extra.y = 0xFFFFFFFF; \n"\
"        Ray_SetExtra(myray, 1.f); \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"        mypath->volume = -1; \n"\
"        mypath->flags = 0; \n"\
"        mypath->active = 0xFF; \n"\
"#endif \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Ray generation kernel for perspective camera. \n"\
"/// Rays are generated from camera position to viewing plane \n"\
"/// using random sample distribution within the pixel. \n"\
"/// \n"\
"__kernel void PerspectiveCameraDof_GeneratePaths( \n"\
"    // Camera descriptor \n"\
"    __global Camera const* camera, \n"\
"    // Image resolution \n"\
"    int imgwidth, \n"\
"    int imgheight, \n"\
"    // RNG seed value \n"\
"    int randseed, \n"\
"    // Output rays \n"\
"    __global ray* rays, \n"\
"    __global SobolSampler* samplers, \n"\
"    __global uint const* sobolmat, \n"\
"    int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"    , __global Path* paths \n"\
"#endif \n"\
"    ) \n"\
"{ \n"\
"    int2 globalid; \n"\
"    globalid.x = get_global_id(0); \n"\
"    globalid.y = get_global_id(1); \n"\
" \n"\
"    // Check borders \n"\
"    if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"    { \n"\
"        // Get pointer to ray to handle \n"\
"        __global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        __global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"        // Prepare RNG \n"\
"        Rng rng; \n"\
"        InitRng(randseed + globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"        // \n"\
"#ifdef SOBOL \n"\
"        __global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"        if (reset) \n"\
"        { \n"\
"            sampler->seq = 0; \n"\
"            sampler->s0 = RandUint(&rng); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            sampler->seq++; \n"\
"        } \n"\
" \n"\
"        float2 sample0; \n"\
"        sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"        sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
" \n"\
"        float2 sample1; \n"\
"        sample1.x = SobolSampler_Sample1D(sampler->seq, kLensX, sampler->s0, sobolmat); \n"\
"        sample1.y = SobolSampler_Sample1D(sampler->seq, kLensY, sampler->s0, sobolmat); \n"\
"#else \n"\
"        float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"        float2 sample1 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"        // Calculate [0..1] image plane sample \n"\
"        float2 imgsample; \n"\
"        imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"        imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"        // Transform into [-0.5, 0.5] \n"\
"        float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"        // Transform into [-dim/2, dim/2] \n"\
"        float2 csample = hsample * camera->dim; \n"\
" \n"\
" \n"\
"        float2 lsample = camera->aperture * Sample_MapToDiskConcentric(sample1); \n"\
"        float2 fpsample = csample * camera->focus_distance / camera->focal_length; \n"\
"        float2 cdir = fpsample - lsample; \n"\
" \n"\
"        float3 o = camera->p + lsample.x * camera->right + lsample.y * camera->up; \n"\
"        float3 d = normalize(camera->forward * camera->focus_distance + camera->right * cdir.x + camera->up * cdir.y); \n"\
" \n"\
" \n"\
"        // Calculate direction to image plane \n"\
"        myray->d.xyz = d; \n"\
"        // Origin == camera position + nearz * d \n"\
"        myray->o.xyz = o; \n"\
"        // Max T value = zfar - znear since we moved origin to znear \n"\
"        myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"        // Generate random time from 0 to 1 \n"\
"        myray->d.w = sample0.x; \n"\
"        // Set ray max \n"\
"        myray->extra.x = 0xFFFFFFFF; \n"\
"        myray->extra.y = 0xFFFFFFFF; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"        mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"        mypath->volume = -1; \n"\
"        mypath->flags = 0; \n"\
"        mypath->active = 0xFF; \n"\
"#endif \n"\
"    } \n"\
"} \n"\
" \n"\
"#define M_PI 3.14159265358979323846 \n"\
" \n"\
"/// Ray generation kernel for spherical camera. \n"\
"/// \n"\
"__kernel void SphericalCamera_GeneratePaths( \n"\
"	// Camera descriptor \n"\
"	__global Camera const* camera, \n"\
"	// Image resolution \n"\
"	int imgwidth, \n"\
"	int imgheight, \n"\
"	// RNG seed value \n"\
"	int randseed, \n"\
"	// Output rays \n"\
"	__global ray* rays, \n"\
"	__global SobolSampler* samplers, \n"\
"	__global uint const* sobolmat, \n"\
"	int reset \n"\
"#ifndef NO_PATH_DATA \n"\
"	, __global Path* paths \n"\
"#endif \n"\
") \n"\
"{ \n"\
"	int2 globalid; \n"\
"	globalid.x = get_global_id(0); \n"\
"	globalid.y = get_global_id(1); \n"\
" \n"\
"	// Check borders \n"\
"	if (globalid.x < imgwidth && globalid.y < imgheight) \n"\
"	{ \n"\
"		// Get pointer to ray to handle \n"\
"		__global ray* myray = rays + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"		__global Path* mypath = paths + globalid.y * imgwidth + globalid.x; \n"\
"#endif \n"\
" \n"\
"		// Prepare RNG \n"\
"		Rng rng; \n"\
"		InitRng(randseed + globalid.x * 157 + 10433 * globalid.y, &rng); \n"\
" \n"\
"#ifdef SOBOL \n"\
"		__global SobolSampler* sampler = samplers + globalid.y * imgwidth + globalid.x; \n"\
" \n"\
"		if (reset) \n"\
"		{ \n"\
"			sampler->seq = 0; \n"\
"			sampler->s0 = RandUint(&rng); \n"\
"		} else \n"\
"		{ \n"\
"			sampler->seq++; \n"\
"		} \n"\
" \n"\
"		float2 sample0; \n"\
"		sample0.x = SobolSampler_Sample1D(sampler->seq, kPixelX, sampler->s0, sobolmat); \n"\
"		sample0.y = SobolSampler_Sample1D(sampler->seq, kPixelY, sampler->s0, sobolmat); \n"\
"#else \n"\
"		float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
" \n"\
"		// Calculate [0..1] image plane sample \n"\
"		float2 imgsample; \n"\
"		imgsample.x = (float)globalid.x / imgwidth + sample0.x / imgwidth; \n"\
"		imgsample.y = (float)globalid.y / imgheight + sample0.y / imgheight; \n"\
" \n"\
"		// Transform into [-0.5, 0.5] \n"\
"		float2 hsample = imgsample - make_float2(0.5f, 0.5f); \n"\
"		// Transform into [-dim/2, dim/2] \n"\
"		float2 csample = hsample * camera->dim; \n"\
" \n"\
" \n"\
"		float phi = (2.0 * M_PI) * (imgsample.x); \n"\
"		float theta = (M_PI) * (imgsample.y); \n"\
" \n"\
"		float4 m1, m2, m3, m4; \n"\
"		float4 n1, n2, n3, n4; \n"\
" \n"\
"		m1 = (float4) { cos(phi), 0.0, -sin(phi), 0.0 }; \n"\
"		m2 = (float4) { 0.0, 1.0, 0.0, 0.0 }; \n"\
"		m3 = (float4) { sin(phi), 0.0, cos(phi), 0.0 }; \n"\
"		m4 = (float4) { 0.0, 0.0, 0.0, 1.0 }; \n"\
" \n"\
" \n"\
"		n1 = (float4) { cos(theta), sin(theta), 0.0, 0.0 }; \n"\
"		n2 = (float4) { -sin(theta), cos(theta), 0.0, 0.0 }; \n"\
"		n3 = (float4) { 0.0, 0.0, 1.0, 0.0 }; \n"\
"		n4 = (float4) { 0.0, 0.0, 0.0, 1.0 }; \n"\
" \n"\
"		//myray->d.xyz = normalize(camera->focal_length * transform_vector(transform_vector(-camera->up.xyz, n1, n2, n3, n4), m1, m2, m3, m4)); \n"\
"		myray->d.xyz = normalize(camera->focal_length * transform_vector(transform_vector(-(float3) { 0, 1, 0 }, n1, n2, n3, n4), m1, m2, m3, m4)); \n"\
" \n"\
"		// Calculate direction to image plane \n"\
"		//myray->d.xyz = normalize(camera->focal_length * camera->forward + csample.x * camera->right + csample.y * camera->up); \n"\
"		// Origin == camera position + nearz * d \n"\
"		myray->o.xyz = camera->p + camera->zcap.x * myray->d.xyz; \n"\
"		// Max T value = zfar - znear since we moved origin to znear \n"\
"		myray->o.w = camera->zcap.y - camera->zcap.x; \n"\
"		// Generate random time from 0 to 1 \n"\
"		myray->d.w = sample0.x; \n"\
"		// Set ray max \n"\
"		myray->extra.x = 0xFFFFFFFF; \n"\
"		myray->extra.y = 0xFFFFFFFF; \n"\
" \n"\
"#ifndef NO_PATH_DATA \n"\
"		mypath->throughput = make_float3(1.f, 1.f, 1.f); \n"\
"		mypath->volume = -1; \n"\
"		mypath->flags = 0; \n"\
"		mypath->active = 0xFF; \n"\
"#endif \n"\
"	} \n"\
"} \n"\
" \n"\
" \n"\
"#endif // CAMERA_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SCENE_CL \n"\
"#define SCENE_CL \n"\
" \n"\
" \n"\
"/// Fill DifferentialGeometry structure based on intersection info from RadeonRays \n"\
"void FillDifferentialGeometry(// Scene \n"\
"                              Scene const* scene, \n"\
"                              // RadeonRays intersection \n"\
"                              Intersection const* isect, \n"\
"                              // Differential geometry \n"\
"                              DifferentialGeometry* diffgeo \n"\
"                              ) \n"\
"{ \n"\
"    // Determine shape and polygon \n"\
"    int shapeid = isect->shapeid - 1; \n"\
"    int primid = isect->primid; \n"\
"     \n"\
"    // Get barycentrics \n"\
"    float2 uv = isect->uvwt.xy; \n"\
"     \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeid]; \n"\
"    //float3 linearvelocity = shape.linearvelocity; \n"\
"    //float4 angularvelocity = shape.angularvelocity; \n"\
"     \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primid]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primid + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primid + 2]; \n"\
"     \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
"     \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
"     \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
"     \n"\
"    // Calculate barycentric position and normal \n"\
"    diffgeo->n = normalize(transform_vector((1.f - uv.x - uv.y) * n0 + uv.x * n1 + uv.y * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"    diffgeo->p = transform_point((1.f - uv.x - uv.y) * v0 + uv.x * v1 + uv.y * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    diffgeo->uv = (1.f - uv.x - uv.y) * uv0 + uv.x * uv1 + uv.y * uv2; \n"\
"     \n"\
"    // Get material at shading point \n"\
"    int matidx = scene->materialids[shape.startidx / 3 + primid]; \n"\
"    diffgeo->mat = scene->materials[matidx]; \n"\
" \n"\
"    /// From PBRT book \n"\
"    /// Construct tangent basis on the fly and apply normal map \n"\
"    float du1 = uv0.x - uv2.x; \n"\
"    float du2 = uv1.x - uv2.x; \n"\
"    float dv1 = uv0.y - uv2.y; \n"\
"    float dv2 = uv1.y - uv2.y; \n"\
"     \n"\
"    float3 dp1 = v0 - v2; \n"\
"    float3 dp2 = v1 - v2; \n"\
"     \n"\
"    float det = du1 * dv2 - dv1 * du2; \n"\
"     \n"\
"    if (0 && det != 0.f) \n"\
"    { \n"\
"        float invdet = 1.f / det; \n"\
"        diffgeo->dpdu = normalize( (dv2 * dp1 - dv1 * dp2) * invdet ); \n"\
"        diffgeo->dpdv = normalize( (-du2 * dp1 + du1 * dp2) * invdet ); \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        diffgeo->dpdu = normalize(GetOrthoVector(diffgeo->n)); \n"\
"        diffgeo->dpdv = normalize(cross(diffgeo->n, diffgeo->dpdu)); \n"\
"    } \n"\
"     \n"\
"    diffgeo->ng = normalize(cross(diffgeo->dpdv, diffgeo->dpdu)); \n"\
" \n"\
"    //if (dot(diffgeo->ng, diffgeo->n) < 0.f) \n"\
"        //diffgeo->ng = -diffgeo->ng; \n"\
" \n"\
"    // Fix all to be orthogonal \n"\
"    //diffgeo->dpdv = normalize(cross(diffgeo->ng, diffgeo->dpdu)); \n"\
"    //diffgeo->dpdu = normalize(cross(diffgeo->dpdv, diffgeo->ng)); \n"\
" \n"\
"    float3 p0 = transform_point(v0, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    float3 p1 = transform_point(v1, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    float3 p2 = transform_point(v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
" \n"\
"    diffgeo->area = 0.5f * length(cross(p2 - p0, p2 - p1)); \n"\
"     \n"\
"    // Apply transform & linear motion blur \n"\
"    //v += (linearvelocity * time); \n"\
"    // MT^-1 should be used if scale is present \n"\
"    //n = rotate_vector(n, angularvelocity); \n"\
"} \n"\
" \n"\
"int Scene_SampleLight(Scene const* scene, float sample, float* pdf) \n"\
"{ \n"\
"    int num_lights = scene->num_lights; \n"\
"    int light_idx = clamp((int)(sample * num_lights), 0, num_lights - 1); \n"\
"    *pdf = 1.f / num_lights; \n"\
"    return light_idx; \n"\
"} \n"\
" \n"\
" \n"\
"#endif \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef MATERIAL_CL \n"\
"#define MATERIAL_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef BXDF_CL \n"\
"#define BXDF_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"#define DENOM_EPS 0.0f \n"\
"#define ROUGHNESS_EPS 0.0001f \n"\
" \n"\
"enum Bxdf \n"\
"{ \n"\
"    kZero, \n"\
"    kLambert, \n"\
"    kIdealReflect, \n"\
"    kIdealRefract, \n"\
"    kMicrofacetBlinn, \n"\
"    kMicrofacetBeckmann, \n"\
"    kMicrofacetGGX, \n"\
"    kLayered, \n"\
"    kFresnelBlend, \n"\
"    kMix, \n"\
"    kEmissive, \n"\
"    kPassthrough, \n"\
"    kTranslucent, \n"\
"    kMicrofacetRefractionGGX, \n"\
"    kMicrofacetRefractionBeckmann \n"\
"}; \n"\
" \n"\
"enum BxdfFlags \n"\
"{ \n"\
"    kReflection = (1 << 0), \n"\
"    kTransmission = (1 << 1), \n"\
"    kDiffuse = (1 << 2), \n"\
"    kSpecular = (1 << 3), \n"\
"    kGlossy = (1 << 4), \n"\
"    kAllReflection = kReflection | kDiffuse | kSpecular | kGlossy, \n"\
"    kAllTransmission = kTransmission | kDiffuse | kSpecular | kGlossy, \n"\
"    kAll = kReflection | kTransmission | kDiffuse | kSpecular | kGlossy \n"\
"}; \n"\
" \n"\
" \n"\
"/// Schlick's approximation of Fresnel equtions \n"\
"float SchlickFresnel(float eta, float ndotw) \n"\
"{ \n"\
"    const float f = ((1.f - eta) / (1.f + eta)) * ((1.f - eta) / (1.f + eta)); \n"\
"    const float m = 1.f - fabs(ndotw); \n"\
"    const float m2 = m*m; \n"\
"    return f + (1.f - f) * m2 * m2 * m; \n"\
"} \n"\
" \n"\
"/// Full Fresnel equations \n"\
"float FresnelDielectric(float etai, float etat, float ndotwi, float ndotwt) \n"\
"{ \n"\
"    // Parallel and perpendicular polarization \n"\
"    float rparl = ((etat * ndotwi) - (etai * ndotwt)) / ((etat * ndotwi) + (etai * ndotwt)); \n"\
"    float rperp = ((etai * ndotwi) - (etat * ndotwt)) / ((etai * ndotwi) + (etat * ndotwt)); \n"\
"    return (rparl*rparl + rperp*rperp) * 0.5f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Microfacet Beckmann \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Beckmann_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = dot(m, n); \n"\
" \n"\
"    if (ndotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = sinmn / ndotm; \n"\
"    float a2 = roughness * roughness; \n"\
" \n"\
"    return (1.f / (PI * a2 * ndotm2 * ndotm2)) * native_exp(-tanmn * tanmn / a2); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Beckmann_GetPdf( \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 m = normalize(wi + wo); \n"\
"    float wodotm = dot(wo, m); \n"\
" \n"\
"    if (wodotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    // \n"\
"    float mpdf = MicrofacetDistribution_Beckmann_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
" \n"\
"    return mpdf / (4.f * wodotm); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_Sample(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_SampleNormal(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"float MicrofacetDistribution_Beckmann_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = sinnv / ndotv; \n"\
"    float a = tannv > DENOM_EPS ? 1.f / (roughness * tannv) : 0.f; \n"\
"    float a2 = a * a; \n"\
" \n"\
"    if (a < 1.6f) \n"\
"        return 1.f; \n"\
" \n"\
"    return (3.535f * a + 2.181f * a2) / (1.f + 2.276f * a + 2.577f * a2); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Beckmann_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_Beckmann_G1(roughness, wi, wh, n) * MicrofacetDistribution_Beckmann_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
" \n"\
"float3 MicrofacetBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = 4.f * costhetao * costhetai; \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    return MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    MicrofacetDistribution_Beckmann_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet GGX \n"\
" */ \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_GGX_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = fabs(dot(m, n)); \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = ndotm > DENOM_EPS ? sinmn / ndotm : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    float denom = (PI * ndotm2 * ndotm2 * (a2 + tanmn * tanmn) * (a2 + tanmn * tanmn)); \n"\
"    return denom > DENOM_EPS ? (a2 / denom) : 0.f; \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_GGX_GetPdf( \n"\
"    // Halfway vector \n"\
"    float3 m, \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float mpdf = MicrofacetDistribution_GGX_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (4.f * fabs(dot(wo, m))); \n"\
" \n"\
"    return denom > DENOM_EPS ? mpdf / denom : 0.f; \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_Sample( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*fabs(dot(wi, wh)) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_SampleNormal( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Differential geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"// \n"\
"float MicrofacetDistribution_GGX_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = ndotv > 0.f ? sinnv / ndotv : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    return 2.f / (1.f + native_sqrt(1.f + a2 * tannv * tannv)); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_GGX_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_GGX_G1(roughness, wi, wh, n) * MicrofacetDistribution_GGX_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > 0.f ? F * ks * MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float3 wh = normalize(wo + wi); \n"\
" \n"\
"    return MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    MicrofacetDistribution_GGX_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
" \n"\
"    return MicrofacetGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet Blinn \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Blinn_D(float shininess, float3 w, float3 n) \n"\
"{ \n"\
"    float ndotw = fabs(dot(n, w)); \n"\
"    return (1.f / (2 * PI)) * (shininess + 2) * native_powr(ndotw, shininess); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Blinn_GetPdf(// Shininess \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 wh = normalize(wi + wo); \n"\
"    // costheta \n"\
"    float ndotwh = dot(dg->n, wh); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (2.f * PI * 4.f * dot(wo, wh)); \n"\
"    return denom > DENOM_EPS ? ((shininess + 1.f) * native_powr(ndotwh, shininess)) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Blinn_Sample(// Shininess param \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    // \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float costheta = native_powr(r1, 1.f / (shininess + 1.f)); \n"\
"    float sintheta = native_sqrt(1.f - costheta * costheta); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - cosphi * cosphi); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Blinn_G(float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    float ndotwh = fabs(dot(n, wh)); \n"\
"    float ndotwo = fabs(dot(n, wo)); \n"\
"    float ndotwi = fabs(dot(n, wi)); \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    return min(1.f, min(2.f * ndotwh * ndotwo / wodotwh, 2.f * ndotwh * ndotwi / wodotwh)); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF evaluation \n"\
"float3 MicrofacetBlinn_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
"    const float shininess = dg->mat.ns; \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Blinn_G(wi, wo, wh, dg->n) * MicrofacetDistribution_Blinn_D(shininess, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float MicrofacetBlinn_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float shininess = dg->mat.ns; \n"\
"    return MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 MicrofacetBlinn_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    if (dot(dg->n, wi) <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float shininess = dg->mat.ns; \n"\
"    MicrofacetDistribution_Blinn_Sample(shininess, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBlinn_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/* \n"\
" Lambert BRDF \n"\
" */ \n"\
" /// Lambert BRDF evaluation \n"\
"float3 Lambert_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Lambert_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return fabs(dot(dg->n, wo)) / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Lambert_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    *wo = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *pdf = fabs(dot(dg->n, *wo)) / PI; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal reflection BRDF \n"\
" */ \n"\
"float3 IdealReflect_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Translucent_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float3 n = ndotwi > DENOM_EPS ? -dg->n : dg->n; \n"\
" \n"\
"    *wo = normalize(Sample_MapToHemisphere(sample, n, 1.f)); \n"\
" \n"\
"    *pdf = fabs(dot(n, *wo)) / PI; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"// Lambert BRDF evaluation \n"\
"float3 Translucent_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Translucent_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0) \n"\
"        return 0.f; \n"\
" \n"\
"    return fabs(ndotwo) / PI; \n"\
"} \n"\
" \n"\
"float IdealReflect_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealReflect_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    // Mirror reflect wi \n"\
"    *wo = normalize(2.f * ndotwi * dg->n - wi); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // Return reflectance value \n"\
"    return coswo > DENOM_EPS ? (F * ks * (1.f / coswo)) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal refraction BTDF \n"\
" */ \n"\
" \n"\
"float3 IdealRefract_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float IdealRefract_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealRefract_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float cosi = dot(dg->n, wi); \n"\
" \n"\
"    bool entering = cosi > 0.f; \n"\
"    float3 n = dg->n; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (!entering) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        n = -dg->n; \n"\
"        cosi = -cosi; \n"\
"    } \n"\
" \n"\
"    float eta = etai / etat; \n"\
"    float sini2 = 1.f - cosi * cosi; \n"\
" \n"\
"    float sint2 = eta * eta * sini2; \n"\
" \n"\
"    if (sint2 >= 1.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
" \n"\
"    // Transmitted ray \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *wo = normalize(-n * cost + normalize(n * cosi - wi) * native_sqrt(max(sint2, 0.f))); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    return cost > 0.0001f ? F * (((etai * etai) / (etat * etat)) * ks / cost) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_GGX_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi == 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_GGX_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionGGX_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_Beckmann_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionBeckmann_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 Passthrough_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
" \n"\
"    *wo = -wi; \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    //  \n"\
"    return coswo > 0.0001f ? (1.f / coswo) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Dispatch functions \n"\
" */ \n"\
"float3 Bxdf_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 Bxdf_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at w \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kPassthrough: \n"\
"        return Passthrough_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Bxdf_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kPassthrough: \n"\
"        return 0.f; \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Emissive BRDF sampling \n"\
"float3 Emissive_GetLe( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    return kd; \n"\
"} \n"\
" \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsSingular(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealReflect || dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough; \n"\
"} \n"\
" \n"\
"/// BxDF emission check \n"\
"bool Bxdf_IsEmissive(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kEmissive; \n"\
"} \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsBtdf(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough || dg->mat.type == kTranslucent || \n"\
"        dg->mat.type == kMicrofacetRefractionGGX || dg->mat.type == kMicrofacetRefractionBeckmann; \n"\
"} \n"\
" \n"\
"#endif // BXDF_CL \n"\
" \n"\
"void Material_Select( \n"\
"    // Scene data \n"\
"    Scene const* scene, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
" \n"\
"#ifdef SOBOL \n"\
"    // Sampler state \n"\
"    __global SobolSampler* sampler, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Current bounce \n"\
"    int bounce, \n"\
"#else \n"\
"    Rng* rng, \n"\
"#endif \n"\
" \n"\
"    // Geometry \n"\
"    DifferentialGeometry* dg \n"\
") \n"\
"{ \n"\
"    // Check material type \n"\
"    int type = dg->mat.type; \n"\
" \n"\
"    // If material is regular BxDF we do not have to sample it \n"\
"    if (type != kFresnelBlend && type != kMix) \n"\
"    { \n"\
"        // If fresnel > 0 here we need to calculate Frensle factor (remove this workaround) \n"\
"        if (dg->mat.fresnel > 0.f) \n"\
"        { \n"\
"            float etai = 1.f; \n"\
"            float etat = dg->mat.ni; \n"\
"            float cosi = dot(dg->n, wi); \n"\
" \n"\
"            // Revert normal and eta if needed \n"\
"            if (cosi < 0.f) \n"\
"            { \n"\
"                float tmp = etai; \n"\
"                etai = etat; \n"\
"                etat = tmp; \n"\
"                cosi = -cosi; \n"\
"            } \n"\
" \n"\
"            float eta = etai / etat; \n"\
"            float sini2 = 1.f - cosi * cosi; \n"\
"            float sint2 = eta * eta * sini2; \n"\
" \n"\
"            float fresnel = 1.f; \n"\
" \n"\
"            if (sint2 < 1.f) \n"\
"            { \n"\
"                float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
"                fresnel = FresnelDielectric(etai, etat, cosi, cost); \n"\
"            } \n"\
" \n"\
"            dg->mat.fresnel = Bxdf_IsBtdf(dg) ? (1.f - fresnel) : fresnel; \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            // Otherwise set multiplier to 1 \n"\
"            dg->mat.fresnel = 1.f; \n"\
"        } \n"\
"    } \n"\
"    // Here we deal with combined material and we have to sample \n"\
"    else \n"\
"    { \n"\
"        // Prefetch current material \n"\
"        Material mat = dg->mat; \n"\
"        int iter = 0; \n"\
" \n"\
"        // Might need several passes of sampling \n"\
"        while (mat.type == kFresnelBlend || mat.type == kMix) \n"\
"        { \n"\
"            if (mat.type == kFresnelBlend) \n"\
"            { \n"\
"                float etai = 1.f; \n"\
"                float etat = mat.ni; \n"\
"                float cosi = dot(dg->n, wi); \n"\
" \n"\
"                // Revert normal and eta if needed \n"\
"                if (cosi < 0.f) \n"\
"                { \n"\
"                    float tmp = etai; \n"\
"                    etai = etat; \n"\
"                    etat = tmp; \n"\
"                    cosi = -cosi; \n"\
"                } \n"\
" \n"\
"                float eta = etai / etat; \n"\
"                float sini2 = 1.f - cosi * cosi; \n"\
"                float sint2 = eta * eta * sini2; \n"\
" \n"\
"                int idx = 0; \n"\
" \n"\
"                float fresnel = 1.f; \n"\
" \n"\
"                if (sint2 < 1.f) \n"\
"                { \n"\
"                    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
"                    fresnel = FresnelDielectric(etai, etat, cosi, cost); \n"\
"                } \n"\
" \n"\
"#ifdef SOBOL \n"\
"                float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kMaterial + iter), sampler->s0, sobolmat); \n"\
"#else \n"\
"                float sample = UniformSampler_Sample2D(rng).x; \n"\
"#endif \n"\
" \n"\
"                if (sample < fresnel) \n"\
"                { \n"\
"                    // Sample top \n"\
"                    idx = mat.brdftopidx; \n"\
"                    //  \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"                else \n"\
"                { \n"\
"                    // Sample base \n"\
"                    idx = mat.brdfbaseidx; \n"\
"                    //  \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"            } \n"\
"            else \n"\
"            { \n"\
" \n"\
"#ifdef SOBOL \n"\
"                float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kMaterial + iter), sampler->s0, sobolmat); \n"\
"#else \n"\
"                float sample = UniformSampler_Sample2D(rng).x; \n"\
"#endif \n"\
"                float weight = Texture_GetValue1f(mat.ns, dg->uv, TEXTURE_ARGS_IDX(mat.nsmapidx)); \n"\
" \n"\
"                if (sample < weight) \n"\
"                { \n"\
"                    // Sample top \n"\
"                    int idx = mat.brdftopidx; \n"\
"                    // \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"                else \n"\
"                { \n"\
"                    // Sample base \n"\
"                    int idx = mat.brdfbaseidx; \n"\
"                    // \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"            } \n"\
"        } \n"\
" \n"\
"        dg->mat = mat; \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"#endif // MATERIAL_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef VOLUMETRICS_CL \n"\
"#define VOLUMETRICS_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
" \n"\
"#define FAKE_SHAPE_SENTINEL 0xFFFFFF \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kEmpty, \n"\
"    kHomogeneous, \n"\
"    kHeterogeneous \n"\
"} VolumeType; \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kUniform, \n"\
"    kRayleigh, \n"\
"    kMieMurky, \n"\
"    kMieHazy, \n"\
"    kHG // this one requires one extra coeff \n"\
"} PhaseFunction; \n"\
" \n"\
"typedef struct _Volume \n"\
"{ \n"\
"    VolumeType type; \n"\
"    PhaseFunction phase_func; \n"\
"     \n"\
"    // Id of volume data if present  \n"\
"    int data; \n"\
"    int extra; \n"\
" \n"\
"    // Absorbtion \n"\
"    float3 sigma_a; \n"\
"    // Scattering \n"\
"    float3 sigma_s; \n"\
"    // Emission \n"\
"    float3 sigma_e; \n"\
"} Volume; \n"\
" \n"\
" \n"\
"// The following functions are taken from PBRT \n"\
"float PhaseFunction_Uniform(float3 wi, float3 wo) \n"\
"{ \n"\
"    return 1.f / (4.f * PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_Rayleigh(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return  3.f / (16.f*PI) * (1 + costheta * costheta); \n"\
"} \n"\
" \n"\
"float PhaseFunction_MieHazy(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return (0.5f + 4.5f * native_powr(0.5f * (1.f + costheta), 8.f)) / (4.f*PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_MieMurky(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return (0.5f + 16.5f * native_powr(0.5f * (1.f + costheta), 32.f)) / (4.f*PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_HG(float3 wi, float3 wo, float g) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return 1.f / (4.f * PI) * \n"\
"        (1.f - g*g) / native_powr(1.f + g*g - 2.f * g * costheta, 1.5f); \n"\
"} \n"\
" \n"\
" \n"\
"// Evaluate volume transmittance along the ray [0, dist] segment \n"\
"float3 Volume_Transmittance(__global Volume const* volume, __global ray const* ray, float dist) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // For homogeneous it is e(-sigma * dist) \n"\
"            float3 sigma_t = volume->sigma_a + volume->sigma_s; \n"\
"            return native_exp(-sigma_t * dist); \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return 1.f; \n"\
"} \n"\
" \n"\
"// Evaluate volume selfemission along the ray [0, dist] segment \n"\
"float3 Volume_Emission(__global Volume const* volume, __global ray const* ray, float dist) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // For homogeneous it is simply Tr * Ev (since sigma_e is constant) \n"\
"            return Volume_Transmittance(volume, ray, dist) * volume->sigma_e; \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"// Sample volume in order to find next scattering event \n"\
"float Volume_SampleDistance(__global Volume const* volume, __global ray const* ray, float maxdist, float sample, float* pdf) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // The PDF = sigma * e(-sigma * x), so the larger sigma the closer we scatter \n"\
"            float sigma = (volume->sigma_s.x + volume->sigma_s.y + volume->sigma_s.z) / 3; \n"\
"            float d = sigma > 0.f ? (-native_log(sample) / sigma) : -1.f; \n"\
"            *pdf = sigma > 0.f ? (sigma * native_exp(-sigma * d)) : 0.f; \n"\
"            return d; \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return -1.f; \n"\
"} \n"\
" \n"\
"// Apply volume effects (absorbtion and emission) and scatter if needed. \n"\
"// The rays we handling here might intersect something or miss,  \n"\
"// since scattering can happen even for missed rays. \n"\
"// That's why this function is called prior to ray compaction. \n"\
"// In case ray has missed geometry (has shapeid < 0) and has been scattered, \n"\
"// we put FAKE_SHAPE_SENTINEL into shapeid to prevent ray from being compacted away. \n"\
"// \n"\
"__kernel void EvaluateVolume( \n"\
"    // Ray batch \n"\
"    __global ray const* rays, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int const* numrays, \n"\
"    // Volumes \n"\
"    __global Volume const* volumes, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG seed \n"\
"    int rngseed, \n"\
"    // Sampler state \n"\
"    __global SobolSampler* samplers, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Current bounce  \n"\
"    int bounce, \n"\
"    // Intersection data \n"\
"    __global Intersection* isects, \n"\
"    // Current paths \n"\
"    __global Path* paths, \n"\
"    // Output \n"\
"    __global float3* output \n"\
"    ) \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
"     \n"\
"    // Only handle active rays \n"\
"    if (globalid < *numrays) \n"\
"    { \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
"         \n"\
"        __global Path* path = paths + pixelidx; \n"\
" \n"\
"        // Path can be dead here since compaction step has not  \n"\
"        // yet been applied \n"\
"        if (!Path_IsAlive(path)) \n"\
"            return; \n"\
" \n"\
"        int volidx = Path_GetVolumeIdx(path); \n"\
" \n"\
"        // Check if we are inside some volume \n"\
"        if (volidx != -1) \n"\
"        { \n"\
"#ifdef SOBOL \n"\
"            __global SobolSampler* sampler = samplers + pixelidx; \n"\
"            float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kVolume), sampler->s0, sobolmat); \n"\
"#else \n"\
"            Rng rng; \n"\
"            InitRng(rngseed + (globalid << 2) * 157 + 13, &rng); \n"\
"            float sample = UniformSampler_Sample2D(&rng).x; \n"\
"#endif \n"\
"            // Try sampling volume for a next scattering event \n"\
"            float pdf = 0.f; \n"\
"            float maxdist = Intersection_GetDistance(isects + globalid); \n"\
"            float d = Volume_SampleDistance(&volumes[volidx], &rays[globalid], maxdist, sample, &pdf); \n"\
"             \n"\
"            // Check if we shall skip the event (it is either outside of a volume or not happened at all) \n"\
"            bool skip = d < 0 || d > maxdist || pdf <= 0.f; \n"\
" \n"\
"            if (skip) \n"\
"            { \n"\
"                // In case we skip we just need to apply volume absorbtion and emission for the segment we went through \n"\
"                // and clear scatter flag \n"\
"                Path_ClearScatterFlag(path); \n"\
"                // Emission contribution accounting for a throughput we have so far \n"\
"                Path_AddContribution(path, output, pixelidx, Volume_Emission(&volumes[volidx], &rays[globalid], maxdist)); \n"\
"                // And finally update the throughput \n"\
"                Path_MulThroughput(path, Volume_Transmittance(&volumes[volidx], &rays[globalid], maxdist)); \n"\
"            } \n"\
"            else \n"\
"            { \n"\
"                // Set scattering flag to notify ShadeVolume kernel to handle this path \n"\
"                Path_SetScatterFlag(path); \n"\
"                // Emission contribution accounting for a throughput we have so far \n"\
"                Path_AddContribution(path, output, pixelidx, Volume_Emission(&volumes[volidx], &rays[globalid], d) / pdf); \n"\
"                // Update the throughput \n"\
"                Path_MulThroughput(path, (Volume_Transmittance(&volumes[volidx], &rays[globalid], d) / pdf)); \n"\
"                // Put fake shape to prevent from being compacted away \n"\
"                isects[globalid].shapeid = FAKE_SHAPE_SENTINEL; \n"\
"                // And keep scattering distance around as well \n"\
"                isects[globalid].uvwt.w = d; \n"\
"            } \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"#endif // VOLUMETRICS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
" \n"\
"#define CRAZY_LOW_THROUGHPUT 0.0f \n"\
"#define CRAZY_HIGH_RADIANCE 3.f \n"\
"#define CRAZY_HIGH_DISTANCE 1000000.f \n"\
"#define CRAZY_LOW_DISTANCE 0.001f \n"\
"#define REASONABLE_RADIANCE(x) (clamp((x), 0.f, CRAZY_HIGH_RADIANCE)) \n"\
"#define NON_BLACK(x) (length(x) > 0.f) \n"\
" \n"\
"// This kernel only handles scattered paths. \n"\
"// It applies direct illumination and generates \n"\
"// path continuation if multiscattering is enabled. \n"\
"__kernel void ShadeVolume( \n"\
"    // Ray batch \n"\
"    __global ray const* rays, \n"\
"    // Intersection data \n"\
"    __global Intersection const* isects, \n"\
"    // Hit indices \n"\
"    __global int const* hitindices, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int const* numhits, \n"\
"    // Vertices \n"\
"    __global float3 const* vertices, \n"\
"    // Normals \n"\
"    __global float3 const* normals, \n"\
"    // UVs \n"\
"    __global float2 const* uvs, \n"\
"    // Indices \n"\
"    __global int const* indices, \n"\
"    // Shapes \n"\
"    __global Shape const* shapes, \n"\
"    // Material IDs \n"\
"    __global int const* materialids, \n"\
"    // Materials \n"\
"    __global Material const* materials, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Environment texture index \n"\
"    int envmapidx, \n"\
"    // Envmap multiplier \n"\
"    float envmapmul, \n"\
"    // Emissives \n"\
"    __global Light const* lights, \n"\
"    // Number of emissive objects \n"\
"    int num_lights, \n"\
"    // RNG seed \n"\
"    int rngseed, \n"\
"    // Sampler state \n"\
"    __global SobolSampler* samplers, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Current bounce \n"\
"    int bounce, \n"\
"    // Volume data \n"\
"    __global Volume const* volumes, \n"\
"    // Shadow rays \n"\
"    __global ray* shadowrays, \n"\
"    // Light samples \n"\
"    __global float3* lightsamples, \n"\
"    // Path throughput \n"\
"    __global Path* paths, \n"\
"    // Indirect rays (next path segment) \n"\
"    __global ray* indirectrays, \n"\
"    // Radiance \n"\
"    __global float3* output \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    Scene scene = \n"\
"    { \n"\
"        vertices, \n"\
"        normals, \n"\
"        uvs, \n"\
"        indices, \n"\
"        shapes, \n"\
"        materialids, \n"\
"        materials, \n"\
"        lights, \n"\
"        envmapidx, \n"\
"        envmapmul, \n"\
"        num_lights \n"\
"    }; \n"\
" \n"\
"    if (globalid < *numhits) \n"\
"    { \n"\
"        // Fetch index \n"\
"        int hitidx = hitindices[globalid]; \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
"        Intersection isect = isects[hitidx]; \n"\
" \n"\
"        __global Path* path = paths + pixelidx; \n"\
" \n"\
"        // Only apply to scattered paths \n"\
"        if (!Path_IsScattered(path)) \n"\
"        { \n"\
"            return; \n"\
"        } \n"\
" \n"\
"        // Fetch incoming ray \n"\
"        float3 o = rays[hitidx].o.xyz; \n"\
"        float3 wi = rays[hitidx].d.xyz; \n"\
" \n"\
"#ifdef SOBOL \n"\
"        __global SobolSampler* sampler = samplers + pixelidx; \n"\
"        float sample0 = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kVolumeLight), sampler->s0, sobolmat); \n"\
"        float2 sample1; \n"\
"        sample1.x = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kVolumeLightU), sampler->s0, sobolmat); \n"\
"        sample1.y = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kVolumeLightV), sampler->s0, sobolmat); \n"\
"#ifdef MULTISCATTER \n"\
"        float2 sample2; \n"\
"        sample2.x = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kVolumeIndirectU), sampler->s0, sobolmat); \n"\
"        sample2.y = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kVolumeIndirectV), sampler->s0, sobolmat); \n"\
"#endif \n"\
"#else \n"\
"        // Prepare RNG for sampling \n"\
"        Rng rng; \n"\
"        InitRng(rngseed + (globalid << 2) * 157 + 13, &rng); \n"\
"        float sample0 = UniformSampler_Sample2D(&rng).x; \n"\
"        float2 sample1 = UniformSampler_Sample2D(&rng); \n"\
"#ifdef MULTISCATTER \n"\
"        float2 sample2 = UniformSampler_Sample2D(&rng); \n"\
"#endif \n"\
"#endif \n"\
"        // Here we know that volidx != -1 since this is a precondition \n"\
"        // for scattering event \n"\
"        int volidx = Path_GetVolumeIdx(path); \n"\
" \n"\
"        // Sample light source \n"\
"        float pdf = 0.f; \n"\
"        float selection_pdf = 0.f; \n"\
"        float3 wo; \n"\
" \n"\
"        int light_idx = Scene_SampleLight(&scene, sample0, &selection_pdf); \n"\
" \n"\
"        // Here we need fake differential geometry for light sampling procedure \n"\
"        DifferentialGeometry dg; \n"\
"        // put scattering position in there (it is along the current ray at isect.distance \n"\
"        // since EvaluateVolume has put it there \n"\
"        dg.p = o + wi * Intersection_GetDistance(isects + hitidx); \n"\
"        // Get light sample intencity \n"\
"        float3 le = Light_Sample(light_idx, &scene, &dg, TEXTURE_ARGS, sample1, &wo, &pdf); \n"\
" \n"\
"        // Generate shadow ray \n"\
"        float shadow_ray_length = 0.999f * length(wo); \n"\
"        Ray_Init(shadowrays + globalid, dg.p, normalize(wo), shadow_ray_length, 0.f, 0xFFFFFFFF); \n"\
" \n"\
"        // Evaluate volume transmittion along the shadow ray (it is incorrect if the light source is outside of the \n"\
"        // current volume, but in this case it will be discarded anyway since the intersection at the outer bound \n"\
"        // of a current volume), so the result is fully correct. \n"\
"        float3 tr = Volume_Transmittance(&volumes[volidx], &shadowrays[globalid], shadow_ray_length); \n"\
" \n"\
"        // Volume emission is applied only if the light source is in the current volume(this is incorrect since the light source might be \n"\
"        // outside of a volume and we have to compute fraction of ray in this case, but need to figure out how) \n"\
"        float3 r = Volume_Emission(&volumes[volidx], &shadowrays[globalid], shadow_ray_length); \n"\
" \n"\
"        // This is the estimate coming from a light source \n"\
"        // TODO: remove hardcoded phase func and sigma \n"\
"        r += tr * le * volumes[volidx].sigma_s * PhaseFunction_Uniform(wi, normalize(wo)) / pdf / selection_pdf; \n"\
" \n"\
"        // Only if we have some radiance compute the visibility ray \n"\
"        if (NON_BLACK(tr) && NON_BLACK(r) && pdf > 0.f) \n"\
"        { \n"\
"            // Put lightsample result \n"\
"            lightsamples[globalid] = REASONABLE_RADIANCE(r * Path_GetThroughput(path)); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            // Nothing to compute \n"\
"            lightsamples[globalid] = 0.f; \n"\
"            // Otherwise make it incative to save intersector cycles (hopefully) \n"\
"            Ray_SetInactive(shadowrays + globalid); \n"\
"        } \n"\
" \n"\
"#ifdef MULTISCATTER \n"\
"        // This is highly brute-force \n"\
"        // TODO: investigate importance sampling techniques here \n"\
"        wo = Sample_MapToSphere(sample2); \n"\
"        pdf = 1.f / (4.f * PI); \n"\
" \n"\
"        // Generate new path segment \n"\
"        Ray_Init(indirectrays + globalid, dg.p, normalize(wo), CRAZY_HIGH_DISTANCE, 0.f, 0xFFFFFFFF); \n"\
" \n"\
"        // Update path throughput multiplying by phase function. \n"\
"        Path_MulThroughput(path, volumes[volidx].sigma_s * PhaseFunction_Uniform(wi, normalize(wo)) / pdf); \n"\
"#else \n"\
"        // Single-scattering mode only, \n"\
"        // kill the path and compact away on next iteration \n"\
"        Path_Kill(path); \n"\
"        Ray_SetInactive(indirectrays + globalid); \n"\
"#endif \n"\
"    } \n"\
"} \n"\
" \n"\
"// Handle ray-surface interaction possibly generating path continuation. \n"\
"// This is only applied to non-scattered paths. \n"\
"__kernel void ShadeSurface( \n"\
"    // Ray batch \n"\
"    __global ray const* rays, \n"\
"    // Intersection data \n"\
"    __global Intersection const* isects, \n"\
"    // Hit indices \n"\
"    __global int const* hitindices, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int const* numhits, \n"\
"    // Vertices \n"\
"    __global float3 const* vertices, \n"\
"    // Normals \n"\
"    __global float3 const* normals, \n"\
"    // UVs \n"\
"    __global float2 const* uvs, \n"\
"    // Indices \n"\
"    __global int const* indices, \n"\
"    // Shapes \n"\
"    __global Shape const* shapes, \n"\
"    // Material IDs \n"\
"    __global int const* materialids, \n"\
"    // Materials \n"\
"    __global Material const* materials, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Environment texture index \n"\
"    int envmapidx, \n"\
"    // Envmap multiplier \n"\
"    float envmapmul, \n"\
"    // Emissives \n"\
"    __global Light const* lights, \n"\
"    // Number of emissive objects \n"\
"    int num_lights, \n"\
"    // RNG seed \n"\
"    int rngseed, \n"\
"    // Sampler states \n"\
"    __global SobolSampler* samplers, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Current bounce \n"\
"    int bounce, \n"\
"    // Volume data \n"\
"    __global Volume const* volumes, \n"\
"    // Shadow rays \n"\
"    __global ray* shadowrays, \n"\
"    // Light samples \n"\
"    __global float3* lightsamples, \n"\
"    // Path throughput \n"\
"    __global Path* paths, \n"\
"    // Indirect rays \n"\
"    __global ray* indirectrays, \n"\
"    // Radiance \n"\
"    __global float3* output, \n"\
"    // Output Normals \n"\
"    __global float4* output_normals \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    Scene scene = \n"\
"    { \n"\
"        vertices, \n"\
"        normals, \n"\
"        uvs, \n"\
"        indices, \n"\
"        shapes, \n"\
"        materialids, \n"\
"        materials, \n"\
"        lights, \n"\
"        envmapidx, \n"\
"        envmapmul, \n"\
"        num_lights \n"\
"    }; \n"\
" \n"\
"    // Only applied to active rays after compaction \n"\
"    if (globalid < *numhits) \n"\
"    { \n"\
"        // Fetch index \n"\
"        int hitidx = hitindices[globalid]; \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
"        Intersection isect = isects[hitidx]; \n"\
" \n"\
"        __global Path* path = paths + pixelidx; \n"\
" \n"\
"        // Early exit for scattered paths \n"\
"        if (Path_IsScattered(path)) \n"\
"        { \n"\
"            return; \n"\
"        } \n"\
" \n"\
"        // Fetch incoming ray direction \n"\
"        float3 wi = -normalize(rays[hitidx].d.xyz); \n"\
"#ifdef SOBOL \n"\
"        // Sample light \n"\
"        __global SobolSampler* sampler = samplers + pixelidx; \n"\
" \n"\
"        float2 sample0; \n"\
"        sample0.x = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kBrdf), sampler->s0, sobolmat); \n"\
"        sample0.y = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kLight), sampler->s0, sobolmat); \n"\
" \n"\
"        float2 sample1; \n"\
"        sample1.x = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kLightU), sampler->s0, sobolmat); \n"\
"        sample1.y = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kLightV), sampler->s0, sobolmat); \n"\
" \n"\
"        float2 sample2; \n"\
"        sample2.x = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kBrdfU), sampler->s0, sobolmat); \n"\
"        sample2.y = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kBrdfV), sampler->s0, sobolmat); \n"\
" \n"\
"        float2 sample3; \n"\
"        sample3.x = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kIndirectU), sampler->s0, sobolmat); \n"\
"        sample3.y = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kIndirectV), sampler->s0, sobolmat); \n"\
" \n"\
"        float sample4 = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kRR), sampler->s0, sobolmat); \n"\
"#else \n"\
"        // Prepare RNG \n"\
"        Rng rng; \n"\
"        InitRng(rngseed + (globalid << 2) * 157 + 13, &rng); \n"\
"        float2 sample0 = UniformSampler_Sample2D(&rng); \n"\
"        float2 sample1 = UniformSampler_Sample2D(&rng); \n"\
"        float2 sample2 = UniformSampler_Sample2D(&rng); \n"\
"        float2 sample3 = UniformSampler_Sample2D(&rng); \n"\
"        float  sample4 = UniformSampler_Sample2D(&rng).x; \n"\
"#endif \n"\
" \n"\
"        // Fill surface data \n"\
"        DifferentialGeometry diffgeo; \n"\
"        FillDifferentialGeometry(&scene, &isect, &diffgeo); \n"\
" \n"\
"		if (bounce == 0) { output_normals[globalid] += (float4)(diffgeo.n.x, diffgeo.n.y, diffgeo.n.z, 0.0f); } \n"\
" \n"\
"        // Check if we are hitting from the inside \n"\
"        float ndotwi = dot(diffgeo.n, wi); \n"\
"        int twosided = diffgeo.mat.twosided; \n"\
"        if (twosided && ndotwi < 0.f) \n"\
"        { \n"\
"            // Reverse normal and tangents in this case \n"\
"            // but not for BTDFs, since BTDFs rely \n"\
"            // on normal direction in order to arrange \n"\
"            // indices of refraction \n"\
"            diffgeo.n = -diffgeo.n; \n"\
"            diffgeo.dpdu = -diffgeo.dpdu; \n"\
"            diffgeo.dpdv = -diffgeo.dpdv; \n"\
"        } \n"\
" \n"\
"        // Select BxDF \n"\
"        Material_Select( \n"\
"            &scene, wi, TEXTURE_ARGS, \n"\
"#ifdef SOBOL \n"\
"            sampler, sobolmat, bounce, \n"\
"#else \n"\
"            &rng, \n"\
"#endif \n"\
"            &diffgeo \n"\
"        ); \n"\
" \n"\
"        ndotwi = dot(diffgeo.n, wi); \n"\
" \n"\
"        // Terminate if emissive \n"\
"        if (Bxdf_IsEmissive(&diffgeo)) \n"\
"        { \n"\
"            if (ndotwi > 0.f) \n"\
"            { \n"\
"                float weight = 1.f; \n"\
" \n"\
"                if (bounce > 0 && !Path_IsSpecular(path)) \n"\
"                { \n"\
"                    float2 extra = Ray_GetExtra(&rays[hitidx]); \n"\
"                    float ld = isect.uvwt.w; \n"\
"                    float denom = extra.y * diffgeo.area; \n"\
"                    // TODO: num_lights should be num_emissies instead, presence of analytical lights breaks this code \n"\
"                    float bxdflightpdf = denom > 0.f ? (ld * ld / denom / num_lights) : 0.f; \n"\
"                    weight = BalanceHeuristic(1, extra.x, 1, bxdflightpdf); \n"\
"                } \n"\
"                 \n"\
"                { \n"\
"                    // In this case we hit after an application of MIS process at previous step. \n"\
"                    // That means BRDF weight has been already applied. \n"\
"                    output[pixelidx] += Path_GetThroughput(path) * Emissive_GetLe(&diffgeo, TEXTURE_ARGS) * weight; \n"\
"                } \n"\
"            } \n"\
" \n"\
"            Path_Kill(path); \n"\
"            Ray_SetInactive(shadowrays + globalid); \n"\
"            Ray_SetInactive(indirectrays + globalid); \n"\
" \n"\
"            lightsamples[globalid] = 0.f; \n"\
"            return; \n"\
"        } \n"\
" \n"\
" \n"\
"        float s = Bxdf_IsBtdf(&diffgeo) ? (-sign(ndotwi)) : 1.f; \n"\
"        if (!twosided && ndotwi < 0.f && !Bxdf_IsBtdf(&diffgeo)) \n"\
"        { \n"\
"            // Reverse normal and tangents in this case \n"\
"            // but not for BTDFs, since BTDFs rely \n"\
"            // on normal direction in order to arrange \n"\
"            // indices of refraction \n"\
"            diffgeo.n = -diffgeo.n; \n"\
"            diffgeo.dpdu = -diffgeo.dpdu; \n"\
"            diffgeo.dpdv = -diffgeo.dpdv; \n"\
"        } \n"\
" \n"\
"        // TODO: this is test code, need to \n"\
"        // maintain proper volume stack here \n"\
"        //if (Bxdf_IsBtdf(&diffgeo)) \n"\
"        //{ \n"\
"            // If we entering set the volume \n"\
"            //path->volume = ndotwi > 0.f ? 0 : -1; \n"\
"        //} \n"\
" \n"\
"        // Check if we need to apply normal map \n"\
"        //ApplyNormalMap(&diffgeo, TEXTURE_ARGS); \n"\
"        ApplyBumpMap(&diffgeo, TEXTURE_ARGS); \n"\
"        float lightpdf = 0.f; \n"\
"        float bxdflightpdf = 0.f; \n"\
"        float bxdfpdf = 0.f; \n"\
"        float lightbxdfpdf = 0.f; \n"\
"        float selection_pdf = 0.f; \n"\
"        float3 radiance = 0.f; \n"\
"        float3 lightwo; \n"\
"        float3 bxdfwo; \n"\
"        float3 wo; \n"\
"        float bxdfweight = 1.f; \n"\
"        float lightweight = 1.f; \n"\
" \n"\
"        int light_idx = num_lights > 0 ? Scene_SampleLight(&scene, sample0.y, &selection_pdf) : -1; \n"\
" \n"\
"        float3 throughput = Path_GetThroughput(path); \n"\
" \n"\
"        // Sample bxdf \n"\
"        float3 bxdf = Bxdf_Sample(&diffgeo, wi, TEXTURE_ARGS, sample2, &bxdfwo, &bxdfpdf); \n"\
" \n"\
"        // If we have light to sample we can hopefully do mis \n"\
"        if (light_idx > -1) \n"\
"        { \n"\
"            // Sample light \n"\
"            float3 le = Light_Sample(light_idx, &scene, &diffgeo, TEXTURE_ARGS, sample1, &lightwo, &lightpdf); \n"\
"            lightbxdfpdf = Bxdf_GetPdf(&diffgeo, wi, normalize(lightwo), TEXTURE_ARGS); \n"\
"            lightweight = Light_IsSingular(&scene.lights[light_idx]) ? 1.f : BalanceHeuristic(1, lightpdf, 1, lightbxdfpdf); \n"\
" \n"\
" \n"\
"            // Apply MIS to account for both \n"\
"            if (NON_BLACK(le) && lightpdf > 0.0f && !Bxdf_IsSingular(&diffgeo)) \n"\
"            { \n"\
"                wo = lightwo; \n"\
"                float ndotwo = fabs(dot(diffgeo.n, normalize(wo))); \n"\
"                radiance = le * Bxdf_Evaluate(&diffgeo, wi, normalize(wo), TEXTURE_ARGS) * throughput * \n"\
"                    ndotwo * lightweight / lightpdf / selection_pdf; \n"\
"            } \n"\
"        } \n"\
" \n"\
"        // If we have some light here generate a shadow ray \n"\
"        if (NON_BLACK(radiance)) \n"\
"        { \n"\
"            // Generate shadow ray \n"\
"            float shadow_ray_length = (1.f - 2.f * CRAZY_LOW_DISTANCE) * length(wo); \n"\
"            float3 shadow_ray_dir = normalize(wo); \n"\
"            float3 shadow_ray_o = diffgeo.p + CRAZY_LOW_DISTANCE * s * diffgeo.n; \n"\
"            int shadow_ray_mask = Bxdf_IsSingular(&diffgeo) ? 0xFFFFFFFF : 0x0000FFFF; \n"\
" \n"\
"            Ray_Init(shadowrays + globalid, shadow_ray_o, shadow_ray_dir, shadow_ray_length, 0.f, shadow_ray_mask); \n"\
" \n"\
"            // Apply the volume to shadow ray if needed \n"\
"            int volidx = Path_GetVolumeIdx(path); \n"\
"            if (volidx != -1) \n"\
"            { \n"\
"                radiance *= Volume_Transmittance(&volumes[volidx], &shadowrays[globalid], shadow_ray_length); \n"\
"                radiance += Volume_Emission(&volumes[volidx], &shadowrays[globalid], shadow_ray_length) * throughput; \n"\
"            } \n"\
" \n"\
"            // And write the light sample \n"\
"            lightsamples[globalid] = REASONABLE_RADIANCE(radiance); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            // Otherwise save some intersector cycles \n"\
"            Ray_SetInactive(shadowrays + globalid); \n"\
"            lightsamples[globalid] = 0; \n"\
"        } \n"\
" \n"\
"        // Apply Russian roulette \n"\
"        float q = max(min(0.5f, \n"\
"            // Luminance \n"\
"            0.2126f * throughput.x + 0.7152f * throughput.y + 0.0722f * throughput.z), 0.01f); \n"\
"        // Only if it is 3+ bounce \n"\
"        bool rr_apply = bounce > 3; \n"\
"        bool rr_stop = sample4 > q && rr_apply; \n"\
" \n"\
"        if (rr_apply) \n"\
"        { \n"\
"            Path_MulThroughput(path, 1.f / q); \n"\
"        } \n"\
" \n"\
"        if (Bxdf_IsSingular(&diffgeo)) \n"\
"        { \n"\
"            Path_SetSpecularFlag(path); \n"\
"        } \n"\
" \n"\
"        bxdfwo = normalize(bxdfwo); \n"\
"        float3 t = bxdf * fabs(dot(diffgeo.n, bxdfwo)); \n"\
" \n"\
"        // Only continue if we have non-zero throughput & pdf \n"\
"        if (NON_BLACK(t) && bxdfpdf > 0.f && !rr_stop) \n"\
"        { \n"\
"            // Update the throughput \n"\
"            Path_MulThroughput(path, t / bxdfpdf); \n"\
" \n"\
"            // Generate ray \n"\
"            float3 indirect_ray_dir = bxdfwo; \n"\
"            float3 indirect_ray_o = diffgeo.p + CRAZY_LOW_DISTANCE * s * diffgeo.n; \n"\
" \n"\
"            Ray_Init(indirectrays + globalid, indirect_ray_o, indirect_ray_dir, CRAZY_HIGH_DISTANCE, 0.f, 0xFFFFFFFF); \n"\
"            Ray_SetExtra(indirectrays + globalid, make_float2(bxdfpdf, fabs(dot(diffgeo.n, bxdfwo)))); \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            // Otherwise kill the path \n"\
"            Path_Kill(path); \n"\
"            Ray_SetInactive(indirectrays + globalid); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"///< Illuminate missing rays \n"\
"__kernel void ShadeMiss( \n"\
"    // Ray batch \n"\
"    __global ray const* rays, \n"\
"    // Intersection data \n"\
"    __global Intersection const* isects, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    int numrays, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Environment texture index \n"\
"    int envmapidx, \n"\
"    // \n"\
"    __global Path const* paths, \n"\
"    __global Volume const* volumes, \n"\
"    // Output values \n"\
"    __global float4* output \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    if (globalid < numrays) \n"\
"    { \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
" \n"\
"        // In case of a miss \n"\
"        if (isects[globalid].shapeid < 0) \n"\
"        { \n"\
"            // Multiply by throughput \n"\
"            int volidx = paths[pixelidx].volume; \n"\
" \n"\
"            if (volidx == -1) \n"\
"                output[pixelidx].xyz += Texture_SampleEnvMap(rays[globalid].d.xyz, TEXTURE_ARGS_IDX(envmapidx)); \n"\
"            else \n"\
"            { \n"\
"                output[pixelidx].xyz += Texture_SampleEnvMap(rays[globalid].d.xyz, TEXTURE_ARGS_IDX(envmapidx)) * \n"\
"                    Volume_Transmittance(&volumes[volidx], &rays[globalid], rays[globalid].o.w); \n"\
" \n"\
"                output[pixelidx].xyz += Volume_Emission(&volumes[volidx], &rays[globalid], rays[globalid].o.w); \n"\
"            } \n"\
"        } \n"\
" \n"\
"        if (isnan(output[pixelidx].x) || isnan(output[pixelidx].y) || isnan(output[pixelidx].z)) \n"\
"        { \n"\
"            output[pixelidx] = make_float4(100.f, 0.f, 0.f, 1.f); \n"\
"        } \n"\
" \n"\
"        output[pixelidx].w += 1.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"///< Handle light samples and visibility info and add contribution to final buffer \n"\
"__kernel void GatherLightSamples( \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int* numrays, \n"\
"    // Shadow rays hits \n"\
"    __global int const* shadowhits, \n"\
"    // Light samples \n"\
"    __global float3 const* lightsamples, \n"\
"    // throughput \n"\
"    __global Path const* paths, \n"\
"    // Radiance sample buffer \n"\
"    __global float4* output \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    if (globalid < *numrays) \n"\
"    { \n"\
"        // Get pixel id for this sample set \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
" \n"\
" \n"\
"        // Prepare accumulator variable \n"\
"        float3 radiance = make_float3(0.f, 0.f, 0.f); \n"\
" \n"\
"        // Start collecting samples \n"\
"        { \n"\
"            // If shadow ray didn't hit anything and reached skydome \n"\
"            if (shadowhits[globalid] == -1) \n"\
"            { \n"\
"                // Add its contribution to radiance accumulator \n"\
"                radiance += lightsamples[globalid]; \n"\
"            } \n"\
"        } \n"\
" \n"\
"        // Divide by number of light samples (samples already have built-in throughput) \n"\
"        output[pixelidx].xyz += radiance; \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"///< Handle light samples and visibility info and add contribution to final buffer \n"\
"__kernel void GatherOcclusion( \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int const* numrays, \n"\
"    // Shadow rays hits \n"\
"    __global int const* shadowhits, \n"\
"    // Light samples \n"\
"    __global float3 const* lightsamples, \n"\
"    // throughput \n"\
"    __global float3 const* throughput, \n"\
"    // Radiance sample buffer \n"\
"    __global float4* output \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    if (globalid < *numrays) \n"\
"    { \n"\
"        // Get pixel id for this sample set \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
" \n"\
"        float visibility = (shadowhits[globalid] == 1) ? 0.f : 1.f; \n"\
" \n"\
"        output[pixelidx].xyz += visibility; \n"\
"        output[pixelidx].w += 1.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"///< Restore pixel indices after compaction \n"\
"__kernel void RestorePixelIndices( \n"\
"    // Compacted indices \n"\
"    __global int const* compacted_indices, \n"\
"    // Number of compacted indices \n"\
"    __global int* numitems, \n"\
"    // Previous pixel indices \n"\
"    __global int const* previndices, \n"\
"    // New pixel indices \n"\
"    __global int* newindices \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    // Handle only working subset \n"\
"    if (globalid < *numitems) \n"\
"    { \n"\
"        newindices[globalid] = previndices[compacted_indices[globalid]]; \n"\
"    } \n"\
"} \n"\
" \n"\
"///< Restore pixel indices after compaction \n"\
"__kernel void FilterPathStream( \n"\
"    // Intersections \n"\
"    __global Intersection const* isects, \n"\
"    // Number of compacted indices \n"\
"    __global int const* numitems, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Paths \n"\
"    __global Path* paths, \n"\
"    // Predicate \n"\
"    __global int* predicate \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    // Handle only working subset \n"\
"    if (globalid < *numitems) \n"\
"    { \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
" \n"\
"        __global Path* path = paths + pixelidx; \n"\
" \n"\
"        if (Path_IsAlive(path)) \n"\
"        { \n"\
"            bool kill = (length(Path_GetThroughput(path)) < CRAZY_LOW_THROUGHPUT); \n"\
" \n"\
"            if (!kill) \n"\
"            { \n"\
"                predicate[globalid] = isects[globalid].shapeid >= 0 ? 1 : 0; \n"\
"            } \n"\
"            else \n"\
"            { \n"\
"                Path_Kill(path); \n"\
"                predicate[globalid] = 0; \n"\
"            } \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            predicate[globalid] = 0; \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"///< Illuminate missing rays \n"\
"__kernel void ShadeBackground( \n"\
"    // Ray batch \n"\
"    __global ray const* rays, \n"\
"    // Intersection data \n"\
"    __global Intersection const* isects, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int const* numrays, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Environment texture index \n"\
"    int envmapidx, \n"\
"    float envmapmul, \n"\
"    // \n"\
"    int num_lights, \n"\
"    __global Path const* paths, \n"\
"    __global Volume const* volumes, \n"\
"    // Output values \n"\
"    __global float4* output \n"\
") \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
" \n"\
"    if (globalid < *numrays) \n"\
"    { \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
" \n"\
"        __global Path const* path = paths + pixelidx; \n"\
" \n"\
"        // In case of a miss \n"\
"        if (isects[globalid].shapeid < 0 && Path_IsAlive(path)) \n"\
"        { \n"\
"            float3 t = Path_GetThroughput(path); \n"\
"            output[pixelidx].xyz += REASONABLE_RADIANCE(envmapmul * Texture_SampleEnvMap(rays[globalid].d.xyz, TEXTURE_ARGS_IDX(envmapidx)) * t); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"// JOSH \n"\
"__kernel void CaptureDepths( \n"\
"                            __global Intersection const* intersections, \n"\
"                            __global int const* numhits, \n"\
"                             __global float* dstdata, \n"\
"                            int count \n"\
"                             ) \n"\
"{ \n"\
"    int gid = get_global_id(0); \n"\
"     \n"\
"    if (gid < *numhits) \n"\
"    { \n"\
"        Intersection v = intersections[gid]; \n"\
"        float n = dstdata[gid]; \n"\
"        n = n * (count - 1); \n"\
"        dstdata[gid] = (n + v.uvwt.w) / count; \n"\
"    } \n"\
"} \n"\
" \n"\
"// Copy data to interop texture if supported \n"\
"__kernel void AccumulateData( \n"\
"    __global float4 const* srcdata, \n"\
"    int numelems, \n"\
"    __global float4* dstdata \n"\
") \n"\
"{ \n"\
"    int gid = get_global_id(0); \n"\
" \n"\
"    if (gid < numelems) \n"\
"    { \n"\
"        float4 v = srcdata[gid]; \n"\
"        dstdata[gid] += v; \n"\
"    } \n"\
"} \n"\
" \n"\
"// Copy data to interop texture if supported \n"\
"__kernel void CopyDepth( \n"\
"    __global float const* data, \n"\
"    int imgwidth, \n"\
"    int imgheight, \n"\
"    write_only image2d_t img \n"\
") \n"\
"{ \n"\
"    int gid = get_global_id(0); \n"\
" \n"\
"    int gidx = gid % imgwidth; \n"\
"    int gidy = gid / imgwidth; \n"\
" \n"\
"    if (gidx < imgwidth && gidy < imgheight) \n"\
"    { \n"\
"        float v = data[gid]; \n"\
"        write_imagef(img, make_int2(gidx, gidy), (float4)(v, v, v, 1.0f)); \n"\
"    } \n"\
"} \n"\
" \n"\
"// Copy data to interop texture if supported \n"\
"__kernel void ApplyGammaAndCopyData( \n"\
"    __global float4 const* data, \n"\
"    int imgwidth, \n"\
"    int imgheight, \n"\
"    float gamma, \n"\
"    write_only image2d_t img \n"\
") \n"\
"{ \n"\
"    int gid = get_global_id(0); \n"\
" \n"\
"    int gidx = gid % imgwidth; \n"\
"    int gidy = gid / imgwidth; \n"\
" \n"\
"    if (gidx < imgwidth && gidy < imgheight) \n"\
"    { \n"\
"        float4 v = data[gid]; \n"\
"        //float4 val = clamp(native_powr(v / v.w, 1.f / gamma), 0.f, 1.f); \n"\
"        float4 val = max(native_powr(v / v.w, 1.f / gamma), 0.f); \n"\
"        write_imagef(img, make_int2(gidx, gidy), val); \n"\
"    } \n"\
"} \n"\
;
static const char g_light_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef LIGHT_CL \n"\
"#define LIGHT_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
" \n"\
" \n"\
"bool IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, float* a, float* b) \n"\
"{ \n"\
"    const float3 e1 = v2 - v1; \n"\
"    const float3 e2 = v3 - v1; \n"\
"    const float3 s1 = cross(r->d.xyz, e2); \n"\
"    const float  invd = native_recip(dot(s1, e1)); \n"\
"    const float3 d = r->o.xyz - v1; \n"\
"    const float  b1 = dot(d, s1) * invd; \n"\
"    const float3 s2 = cross(d, e1); \n"\
"    const float  b2 = dot(r->d.xyz, s2) * invd; \n"\
"    const float temp = dot(e2, s2) * invd; \n"\
" \n"\
"    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f) \n"\
"    { \n"\
"        return false; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *a = b1; \n"\
"        *b = b2; \n"\
"        return true; \n"\
"    } \n"\
"} \n"\
" \n"\
"/* \n"\
" Environment light \n"\
" */ \n"\
"/// Get intensity for a given direction \n"\
"float3 EnvironmentLight_GetLe(// Light \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3* wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    // Sample envmap \n"\
"    *wo *= 100000.f; \n"\
"    // \n"\
"    return scene->envmapmul * Texture_SampleEnvMap(normalize(*wo), TEXTURE_ARGS_IDX(scene->envmapidx)); \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 EnvironmentLight_Sample(// Light \n"\
"                               Light const* light, \n"\
"                               // Scene \n"\
"                               Scene const* scene, \n"\
"                               // Geometry \n"\
"                               DifferentialGeometry const* dg, \n"\
"                               // Textures \n"\
"                               TEXTURE_ARG_LIST, \n"\
"                               // Sample \n"\
"                               float2 sample, \n"\
"                               // Direction to light source \n"\
"                               float3* wo, \n"\
"                               // PDF \n"\
"                               float* pdf \n"\
"                              ) \n"\
"{ \n"\
"    float3 d = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    // Generate direction \n"\
"    *wo = 100000.f * d; \n"\
" \n"\
"    // Envmap PDF \n"\
"    *pdf = fabs(dot(dg->n, normalize(d))) / PI; \n"\
" \n"\
"    // Sample envmap \n"\
"    return scene->envmapmul * Texture_SampleEnvMap(d, TEXTURE_ARGS_IDX(scene->envmapidx)); \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float EnvironmentLight_GetPdf( \n"\
"                              // Light \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3 wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return max(0.f, fabs(dot(dg->n, normalize(wo)))/ PI); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Area light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 AreaLight_GetLe(// Emissive object \n"\
"                       Light const* light, \n"\
"                       // Scene \n"\
"                       Scene const* scene, \n"\
"                       // Geometry \n"\
"                       DifferentialGeometry const* dg, \n"\
"                       // Direction to light source \n"\
"                       float3* wo, \n"\
"                       // Textures \n"\
"                       TEXTURE_ARG_LIST \n"\
"                       ) \n"\
"{ \n"\
"    ray r; \n"\
"    r.o.xyz = dg->p; \n"\
"    r.d.xyz = normalize(*wo); \n"\
" \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
" \n"\
" \n"\
"    // Intersect ray against this area light \n"\
" \n"\
"    float a, b; \n"\
"    if (IntersectTriangle(&r, v0, v1, v2, &a, &b)) \n"\
"    { \n"\
"        float3 n = normalize(transform_vector((1.f - a - b) * n0 + a * n1 + b * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"        float3 p = transform_point((1.f - a - b) * v0 + a * v1 + b * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float2 tx = (1.f - a - b) * uv0 + a * uv1 + b * uv2; \n"\
" \n"\
"        float3 d = p - dg->p; \n"\
"        float  ld = length(d); \n"\
"        *wo = p - dg->p; \n"\
" \n"\
"        int matidx = scene->materialids[shape.startidx / 3 + primidx]; \n"\
"        Material mat = scene->materials[matidx]; \n"\
" \n"\
"        const float3 ke = Texture_GetValue3f(mat.kx.xyz, tx, TEXTURE_ARGS_IDX(mat.kxmapidx)); \n"\
"        float ndotv = dot(n, -(normalize(d))); \n"\
"        return  ke; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 AreaLight_Sample(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST, \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Direction to light source \n"\
"                        float3* wo, \n"\
"                        // PDF \n"\
"                        float* pdf) \n"\
"{ \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
" \n"\
"    // Generate sample on triangle \n"\
"    float r0 = sample.x; \n"\
"    float r1 = sample.y; \n"\
" \n"\
"    // Convert random to barycentric coords \n"\
"    float2 uv; \n"\
"    uv.x = native_sqrt(r0) * (1.f - r1); \n"\
"    uv.y = native_sqrt(r0) * r1; \n"\
" \n"\
"    // Calculate barycentric position and normal \n"\
"    float3 n = normalize((1.f - uv.x - uv.y) * n0 + uv.x * n1 + uv.y * n2); \n"\
"    float3 p = (1.f - uv.x - uv.y) * v0 + uv.x * v1 + uv.y * v2; \n"\
"    float2 tx = (1.f - uv.x - uv.y) * uv0 + uv.x * uv1 + uv.y * uv2; \n"\
" \n"\
"    *wo = p - dg->p; \n"\
"    *pdf = 1.f / (length(cross(v2 - v0, v2 - v1)) * 0.5f); \n"\
" \n"\
"    int matidx = scene->materialids[shape.startidx / 3 + primidx]; \n"\
"    Material mat = scene->materials[matidx]; \n"\
" \n"\
"    const float3 ke = Texture_GetValue3f(mat.kx.xyz, tx, TEXTURE_ARGS_IDX(mat.kxmapidx)); \n"\
" \n"\
"    float3 v = -normalize(*wo); \n"\
" \n"\
"    float ndotv = dot(n, v); \n"\
" \n"\
"    if (ndotv > 0.f) \n"\
"    { \n"\
"        float denom = (length(*wo) * length(*wo)); \n"\
"        return denom > 0.f ? ke * ndotv / denom : 0.f; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float AreaLight_GetPdf(// Emissive object \n"\
"                       Light const* light, \n"\
"                       // Scene \n"\
"                       Scene const* scene, \n"\
"                       // Geometry \n"\
"                       DifferentialGeometry const* dg, \n"\
"                       // Direction to light source \n"\
"                       float3 wo, \n"\
"                       // Textures \n"\
"                       TEXTURE_ARG_LIST \n"\
"                       ) \n"\
"{ \n"\
"    ray r; \n"\
"    r.o.xyz = dg->p; \n"\
"    r.d.xyz = wo; \n"\
" \n"\
"    int shapeidx = light->shapeidx; \n"\
"    int primidx = light->primidx; \n"\
" \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeidx]; \n"\
" \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primidx]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primidx + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primidx + 2]; \n"\
" \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
" \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
" \n"\
"    // Intersect ray against this area light \n"\
"    float a, b; \n"\
"    if (IntersectTriangle(&r, v0, v1, v2, &a, &b)) \n"\
"    { \n"\
"        float3 n = normalize(transform_vector((1.f - a - b) * n0 + a * n1 + b * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"        float3 p = transform_point((1.f - a - b) * v0 + a * v1 + b * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 d = p - dg->p; \n"\
"        float  ld = length(d); \n"\
" \n"\
"        float3 p0 = transform_point(v0, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 p1 = transform_point(v1, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"        float3 p2 = transform_point(v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
" \n"\
"        float area = 0.5f * length(cross(p2 - p0, p2 - p1)); \n"\
"        float denom = (fabs(dot(normalize(d), dg->n)) * area); \n"\
" \n"\
"        return denom > 0.f ? ld * ld / denom : 0.f; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/* \n"\
"Directional light \n"\
"*/ \n"\
"// Get intensity for a given direction \n"\
"float3 DirectionalLight_GetLe(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Direction to light source \n"\
"    float3* wo, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST \n"\
") \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 DirectionalLight_Sample(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Direction to light source \n"\
"    float3* wo, \n"\
"    // PDF \n"\
"    float* pdf) \n"\
"{ \n"\
"    *wo = 100000.f * -light->d; \n"\
"    *pdf = 1.f; \n"\
"    return light->intensity; \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float DirectionalLight_GetPdf(// Emissive object \n"\
"    Light const* light, \n"\
"    // Scene \n"\
"    Scene const* scene, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Direction to light source \n"\
"    float3 wo, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST \n"\
") \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Point light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 PointLight_GetLe(// Emissive object \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3* wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 PointLight_Sample(// Emissive object \n"\
"                               Light const* light, \n"\
"                               // Scene \n"\
"                               Scene const* scene, \n"\
"                               // Geometry \n"\
"                               DifferentialGeometry const* dg, \n"\
"                               // Textures \n"\
"                               TEXTURE_ARG_LIST, \n"\
"                               // Sample \n"\
"                               float2 sample, \n"\
"                               // Direction to light source \n"\
"                               float3* wo, \n"\
"                               // PDF \n"\
"                               float* pdf) \n"\
"{ \n"\
"    *wo = light->p - dg->p; \n"\
"    *pdf = 1.f; \n"\
"    return light->intensity; \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float PointLight_GetPdf(// Emissive object \n"\
"                              Light const* light, \n"\
"                              // Scene \n"\
"                              Scene const* scene, \n"\
"                              // Geometry \n"\
"                              DifferentialGeometry const* dg, \n"\
"                              // Direction to light source \n"\
"                              float3 wo, \n"\
"                              // Textures \n"\
"                              TEXTURE_ARG_LIST \n"\
"                              ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Spot light \n"\
" */ \n"\
"// Get intensity for a given direction \n"\
"float3 SpotLight_GetLe(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Direction to light source \n"\
"                        float3* wo, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST \n"\
"                        ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 SpotLight_Sample(// Emissive object \n"\
"                         Light const* light, \n"\
"                         // Scene \n"\
"                         Scene const* scene, \n"\
"                         // Geometry \n"\
"                         DifferentialGeometry const* dg, \n"\
"                         // Textures \n"\
"                         TEXTURE_ARG_LIST, \n"\
"                         // Sample \n"\
"                         float2 sample, \n"\
"                         // Direction to light source \n"\
"                         float3* wo, \n"\
"                         // PDF \n"\
"                         float* pdf) \n"\
"{ \n"\
"    *wo = light->p - dg->p; \n"\
"    float ddotwo = dot(-normalize(*wo), light->d); \n"\
"     \n"\
"    if (ddotwo > light->oa) \n"\
"    { \n"\
"        *pdf = 1.f; \n"\
"        return ddotwo > light->ia ? light->intensity : light->intensity * (1.f - (light->ia - ddotwo) / (light->ia - light->oa)); \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float SpotLight_GetPdf(// Emissive object \n"\
"                        Light const* light, \n"\
"                        // Scene \n"\
"                        Scene const* scene, \n"\
"                        // Geometry \n"\
"                        DifferentialGeometry const* dg, \n"\
"                        // Direction to light source \n"\
"                        float3 wo, \n"\
"                        // Textures \n"\
"                        TEXTURE_ARG_LIST \n"\
"                        ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/* \n"\
" Dispatch calls \n"\
" */ \n"\
" \n"\
"/// Get intensity for a given direction \n"\
"float3 Light_GetLe(// Light index \n"\
"                   int idx, \n"\
"                   // Scene \n"\
"                   Scene const* scene, \n"\
"                   // Geometry \n"\
"                   DifferentialGeometry const* dg, \n"\
"                   // Direction to light source \n"\
"                   float3* wo, \n"\
"                   // Textures \n"\
"                   TEXTURE_ARG_LIST \n"\
"                   ) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kArea: \n"\
"            return AreaLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kPoint: \n"\
"            return PointLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kSpot: \n"\
"            return SpotLight_GetLe(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"/// Sample direction to the light \n"\
"float3 Light_Sample(// Light index \n"\
"                    int idx, \n"\
"                    // Scene \n"\
"                    Scene const* scene, \n"\
"                    // Geometry \n"\
"                    DifferentialGeometry const* dg, \n"\
"                    // Textures \n"\
"                    TEXTURE_ARG_LIST, \n"\
"                    // Sample \n"\
"                    float2 sample, \n"\
"                    // Direction to light source \n"\
"                    float3* wo, \n"\
"                    // PDF \n"\
"                    float* pdf) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kArea: \n"\
"            return AreaLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kPoint: \n"\
"            return PointLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"        case kSpot: \n"\
"            return SpotLight_Sample(&light, scene, dg, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"/// Get PDF for a given direction \n"\
"float Light_GetPdf(// Light index \n"\
"                   int idx, \n"\
"                   // Scene \n"\
"                   Scene const* scene, \n"\
"                   // Geometry \n"\
"                   DifferentialGeometry const* dg, \n"\
"                   // Direction to light source \n"\
"                   float3 wo, \n"\
"                   // Textures \n"\
"                   TEXTURE_ARG_LIST \n"\
"                   ) \n"\
"{ \n"\
"    Light light = scene->lights[idx]; \n"\
" \n"\
"    switch(light.type) \n"\
"    { \n"\
"        case kIbl: \n"\
"            return EnvironmentLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kArea: \n"\
"            return AreaLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kDirectional: \n"\
"            return DirectionalLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kPoint: \n"\
"            return PointLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"        case kSpot: \n"\
"            return SpotLight_GetPdf(&light, scene, dg, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Check if the light is singular \n"\
"bool Light_IsSingular(__global Light const* light) \n"\
"{ \n"\
"    return light->type == kPoint || \n"\
"        light->type == kSpot || \n"\
"        light->type == kDirectional; \n"\
"} \n"\
" \n"\
"#endif // LIGHT_CLnv \n"\
;
static const char g_material_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef MATERIAL_CL \n"\
"#define MATERIAL_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef BXDF_CL \n"\
"#define BXDF_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"#define DENOM_EPS 0.0f \n"\
"#define ROUGHNESS_EPS 0.0001f \n"\
" \n"\
"enum Bxdf \n"\
"{ \n"\
"    kZero, \n"\
"    kLambert, \n"\
"    kIdealReflect, \n"\
"    kIdealRefract, \n"\
"    kMicrofacetBlinn, \n"\
"    kMicrofacetBeckmann, \n"\
"    kMicrofacetGGX, \n"\
"    kLayered, \n"\
"    kFresnelBlend, \n"\
"    kMix, \n"\
"    kEmissive, \n"\
"    kPassthrough, \n"\
"    kTranslucent, \n"\
"    kMicrofacetRefractionGGX, \n"\
"    kMicrofacetRefractionBeckmann \n"\
"}; \n"\
" \n"\
"enum BxdfFlags \n"\
"{ \n"\
"    kReflection = (1 << 0), \n"\
"    kTransmission = (1 << 1), \n"\
"    kDiffuse = (1 << 2), \n"\
"    kSpecular = (1 << 3), \n"\
"    kGlossy = (1 << 4), \n"\
"    kAllReflection = kReflection | kDiffuse | kSpecular | kGlossy, \n"\
"    kAllTransmission = kTransmission | kDiffuse | kSpecular | kGlossy, \n"\
"    kAll = kReflection | kTransmission | kDiffuse | kSpecular | kGlossy \n"\
"}; \n"\
" \n"\
" \n"\
"/// Schlick's approximation of Fresnel equtions \n"\
"float SchlickFresnel(float eta, float ndotw) \n"\
"{ \n"\
"    const float f = ((1.f - eta) / (1.f + eta)) * ((1.f - eta) / (1.f + eta)); \n"\
"    const float m = 1.f - fabs(ndotw); \n"\
"    const float m2 = m*m; \n"\
"    return f + (1.f - f) * m2 * m2 * m; \n"\
"} \n"\
" \n"\
"/// Full Fresnel equations \n"\
"float FresnelDielectric(float etai, float etat, float ndotwi, float ndotwt) \n"\
"{ \n"\
"    // Parallel and perpendicular polarization \n"\
"    float rparl = ((etat * ndotwi) - (etai * ndotwt)) / ((etat * ndotwi) + (etai * ndotwt)); \n"\
"    float rperp = ((etai * ndotwi) - (etat * ndotwt)) / ((etai * ndotwi) + (etat * ndotwt)); \n"\
"    return (rparl*rparl + rperp*rperp) * 0.5f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Microfacet Beckmann \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Beckmann_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = dot(m, n); \n"\
" \n"\
"    if (ndotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = sinmn / ndotm; \n"\
"    float a2 = roughness * roughness; \n"\
" \n"\
"    return (1.f / (PI * a2 * ndotm2 * ndotm2)) * native_exp(-tanmn * tanmn / a2); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Beckmann_GetPdf( \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 m = normalize(wi + wo); \n"\
"    float wodotm = dot(wo, m); \n"\
" \n"\
"    if (wodotm <= 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    // \n"\
"    float mpdf = MicrofacetDistribution_Beckmann_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
" \n"\
"    return mpdf / (4.f * wodotm); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_Sample(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Beckmann_SampleNormal(// Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(native_sqrt(-roughness*roughness*native_log(1.f - r1*0.99f))); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"float MicrofacetDistribution_Beckmann_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = sinnv / ndotv; \n"\
"    float a = tannv > DENOM_EPS ? 1.f / (roughness * tannv) : 0.f; \n"\
"    float a2 = a * a; \n"\
" \n"\
"    if (a < 1.6f) \n"\
"        return 1.f; \n"\
" \n"\
"    return (3.535f * a + 2.181f * a2) / (1.f + 2.276f * a + 2.577f * a2); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Beckmann_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_Beckmann_G1(roughness, wi, wh, n) * MicrofacetDistribution_Beckmann_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
" \n"\
"float3 MicrofacetBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = 4.f * costhetao * costhetai; \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    return MicrofacetDistribution_Beckmann_GetPdf(roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    MicrofacetDistribution_Beckmann_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet GGX \n"\
" */ \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_GGX_D(float roughness, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotm = fabs(dot(m, n)); \n"\
"    float ndotm2 = ndotm * ndotm; \n"\
"    float sinmn = native_sqrt(1.f - clamp(ndotm * ndotm, 0.f, 1.f)); \n"\
"    float tanmn = ndotm > DENOM_EPS ? sinmn / ndotm : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    float denom = (PI * ndotm2 * ndotm2 * (a2 + tanmn * tanmn) * (a2 + tanmn * tanmn)); \n"\
"    return denom > DENOM_EPS ? (a2 / denom) : 0.f; \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_GGX_GetPdf( \n"\
"    // Halfway vector \n"\
"    float3 m, \n"\
"    // Rougness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float mpdf = MicrofacetDistribution_GGX_D(roughness, m, dg->n) * fabs(dot(dg->n, m)); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (4.f * fabs(dot(wo, m))); \n"\
" \n"\
"    return denom > DENOM_EPS ? mpdf / denom : 0.f; \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_Sample( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*fabs(dot(wi, wh)) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_GGX_SampleNormal( \n"\
"    // Roughness \n"\
"    float roughness, \n"\
"    // Differential geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wh \n"\
"    ) \n"\
"{ \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float temp = atan(roughness * native_sqrt(r1) / native_sqrt(1.f - r1)); \n"\
"    float theta = (float)((temp >= 0) ? temp : (temp + 2 * PI)); \n"\
" \n"\
"    float costheta = native_cos(theta); \n"\
"    float sintheta = native_sqrt(1.f - clamp(costheta * costheta, 0.f, 1.f)); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - clamp(cosphi * cosphi, 0.f, 1.f)); \n"\
" \n"\
"    // Calculate wh \n"\
"    *wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
"} \n"\
" \n"\
"// \n"\
"float MicrofacetDistribution_GGX_G1(float roughness, float3 v, float3 m, float3 n) \n"\
"{ \n"\
"    float ndotv = fabs(dot(n, v)); \n"\
"    float mdotv = fabs(dot(m, v)); \n"\
" \n"\
"    float sinnv = native_sqrt(1.f - clamp(ndotv * ndotv, 0.f, 1.f)); \n"\
"    float tannv = ndotv > 0.f ? sinnv / ndotv : 0.f; \n"\
"    float a2 = roughness * roughness; \n"\
"    return 2.f / (1.f + native_sqrt(1.f + a2 * tannv * tannv)); \n"\
"} \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_GGX_G(float roughness, float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    return MicrofacetDistribution_GGX_G1(roughness, wi, wh, n) * MicrofacetDistribution_GGX_G1(roughness, wo, wh, n); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > 0.f ? F * ks * MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"float MicrofacetGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float3 wh = normalize(wo + wi); \n"\
" \n"\
"    return MicrofacetDistribution_GGX_GetPdf(wh, roughness, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 MicrofacetGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    MicrofacetDistribution_GGX_Sample(roughness, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
" \n"\
"    return MicrofacetGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"/* \n"\
" Microfacet Blinn \n"\
" */ \n"\
" \n"\
" // Distribution fucntion \n"\
"float MicrofacetDistribution_Blinn_D(float shininess, float3 w, float3 n) \n"\
"{ \n"\
"    float ndotw = fabs(dot(n, w)); \n"\
"    return (1.f / (2 * PI)) * (shininess + 2) * native_powr(ndotw, shininess); \n"\
"} \n"\
" \n"\
"// PDF of the given direction \n"\
"float MicrofacetDistribution_Blinn_GetPdf(// Shininess \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    // We need to convert pdf(wh)->pdf(wo) \n"\
"    float3 wh = normalize(wi + wo); \n"\
"    // costheta \n"\
"    float ndotwh = dot(dg->n, wh); \n"\
"    // See Humphreys and Pharr for derivation \n"\
"    float denom = (2.f * PI * 4.f * dot(wo, wh)); \n"\
"    return denom > DENOM_EPS ? ((shininess + 1.f) * native_powr(ndotwh, shininess)) / denom : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
"// Sample the distribution \n"\
"void MicrofacetDistribution_Blinn_Sample(// Shininess param \n"\
"    float shininess, \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    // \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
" \n"\
"    // Sample halfway vector first, then reflect wi around that \n"\
"    float costheta = native_powr(r1, 1.f / (shininess + 1.f)); \n"\
"    float sintheta = native_sqrt(1.f - costheta * costheta); \n"\
" \n"\
"    // phi = 2*PI*ksi2 \n"\
"    float cosphi = native_cos(2.f*PI*r2); \n"\
"    float sinphi = native_sqrt(1.f - cosphi * cosphi); \n"\
" \n"\
"    // Calculate wh \n"\
"    float3 wh = normalize(dg->dpdu * sintheta * cosphi + dg->dpdv * sintheta * sinphi + dg->n * costheta); \n"\
" \n"\
"    // Reflect wi around wh \n"\
"    *wo = -wi + 2.f*dot(wi, wh) * wh; \n"\
" \n"\
"    // Calc pdf \n"\
"    *pdf = MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
"// Shadowing function also depends on microfacet distribution \n"\
"float MicrofacetDistribution_Blinn_G(float3 wi, float3 wo, float3 wh, float3 n) \n"\
"{ \n"\
"    float ndotwh = fabs(dot(n, wh)); \n"\
"    float ndotwo = fabs(dot(n, wo)); \n"\
"    float ndotwi = fabs(dot(n, wi)); \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    return min(1.f, min(2.f * ndotwh * ndotwo / wodotwh, 2.f * ndotwh * ndotwi / wodotwh)); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF evaluation \n"\
"float3 MicrofacetBlinn_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
"    const float shininess = dg->mat.ns; \n"\
" \n"\
"    // Incident and reflected zenith angles \n"\
"    float costhetao = dot(dg->n, wo); \n"\
"    float costhetai = dot(dg->n, wi); \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 wh = normalize(wi + wo); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = (4.f * costhetao * costhetai); \n"\
" \n"\
"    // F(eta) * D * G * ks / (4 * cosa * cosi) \n"\
"    return denom > DENOM_EPS ? F * ks * MicrofacetDistribution_Blinn_G(wi, wo, wh, dg->n) * MicrofacetDistribution_Blinn_D(shininess, wh, dg->n) / denom : 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float MicrofacetBlinn_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float shininess = dg->mat.ns; \n"\
"    return MicrofacetDistribution_Blinn_GetPdf(shininess, dg, wi, wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 MicrofacetBlinn_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    if (dot(dg->n, wi) <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    const float shininess = dg->mat.ns; \n"\
"    MicrofacetDistribution_Blinn_Sample(shininess, dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    return MicrofacetBlinn_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"/* \n"\
" Lambert BRDF \n"\
" */ \n"\
" /// Lambert BRDF evaluation \n"\
"float3 Lambert_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Lambert_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return fabs(dot(dg->n, wo)) / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Lambert_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    *wo = Sample_MapToHemisphere(sample, dg->n, 1.f); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *pdf = fabs(dot(dg->n, *wo)) / PI; \n"\
" \n"\
"    return F * kd / PI; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal reflection BRDF \n"\
" */ \n"\
"float3 IdealReflect_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF sampling \n"\
"float3 Translucent_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float3 n = ndotwi > DENOM_EPS ? -dg->n : dg->n; \n"\
" \n"\
"    *wo = normalize(Sample_MapToHemisphere(sample, n, 1.f)); \n"\
" \n"\
"    *pdf = fabs(dot(n, *wo)) / PI; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"// Lambert BRDF evaluation \n"\
"float3 Translucent_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0.f) \n"\
"        return 0.f; \n"\
" \n"\
"    return kd / PI; \n"\
"} \n"\
" \n"\
"/// Lambert BRDF PDF \n"\
"float Translucent_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo > 0) \n"\
"        return 0.f; \n"\
" \n"\
"    return fabs(ndotwo) / PI; \n"\
"} \n"\
" \n"\
"float IdealReflect_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealReflect_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float eta = dg->mat.ni; \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    // Mirror reflect wi \n"\
"    *wo = normalize(2.f * ndotwi * dg->n - wi); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // Return reflectance value \n"\
"    return coswo > DENOM_EPS ? (F * ks * (1.f / coswo)) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Ideal refraction BTDF \n"\
" */ \n"\
" \n"\
"float3 IdealRefract_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float IdealRefract_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 IdealRefract_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float cosi = dot(dg->n, wi); \n"\
" \n"\
"    bool entering = cosi > 0.f; \n"\
"    float3 n = dg->n; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (!entering) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        n = -dg->n; \n"\
"        cosi = -cosi; \n"\
"    } \n"\
" \n"\
"    float eta = etai / etat; \n"\
"    float sini2 = 1.f - cosi * cosi; \n"\
" \n"\
"    float sint2 = eta * eta * sini2; \n"\
" \n"\
"    if (sint2 >= 1.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
" \n"\
"    // Transmitted ray \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    *wo = normalize(-n * cost + normalize(n * cosi - wi) * native_sqrt(max(sint2, 0.f))); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    return cost > 0.0001f ? F * (((etai * etai) / (etat * etat)) * ks / cost) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_GGX_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_GGX_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionGGX_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    if (ndotwi * ndotwo >= 0.f) \n"\
"    { \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_GGX_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionGGX_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    if (ndotwi == 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_GGX_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0.f) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionGGX_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionGGX_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = max(Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)), ROUGHNESS_EPS); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float widotwh = fabs(dot(wh, wi)); \n"\
"    float wodotwh = fabs(dot(wh, wo)); \n"\
" \n"\
"    float F = dg->mat.fresnel; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
"    denom *= (fabs(ndotwi) * fabs(ndotwo)); \n"\
" \n"\
"    return denom > DENOM_EPS ? (F * ks * (widotwh * wodotwh)  * (etat)* (etat)* \n"\
"        MicrofacetDistribution_Beckmann_G(roughness, wi, wo, wh, dg->n) * MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) / denom) : 0.f; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"float MicrofacetRefractionBeckmann_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
"    float ndotwo = dot(dg->n, wo); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"    } \n"\
" \n"\
"    // Calc halfway vector \n"\
"    float3 ht = -(etai * wi + etat * wo); \n"\
" \n"\
"    float3 wh = normalize(ht); \n"\
" \n"\
"    float wodotwh = fabs(dot(wo, wh)); \n"\
" \n"\
"    float whpdf = MicrofacetDistribution_Beckmann_D(roughness, wh, dg->n) * fabs(dot(wh, dg->n)); \n"\
" \n"\
"    float whwo = wodotwh * etat * etat; \n"\
" \n"\
"    float denom = dot(ht, ht); \n"\
" \n"\
"    return denom > DENOM_EPS ? whpdf * whwo / denom : 0.f; \n"\
"} \n"\
" \n"\
"float3 MicrofacetRefractionBeckmann_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    const float3 ks = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    const float roughness = Texture_GetValue1f(dg->mat.ns, dg->uv, TEXTURE_ARGS_IDX(dg->mat.nsmapidx)); \n"\
" \n"\
"    float ndotwi = dot(dg->n, wi); \n"\
" \n"\
"    float etai = 1.f; \n"\
"    float etat = dg->mat.ni; \n"\
"    float s = 1.f; \n"\
" \n"\
"    // Revert normal and eta if needed \n"\
"    if (ndotwi < 0.f) \n"\
"    { \n"\
"        float tmp = etai; \n"\
"        etai = etat; \n"\
"        etat = tmp; \n"\
"        s = -s; \n"\
"    } \n"\
" \n"\
"    float3 wh; \n"\
"    MicrofacetDistribution_Beckmann_SampleNormal(roughness, dg, TEXTURE_ARGS, sample, &wh); \n"\
" \n"\
"    float c = dot(wi, wh); \n"\
"    float eta = etai / etat; \n"\
" \n"\
"    float d = 1 + eta * (c * c - 1); \n"\
" \n"\
"    if (d <= 0) \n"\
"    { \n"\
"        *pdf = 0.f; \n"\
"        return 0.f; \n"\
"    } \n"\
" \n"\
"    *wo = normalize((eta * c - s * native_sqrt(d)) * wh - eta * wi); \n"\
" \n"\
"    *pdf = MicrofacetRefractionBeckmann_GetPdf(dg, wi, *wo, TEXTURE_ARGS); \n"\
" \n"\
"    return MicrofacetRefractionBeckmann_Evaluate(dg, wi, *wo, TEXTURE_ARGS); \n"\
"} \n"\
" \n"\
"float3 Passthrough_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // Sample \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at wo \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
" \n"\
"    *wo = -wi; \n"\
"    float coswo = fabs(dot(dg->n, *wo)); \n"\
" \n"\
"    // PDF is infinite at that point, but deltas are going to cancel out while evaluating \n"\
"    // so set it to 1.f \n"\
"    *pdf = 1.f; \n"\
" \n"\
"    //  \n"\
"    return coswo > 0.0001f ? (1.f / coswo) : 0.f; \n"\
"} \n"\
" \n"\
"/* \n"\
" Dispatch functions \n"\
" */ \n"\
"float3 Bxdf_Evaluate( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Evaluate(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"float3 Bxdf_Sample( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG \n"\
"    float2 sample, \n"\
"    // Outgoing  direction \n"\
"    float3* wo, \n"\
"    // PDF at w \n"\
"    float* pdf \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kTranslucent: \n"\
"        return Translucent_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kPassthrough: \n"\
"        return Passthrough_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_Sample(dg, wi, TEXTURE_ARGS, sample, wo, pdf); \n"\
"    } \n"\
" \n"\
"    *pdf = 0.f; \n"\
"    return make_float3(0.f, 0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Bxdf_GetPdf( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Outgoing direction \n"\
"    float3 wo, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST \n"\
"    ) \n"\
"{ \n"\
"    int mattype = dg->mat.type; \n"\
"    switch (mattype) \n"\
"    { \n"\
"    case kLambert: \n"\
"        return Lambert_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBlinn: \n"\
"        return MicrofacetBlinn_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetGGX: \n"\
"        return MicrofacetGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetBeckmann: \n"\
"        return MicrofacetBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealReflect: \n"\
"        return IdealReflect_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kIdealRefract: \n"\
"        return IdealRefract_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kTranslucent: \n"\
"        return Translucent_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kPassthrough: \n"\
"        return 0.f; \n"\
"    case kMicrofacetRefractionGGX: \n"\
"        return MicrofacetRefractionGGX_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    case kMicrofacetRefractionBeckmann: \n"\
"        return MicrofacetRefractionBeckmann_GetPdf(dg, wi, wo, TEXTURE_ARGS); \n"\
"    } \n"\
" \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"/// Emissive BRDF sampling \n"\
"float3 Emissive_GetLe( \n"\
"    // Geometry \n"\
"    DifferentialGeometry const* dg, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    const float3 kd = Texture_GetValue3f(dg->mat.kx.xyz, dg->uv, TEXTURE_ARGS_IDX(dg->mat.kxmapidx)); \n"\
"    return kd; \n"\
"} \n"\
" \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsSingular(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealReflect || dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough; \n"\
"} \n"\
" \n"\
"/// BxDF emission check \n"\
"bool Bxdf_IsEmissive(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kEmissive; \n"\
"} \n"\
" \n"\
"/// BxDF singularity check \n"\
"bool Bxdf_IsBtdf(DifferentialGeometry const* dg) \n"\
"{ \n"\
"    return dg->mat.type == kIdealRefract || dg->mat.type == kPassthrough || dg->mat.type == kTranslucent || \n"\
"        dg->mat.type == kMicrofacetRefractionGGX || dg->mat.type == kMicrofacetRefractionBeckmann; \n"\
"} \n"\
" \n"\
"#endif // BXDF_CL \n"\
" \n"\
"void Material_Select( \n"\
"    // Scene data \n"\
"    Scene const* scene, \n"\
"    // Incoming direction \n"\
"    float3 wi, \n"\
"    // Texture args \n"\
"    TEXTURE_ARG_LIST, \n"\
" \n"\
"#ifdef SOBOL \n"\
"    // Sampler state \n"\
"    __global SobolSampler* sampler, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Current bounce \n"\
"    int bounce, \n"\
"#else \n"\
"    Rng* rng, \n"\
"#endif \n"\
" \n"\
"    // Geometry \n"\
"    DifferentialGeometry* dg \n"\
") \n"\
"{ \n"\
"    // Check material type \n"\
"    int type = dg->mat.type; \n"\
" \n"\
"    // If material is regular BxDF we do not have to sample it \n"\
"    if (type != kFresnelBlend && type != kMix) \n"\
"    { \n"\
"        // If fresnel > 0 here we need to calculate Frensle factor (remove this workaround) \n"\
"        if (dg->mat.fresnel > 0.f) \n"\
"        { \n"\
"            float etai = 1.f; \n"\
"            float etat = dg->mat.ni; \n"\
"            float cosi = dot(dg->n, wi); \n"\
" \n"\
"            // Revert normal and eta if needed \n"\
"            if (cosi < 0.f) \n"\
"            { \n"\
"                float tmp = etai; \n"\
"                etai = etat; \n"\
"                etat = tmp; \n"\
"                cosi = -cosi; \n"\
"            } \n"\
" \n"\
"            float eta = etai / etat; \n"\
"            float sini2 = 1.f - cosi * cosi; \n"\
"            float sint2 = eta * eta * sini2; \n"\
" \n"\
"            float fresnel = 1.f; \n"\
" \n"\
"            if (sint2 < 1.f) \n"\
"            { \n"\
"                float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
"                fresnel = FresnelDielectric(etai, etat, cosi, cost); \n"\
"            } \n"\
" \n"\
"            dg->mat.fresnel = Bxdf_IsBtdf(dg) ? (1.f - fresnel) : fresnel; \n"\
"        } \n"\
"        else \n"\
"        { \n"\
"            // Otherwise set multiplier to 1 \n"\
"            dg->mat.fresnel = 1.f; \n"\
"        } \n"\
"    } \n"\
"    // Here we deal with combined material and we have to sample \n"\
"    else \n"\
"    { \n"\
"        // Prefetch current material \n"\
"        Material mat = dg->mat; \n"\
"        int iter = 0; \n"\
" \n"\
"        // Might need several passes of sampling \n"\
"        while (mat.type == kFresnelBlend || mat.type == kMix) \n"\
"        { \n"\
"            if (mat.type == kFresnelBlend) \n"\
"            { \n"\
"                float etai = 1.f; \n"\
"                float etat = mat.ni; \n"\
"                float cosi = dot(dg->n, wi); \n"\
" \n"\
"                // Revert normal and eta if needed \n"\
"                if (cosi < 0.f) \n"\
"                { \n"\
"                    float tmp = etai; \n"\
"                    etai = etat; \n"\
"                    etat = tmp; \n"\
"                    cosi = -cosi; \n"\
"                } \n"\
" \n"\
"                float eta = etai / etat; \n"\
"                float sini2 = 1.f - cosi * cosi; \n"\
"                float sint2 = eta * eta * sini2; \n"\
" \n"\
"                int idx = 0; \n"\
" \n"\
"                float fresnel = 1.f; \n"\
" \n"\
"                if (sint2 < 1.f) \n"\
"                { \n"\
"                    float cost = native_sqrt(max(0.f, 1.f - sint2)); \n"\
"                    fresnel = FresnelDielectric(etai, etat, cosi, cost); \n"\
"                } \n"\
" \n"\
"#ifdef SOBOL \n"\
"                float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kMaterial + iter), sampler->s0, sobolmat); \n"\
"#else \n"\
"                float sample = UniformSampler_Sample2D(rng).x; \n"\
"#endif \n"\
" \n"\
"                if (sample < fresnel) \n"\
"                { \n"\
"                    // Sample top \n"\
"                    idx = mat.brdftopidx; \n"\
"                    //  \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"                else \n"\
"                { \n"\
"                    // Sample base \n"\
"                    idx = mat.brdfbaseidx; \n"\
"                    //  \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"            } \n"\
"            else \n"\
"            { \n"\
" \n"\
"#ifdef SOBOL \n"\
"                float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kMaterial + iter), sampler->s0, sobolmat); \n"\
"#else \n"\
"                float sample = UniformSampler_Sample2D(rng).x; \n"\
"#endif \n"\
"                float weight = Texture_GetValue1f(mat.ns, dg->uv, TEXTURE_ARGS_IDX(mat.nsmapidx)); \n"\
" \n"\
"                if (sample < weight) \n"\
"                { \n"\
"                    // Sample top \n"\
"                    int idx = mat.brdftopidx; \n"\
"                    // \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"                else \n"\
"                { \n"\
"                    // Sample base \n"\
"                    int idx = mat.brdfbaseidx; \n"\
"                    // \n"\
"                    mat = scene->materials[idx]; \n"\
"                    mat.fresnel = 1.f; \n"\
"                } \n"\
"            } \n"\
"        } \n"\
" \n"\
"        dg->mat = mat; \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"#endif // MATERIAL_CL \n"\
;
static const char g_normalmap_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef NORMALMAP_CL \n"\
"#define NORMALMAP_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"void ApplyNormalMap(DifferentialGeometry* dg, TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    int nmapidx = dg->mat.nmapidx; \n"\
"    if (nmapidx != -1) \n"\
"    { \n"\
"        // Now n, dpdu, dpdv is orthonormal basis \n"\
"        float3 mappednormal = 2.f * Texture_Sample2D(dg->uv, TEXTURE_ARGS_IDX(nmapidx)).xyz - make_float3(1.f, 1.f, 1.f); \n"\
" \n"\
"        // Return mapped version \n"\
"        dg->n = normalize(mappednormal.z *  dg->n * 0.5f + mappednormal.x * dg->dpdu + mappednormal.y * dg->dpdv); \n"\
"    } \n"\
"} \n"\
" \n"\
"void ApplyBumpMap(DifferentialGeometry* dg, TEXTURE_ARG_LIST) \n"\
"{ \n"\
"    int nmapidx = dg->mat.nmapidx; \n"\
"    if (nmapidx != -1) \n"\
"    { \n"\
"        // Now n, dpdu, dpdv is orthonormal basis \n"\
"        float3 mappednormal = 2.f * Texture_SampleBump(dg->uv, TEXTURE_ARGS_IDX(nmapidx)) - make_float3(1.f, 1.f, 1.f); \n"\
" \n"\
"        // Return mapped version \n"\
"        dg->n = normalize(mappednormal.z * dg->n + mappednormal.x * dg->dpdu + mappednormal.y * dg->dpdv); \n"\
"    } \n"\
"} \n"\
" \n"\
"#endif // NORMALMAP_CL \n"\
;
static const char g_path_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
;
static const char g_payload_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
;
static const char g_random_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
;
static const char g_sampling_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SAMPLING_CL \n"\
"#define SAMPLING_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef RANDOM_CL \n"\
"#define RANDOM_CL \n"\
" \n"\
"/// Pseudo-random number generator state \n"\
"typedef struct _Rng \n"\
"    { \n"\
"        uint val; \n"\
"    } Rng; \n"\
" \n"\
"/// Hash function \n"\
"uint WangHash(uint seed) \n"\
"{ \n"\
"    seed = (seed ^ 61) ^ (seed >> 16); \n"\
"    seed *= 9; \n"\
"    seed = seed ^ (seed >> 4); \n"\
"    seed *= 0x27d4eb2d; \n"\
"    seed = seed ^ (seed >> 15); \n"\
"    return seed; \n"\
"} \n"\
" \n"\
"/// Return random unsigned \n"\
"uint RandUint(Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(1664525U * rng->val + 1013904223U); \n"\
"    return rng->val; \n"\
"} \n"\
" \n"\
"/// Return random float \n"\
"float RandFloat(Rng* rng) \n"\
"{ \n"\
"    return ((float)RandUint(rng)) / 0xffffffffU; \n"\
"} \n"\
" \n"\
"/// Initialize RNG \n"\
"void InitRng(uint seed, Rng* rng) \n"\
"{ \n"\
"    rng->val = WangHash(seed); \n"\
"    for (int i=0;i< 100;++i) \n"\
"        RandFloat(rng); \n"\
"} \n"\
" \n"\
"#endif // RANDOM_CL \n"\
" \n"\
" \n"\
" \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToHemisphere( \n"\
"                        // Sample \n"\
"                        float2 sample, \n"\
"                        // Hemisphere normal \n"\
"                        float3 n, \n"\
"                        // Cos power \n"\
"                        float e \n"\
"                        ) \n"\
"{ \n"\
"    // Construct basis \n"\
"    float3 u = GetOrthoVector(n); \n"\
"    float3 v = cross(u, n); \n"\
"    u = cross(n, v); \n"\
"     \n"\
"    // Calculate 2D sample \n"\
"    float r1 = sample.x; \n"\
"    float r2 = sample.y; \n"\
"     \n"\
"    // Transform to spherical coordinates \n"\
"    float sinpsi = sin(2*PI*r1); \n"\
"    float cospsi = cos(2*PI*r1); \n"\
"    float costheta = pow(1.f - r2, 1.f/(e + 1.f)); \n"\
"    float sintheta = sqrt(1.f - costheta * costheta); \n"\
"     \n"\
"    // Return the result \n"\
"    return normalize(u * sintheta * cospsi + v * sintheta * sinpsi + n * costheta); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDisk( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float r = native_sqrt(sample.x);  \n"\
"    float theta = 2 * PI * sample.y; \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToDiskConcentric( \n"\
"    // Sample \n"\
"    float2 sample \n"\
"    ) \n"\
"{ \n"\
"    float2 offset = 2.f * sample - make_float2(1.f, 1.f); \n"\
" \n"\
"    if (offset.x == 0 && offset.y == 0) return 0.f; \n"\
" \n"\
"    float theta, r; \n"\
" \n"\
"    if (fabs(offset.x) > fabs(offset.y))  \n"\
"    { \n"\
"        r = offset.x; \n"\
"        theta = PI / 4.f * (offset.y / offset.x); \n"\
"    } \n"\
"    else  \n"\
"    { \n"\
"        r = offset.y; \n"\
"        theta = PI / 2.f * ( 1.f - 0.5f * (offset.x / offset.y)); \n"\
"    } \n"\
"     \n"\
"    return make_float2(r * native_cos(theta), r * native_sin(theta)); \n"\
"} \n"\
" \n"\
"/// Sample hemisphere with cos weight \n"\
"float3 Sample_MapToSphere( \n"\
"                        // Sample \n"\
"                        float2 sample \n"\
"                        ) \n"\
"{ \n"\
"    float z = 1.f - 2.f * sample.x; \n"\
"    float r = native_sqrt(max(0.f, 1.f - z*z)); \n"\
"    float phi = 2.f * PI * sample.y; \n"\
"    float x = cos(phi); \n"\
"    float y = sin(phi); \n"\
"     \n"\
"    // Return the result \n"\
"    return make_float3(x,y,z); \n"\
"} \n"\
" \n"\
"float2 Sample_MapToPolygon(int n, float2 sample, float sample1) \n"\
"{ \n"\
"    float theta = 2.f * PI / n; \n"\
" \n"\
"    int edge = clamp((int)(sample1 * n), 0, n - 1); \n"\
" \n"\
"    float t = native_sqrt(sample.x); \n"\
"    float u = 1.f - t; \n"\
"    float v = t * sample.y; \n"\
" \n"\
"    float2 v1 = make_float2(native_cos(theta * edge), native_sin(theta * edge)); \n"\
"    float2 v2 = make_float2(native_cos(theta * (edge + 1)), native_sin(theta * (edge + 1))); \n"\
" \n"\
" \n"\
"    return u*v1 + v*v2;; \n"\
"} \n"\
" \n"\
"/// Power heuristic for multiple importance sampling \n"\
"float PowerHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f*f) / (f*f + g*g); \n"\
"} \n"\
" \n"\
"/// Balance heuristic for multiple importance sampling \n"\
"float BalanceHeuristic(int nf, float fpdf, int ng, float gpdf) \n"\
"{ \n"\
"    float f = nf * fpdf; \n"\
"    float g = ng * gpdf; \n"\
"    return (f) / (f + g); \n"\
"} \n"\
" \n"\
"typedef struct \n"\
"{ \n"\
"    uint seq; \n"\
"    uint s0; \n"\
"    uint s1; \n"\
"    uint s2; \n"\
"} SobolSampler; \n"\
" \n"\
"float2 UniformSampler_Sample2D(Rng* rng) \n"\
"{ \n"\
"    float2 sample; \n"\
"    sample.x = RandFloat(rng); \n"\
"    sample.y = RandFloat(rng); \n"\
"    return sample; \n"\
"} \n"\
" \n"\
"#define MATSIZE 52 \n"\
" \n"\
"// The code is taken from: http://gruenschloss.org/sobol/kuo-2d-proj-single-precision.zip \n"\
"//  \n"\
"float SobolSampler_Sample1D(uint index, uint dimension, uint scramble, __global uint const* mat) \n"\
"{ \n"\
"    uint result = scramble; \n"\
"    for (uint i = dimension * MATSIZE; index; index >>= 1, ++i) \n"\
"    { \n"\
"        if (index & 1) \n"\
"            result ^= mat[i]; \n"\
"    } \n"\
" \n"\
"    return result * (1.f / (1UL << 32)); \n"\
"} \n"\
" \n"\
" \n"\
"#endif // SAMPLING_CL \n"\
;
static const char g_scene_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef SCENE_CL \n"\
"#define SCENE_CL \n"\
" \n"\
" \n"\
"/// Fill DifferentialGeometry structure based on intersection info from RadeonRays \n"\
"void FillDifferentialGeometry(// Scene \n"\
"                              Scene const* scene, \n"\
"                              // RadeonRays intersection \n"\
"                              Intersection const* isect, \n"\
"                              // Differential geometry \n"\
"                              DifferentialGeometry* diffgeo \n"\
"                              ) \n"\
"{ \n"\
"    // Determine shape and polygon \n"\
"    int shapeid = isect->shapeid - 1; \n"\
"    int primid = isect->primid; \n"\
"     \n"\
"    // Get barycentrics \n"\
"    float2 uv = isect->uvwt.xy; \n"\
"     \n"\
"    // Extract shape data \n"\
"    Shape shape = scene->shapes[shapeid]; \n"\
"    //float3 linearvelocity = shape.linearvelocity; \n"\
"    //float4 angularvelocity = shape.angularvelocity; \n"\
"     \n"\
"    // Fetch indices starting from startidx and offset by primid \n"\
"    int i0 = scene->indices[shape.startidx + 3 * primid]; \n"\
"    int i1 = scene->indices[shape.startidx + 3 * primid + 1]; \n"\
"    int i2 = scene->indices[shape.startidx + 3 * primid + 2]; \n"\
"     \n"\
"    // Fetch normals \n"\
"    float3 n0 = scene->normals[shape.startvtx + i0]; \n"\
"    float3 n1 = scene->normals[shape.startvtx + i1]; \n"\
"    float3 n2 = scene->normals[shape.startvtx + i2]; \n"\
"     \n"\
"    // Fetch positions \n"\
"    float3 v0 = scene->vertices[shape.startvtx + i0]; \n"\
"    float3 v1 = scene->vertices[shape.startvtx + i1]; \n"\
"    float3 v2 = scene->vertices[shape.startvtx + i2]; \n"\
"     \n"\
"    // Fetch UVs \n"\
"    float2 uv0 = scene->uvs[shape.startvtx + i0]; \n"\
"    float2 uv1 = scene->uvs[shape.startvtx + i1]; \n"\
"    float2 uv2 = scene->uvs[shape.startvtx + i2]; \n"\
"     \n"\
"    // Calculate barycentric position and normal \n"\
"    diffgeo->n = normalize(transform_vector((1.f - uv.x - uv.y) * n0 + uv.x * n1 + uv.y * n2, shape.m0, shape.m1, shape.m2, shape.m3)); \n"\
"    diffgeo->p = transform_point((1.f - uv.x - uv.y) * v0 + uv.x * v1 + uv.y * v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    diffgeo->uv = (1.f - uv.x - uv.y) * uv0 + uv.x * uv1 + uv.y * uv2; \n"\
"     \n"\
"    // Get material at shading point \n"\
"    int matidx = scene->materialids[shape.startidx / 3 + primid]; \n"\
"    diffgeo->mat = scene->materials[matidx]; \n"\
" \n"\
"    /// From PBRT book \n"\
"    /// Construct tangent basis on the fly and apply normal map \n"\
"    float du1 = uv0.x - uv2.x; \n"\
"    float du2 = uv1.x - uv2.x; \n"\
"    float dv1 = uv0.y - uv2.y; \n"\
"    float dv2 = uv1.y - uv2.y; \n"\
"     \n"\
"    float3 dp1 = v0 - v2; \n"\
"    float3 dp2 = v1 - v2; \n"\
"     \n"\
"    float det = du1 * dv2 - dv1 * du2; \n"\
"     \n"\
"    if (0 && det != 0.f) \n"\
"    { \n"\
"        float invdet = 1.f / det; \n"\
"        diffgeo->dpdu = normalize( (dv2 * dp1 - dv1 * dp2) * invdet ); \n"\
"        diffgeo->dpdv = normalize( (-du2 * dp1 + du1 * dp2) * invdet ); \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        diffgeo->dpdu = normalize(GetOrthoVector(diffgeo->n)); \n"\
"        diffgeo->dpdv = normalize(cross(diffgeo->n, diffgeo->dpdu)); \n"\
"    } \n"\
"     \n"\
"    diffgeo->ng = normalize(cross(diffgeo->dpdv, diffgeo->dpdu)); \n"\
" \n"\
"    //if (dot(diffgeo->ng, diffgeo->n) < 0.f) \n"\
"        //diffgeo->ng = -diffgeo->ng; \n"\
" \n"\
"    // Fix all to be orthogonal \n"\
"    //diffgeo->dpdv = normalize(cross(diffgeo->ng, diffgeo->dpdu)); \n"\
"    //diffgeo->dpdu = normalize(cross(diffgeo->dpdv, diffgeo->ng)); \n"\
" \n"\
"    float3 p0 = transform_point(v0, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    float3 p1 = transform_point(v1, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
"    float3 p2 = transform_point(v2, shape.m0, shape.m1, shape.m2, shape.m3); \n"\
" \n"\
"    diffgeo->area = 0.5f * length(cross(p2 - p0, p2 - p1)); \n"\
"     \n"\
"    // Apply transform & linear motion blur \n"\
"    //v += (linearvelocity * time); \n"\
"    // MT^-1 should be used if scale is present \n"\
"    //n = rotate_vector(n, angularvelocity); \n"\
"} \n"\
" \n"\
"int Scene_SampleLight(Scene const* scene, float sample, float* pdf) \n"\
"{ \n"\
"    int num_lights = scene->num_lights; \n"\
"    int light_idx = clamp((int)(sample * num_lights), 0, num_lights - 1); \n"\
"    *pdf = 1.f / num_lights; \n"\
"    return light_idx; \n"\
"} \n"\
" \n"\
" \n"\
"#endif \n"\
;
static const char g_sh_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
" \n"\
"#define MAX_BAND 2 \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"// Texture description \n"\
"typedef struct _Texture \n"\
"{ \n"\
"    // Texture width, height and depth \n"\
"    int w; \n"\
"    int h; \n"\
"    int d; \n"\
"    // Offset in texture data array \n"\
"    int dataoffset; \n"\
"    int fmt; \n"\
"    int extra; \n"\
"} Texture; \n"\
" \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
" \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
" \n"\
"/// Sample 2D texture described by texture in texturedata pool \n"\
"float3 Sample2D(Texture const* texture, __global char const* texturedata, float2 uv) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = texture->w; \n"\
"    int height = texture->h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + texture->dataoffset; \n"\
" \n"\
"    // Handle wrap \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Figure out integer coordinates \n"\
"    int x = floor(uv.x * width); \n"\
"    int y = floor(uv.y * height); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = min(x + 1, width - 1); \n"\
"    int y1 = min(y + 1, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    if (texture->fmt == RGBA32) \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Get 4 values \n"\
"        float3 valx = *(mydataf + width * y + x); \n"\
" \n"\
"        // Filter and return the result \n"\
"        return valx; \n"\
"    } \n"\
"    else if (texture->fmt == RGBA16) \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        float valx = vload_half(0, mydatah + 4*(width * y + x)); \n"\
"        float valy = vload_half(0, mydatah + 4*(width * y + x) + 1); \n"\
"        float valz = vload_half(0, mydatah + 4*(width * y + x) + 2); \n"\
" \n"\
"        return make_float3(valx, valy, valz); \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        // Get 4 values \n"\
"        uchar4 valx = *(mydatac + width * y + x); \n"\
" \n"\
"        float3 valxf = make_float3((float)valx.x / 255.f, (float)valx.y / 255.f, (float)valx.z / 255.f); \n"\
" \n"\
"        // Filter and return the result \n"\
"        return valxf; \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"void ShEvaluate(float3 p, float* coeffs)  \n"\
"{ \n"\
"                     float fC0, fC1, fS0, fS1, fTmpA, fTmpB, fTmpC; \n"\
"                     float pz2 = p.z * p.z; \n"\
"                     coeffs[0] = 0.2820947917738781f; \n"\
"                     coeffs[2] = 0.4886025119029199f * p.z; \n"\
"                     coeffs[6] = 0.9461746957575601f * pz2 + -0.3153915652525201f; \n"\
"                     fC0 = p.x; \n"\
"                     fS0 = p.y; \n"\
"                     fTmpA = -0.48860251190292f; \n"\
"                     coeffs[3] = fTmpA * fC0; \n"\
"                     coeffs[1] = fTmpA * fS0; \n"\
"                     fTmpB = -1.092548430592079f * p.z; \n"\
"                     coeffs[7] = fTmpB * fC0; \n"\
"                     coeffs[5] = fTmpB * fS0; \n"\
"                     fC1 = p.x*fC0 - p.y*fS0; \n"\
"                     fS1 = p.x*fS0 + p.y*fC0; \n"\
"                     fTmpC = 0.5462742152960395f; \n"\
"                     coeffs[8] = fTmpC * fC1; \n"\
"                     coeffs[4] = fTmpC * fS1; \n"\
"} \n"\
" \n"\
"__attribute__((reqd_work_group_size(8, 8, 1))) \n"\
"///< Project the function represented by lat-long map lmmap to Sh up to lmax band \n"\
"__kernel void ShProject( \n"\
"    __global Texture const* textures, \n"\
"    // Texture data \n"\
"    __global char const* texturedata, \n"\
"    // Environment texture index \n"\
"    int envmapidx, \n"\
"    // Harmonic coefficients flattened: NumShTerms(lmax) * num_groups \n"\
"    __global float3* coeffs \n"\
"    ) \n"\
"{ \n"\
"    // Temporary work area for trigonom results \n"\
"    __local float3 cx[64]; \n"\
" \n"\
"    int x = get_global_id(0); \n"\
"    int y = get_global_id(1); \n"\
" \n"\
"    int xl = get_local_id(0); \n"\
"    int yl = get_local_id(1); \n"\
"    int wl = get_local_size(0); \n"\
" \n"\
"    int ngx = get_num_groups(0); \n"\
"    int gx = get_group_id(0); \n"\
"    int gy = get_group_id(1); \n"\
"    int g = gy * ngx + gx; \n"\
" \n"\
"    int lid = yl * wl + xl; \n"\
" \n"\
"    Texture envmap = textures[envmapidx]; \n"\
"    int w = envmap.w; \n"\
"    int h = envmap.h; \n"\
" \n"\
"    if (x < w && y < h) \n"\
"    { \n"\
"        // Calculate spherical angles \n"\
"        float thetastep = PI / h; \n"\
"        float phistep = 2.f*PI / w; \n"\
"        float theta0 = 0;//PI / h / 2.f; \n"\
"        float phi0 = 0;//2.f*PI / w / 2.f; \n"\
" \n"\
"        float phi = phi0 + x * phistep; \n"\
"        float theta = theta0 + y * thetastep; \n"\
" \n"\
"        float2 uv; \n"\
"        uv.x = (float)x/w; \n"\
"        uv.y = 1.f - (float)y/h; \n"\
"        float3 le = 3.f * Sample2D(&envmap, texturedata, uv); \n"\
" \n"\
"        float sinphi = sin(phi); \n"\
"        float cosphi = cos(phi); \n"\
"        float costheta = cos(theta); \n"\
"        float sintheta = sin(theta); \n"\
" \n"\
"        // Construct point on unit sphere \n"\
"        float3 p = normalize(make_float3(sintheta * cosphi, costheta, sintheta * sinphi)); \n"\
" \n"\
"        // Evaluate SH functions at w up to lmax band \n"\
"        float ylm[9]; \n"\
"        ShEvaluate(p, ylm); \n"\
" \n"\
"        // Evaluate Riemann sum \n"\
"        for (int i = 0; i < 9; ++i) \n"\
"        { \n"\
"            // Calculate the coefficient into local memory \n"\
"             cx[lid] = le * ylm[i] * sintheta * (PI / h) * (2.f * PI / w); \n"\
" \n"\
"             barrier(CLK_LOCAL_MEM_FENCE); \n"\
" \n"\
"             // Reduce the coefficient to get the resulting one \n"\
"             for (int stride = 1; stride <= (64 >> 1); stride <<= 1) \n"\
"             { \n"\
"                 if (lid < 64/(2*stride)) \n"\
"                 { \n"\
"                     cx[2*(lid + 1)*stride-1] = cx[2*(lid + 1)*stride-1] + cx[(2*lid + 1)*stride-1]; \n"\
"                 } \n"\
" \n"\
"                 barrier(CLK_LOCAL_MEM_FENCE); \n"\
"             } \n"\
" \n"\
"             // Put the coefficient into global memory \n"\
"             if (lid == 0) \n"\
"             { \n"\
"                coeffs[g * 9 + i] = cx[63]; \n"\
"             } \n"\
" \n"\
"             barrier(CLK_LOCAL_MEM_FENCE); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"__attribute__((reqd_work_group_size(8, 8, 1))) \n"\
"///< Project the function represented by lat-long map lmmap to Sh up to lmax band \n"\
"__kernel void ShProjectHemisphericalProbe( \n"\
"    __global Texture const* textures, \n"\
"    // Texture data \n"\
"    __global char const* texturedata, \n"\
"    // Environment texture index \n"\
"    int envmapidx, \n"\
"    // Harmonic coefficients flattened: NumShTerms(lmax) * num_groups \n"\
"    __global float3* coeffs \n"\
"    ) \n"\
"{ \n"\
"    // Temporary work area for trigonom results \n"\
"    __local float3 cx[64]; \n"\
" \n"\
"    int x = get_global_id(0); \n"\
"    int y = get_global_id(1); \n"\
" \n"\
"    int xl = get_local_id(0); \n"\
"    int yl = get_local_id(1); \n"\
"    int wl = get_local_size(0); \n"\
" \n"\
"    int ngx = get_num_groups(0); \n"\
"    int gx = get_group_id(0); \n"\
"    int gy = get_group_id(1); \n"\
"    int g = gy * ngx + gx; \n"\
" \n"\
"    int lid = yl * wl + xl; \n"\
" \n"\
"    Texture envmap = textures[envmapidx]; \n"\
"    int w = envmap.w; \n"\
"    int h = envmap.h; \n"\
" \n"\
"    if (x < w && y < h) \n"\
"    { \n"\
"        // Calculate spherical angles \n"\
"        float thetastep = PI / h; \n"\
"        float phistep = 2.f*PI / w; \n"\
"        float theta0 = 0;//PI / h / 2.f; \n"\
"        float phi0 = 0;//2.f*PI / w / 2.f; \n"\
" \n"\
"        float phi = phi0 + x * phistep; \n"\
"        float theta = theta0 + y * thetastep; \n"\
" \n"\
"        float sinphi = sin(phi); \n"\
"        float cosphi = cos(phi); \n"\
"        float costheta = cos(theta); \n"\
"        float sintheta = sin(theta); \n"\
" \n"\
"        // Construct point on unit sphere \n"\
"        float3 p = normalize(make_float3(sintheta * cosphi, costheta, sintheta * sinphi)); \n"\
" \n"\
"        float envmapaspect = (float)envmap.h / envmap.w; \n"\
"        float2 uv = p.xz; \n"\
"        uv.y = 0.5f*uv.y + 0.5f; \n"\
"        uv.x = 0.5f*uv.x + 0.5f; \n"\
"        uv.x = (1.f - envmapaspect) * 0.5f + uv.x * envmapaspect; \n"\
" \n"\
"        //uv.x = (float)x/w; \n"\
"        //uv.y = 1.f - (float)y/h; \n"\
"        float3 le = Sample2D(&envmap, texturedata, uv); \n"\
" \n"\
"        // Evaluate SH functions at w up to lmax band \n"\
"        float ylm[9]; \n"\
"        ShEvaluate(p, ylm); \n"\
" \n"\
"        // Evaluate Riemann sum \n"\
"        for (int i = 0; i < 9; ++i) \n"\
"        { \n"\
"            // Calculate the coefficient into local memory \n"\
"             cx[lid] = le * ylm[i] * sintheta * (PI / h) * (2.f * PI / w); \n"\
" \n"\
"             barrier(CLK_LOCAL_MEM_FENCE); \n"\
" \n"\
"             // Reduce the coefficient to get the resulting one \n"\
"             for (int stride = 1; stride <= (64 >> 1); stride <<= 1) \n"\
"             { \n"\
"                 if (lid < 64/(2*stride)) \n"\
"                 { \n"\
"                     cx[2*(lid + 1)*stride-1] = cx[2*(lid + 1)*stride-1] + cx[(2*lid + 1)*stride-1]; \n"\
"                 } \n"\
" \n"\
"                 barrier(CLK_LOCAL_MEM_FENCE); \n"\
"             } \n"\
" \n"\
"             // Put the coefficient into global memory \n"\
"             if (lid == 0) \n"\
"             { \n"\
"                coeffs[g * 9 + i] = cx[63]; \n"\
"             } \n"\
" \n"\
"             barrier(CLK_LOCAL_MEM_FENCE); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
"#define GROUP_SIZE 256 \n"\
"__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \n"\
"__kernel void ShReduce( \n"\
"    // Harmonic coefficients flattened: NumShTerms(lmax) * num_groups \n"\
"    const __global float3* coeffs, \n"\
"    // Number of sets \n"\
"    int numsets, \n"\
"    // Resulting coeffs \n"\
"    __global float3* result \n"\
"    ) \n"\
"{ \n"\
"    __local float3 lds[GROUP_SIZE]; \n"\
" \n"\
"    int gid = get_global_id(0); \n"\
"    int lid = get_global_id(0); \n"\
" \n"\
"    // How many items to reduce for a single work item \n"\
"    int numprivate = numsets / GROUP_SIZE; \n"\
" \n"\
"    for (int i=0;i<9;++i) \n"\
"    { \n"\
"        float3 res = {0,0,0}; \n"\
" \n"\
"        // Private reduction \n"\
"        for (int j=0;j<numprivate;++j) \n"\
"        { \n"\
"            res += coeffs[gid * numprivate * 9 + j * 9 + i]; \n"\
"        } \n"\
" \n"\
"        // LDS reduction \n"\
"        lds[lid] = res; \n"\
" \n"\
"        barrier (CLK_LOCAL_MEM_FENCE); \n"\
" \n"\
"        // Work group reduction \n"\
"        for (int stride = 1; stride <= (256 >> 1); stride <<= 1) \n"\
"        { \n"\
"            if (lid < GROUP_SIZE/(2*stride)) \n"\
"            { \n"\
"                lds[2*(lid + 1)*stride-1] = lds[2*(lid + 1)*stride-1] + lds[(2*lid + 1)*stride-1]; \n"\
"            } \n"\
" \n"\
"            barrier (CLK_LOCAL_MEM_FENCE); \n"\
"        } \n"\
" \n"\
"        // Write final result \n"\
"        if (lid == 0) \n"\
"        { \n"\
"            result[i] = lds[GROUP_SIZE-1]; \n"\
"        } \n"\
" \n"\
"        barrier (CLK_LOCAL_MEM_FENCE); \n"\
"    } \n"\
"} \n"\
"#undef GROUP_SIZE \n"\
" \n"\
" \n"\
"__attribute__((reqd_work_group_size(8, 8, 1))) \n"\
"__kernel void ShReconstructLmmap( \n"\
"    // SH coefficients: NumShTerms(lmax) items \n"\
"    const __global float3* coeffs, \n"\
"    // Resulting image width \n"\
"    int w, \n"\
"    // Resulting image height \n"\
"    int h, \n"\
"    // Resulting image \n"\
"    __global float3* lmmap \n"\
"    ) \n"\
"{ \n"\
"    int x = get_global_id(0); \n"\
"    int y = get_global_id(1); \n"\
" \n"\
"    int xl = get_local_id(0); \n"\
"    int yl = get_local_id(1); \n"\
"    int wl = get_local_size(0); \n"\
" \n"\
"    int ngx = get_num_groups(0); \n"\
"    int gx = get_group_id(0); \n"\
"    int gy = get_group_id(1); \n"\
" \n"\
"    if (x < w && y < h) \n"\
"    { \n"\
"        // Calculate spherical angles \n"\
"        float thetastep = M_PI / h; \n"\
"        float phistep = 2.f*M_PI / w; \n"\
"        float theta0 = 0;//M_PI / h / 2.f; \n"\
"        float phi0 = 0;//2.f*M_PI / w / 2.f; \n"\
" \n"\
"        float phi = phi0 + x * phistep; \n"\
"        float theta = theta0 + y * thetastep; \n"\
" \n"\
"        float2 uv; \n"\
"        uv.x = (float)x/w; \n"\
"        uv.y = (float)y/h; \n"\
" \n"\
"        float sinphi = sin(phi); \n"\
"        float cosphi = cos(phi); \n"\
"        float costheta = cos(theta); \n"\
"        float sintheta = sin(theta); \n"\
" \n"\
"        // Construct point on unit sphere \n"\
"        float3 p = normalize(make_float3(sintheta * cosphi, costheta, sintheta * sinphi)); \n"\
" \n"\
"        // Evaluate SH functions at w up to lmax band \n"\
"        float ylm[9]; \n"\
"        ShEvaluate(p, ylm); \n"\
" \n"\
"        // Evaluate Riemann sum \n"\
"        float3 val = {0, 0, 0}; \n"\
"        for (int i = 0; i < 9; ++i) \n"\
"        { \n"\
"            // Calculate the coefficient into local memory \n"\
"             val += ylm[i] * coeffs[i]; \n"\
"        } \n"\
" \n"\
"        int x = floor(uv.x * w); \n"\
"        int y = floor(uv.y * h); \n"\
" \n"\
"        lmmap[w * y + x] = val; \n"\
"    } \n"\
"} \n"\
;
static const char g_texture_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef TEXTURE_CL \n"\
"#define TEXTURE_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
" \n"\
"/// Supported formats \n"\
"enum TextureFormat \n"\
"{ \n"\
"    UNKNOWN, \n"\
"    RGBA8, \n"\
"    RGBA16, \n"\
"    RGBA32 \n"\
"}; \n"\
" \n"\
"/// Texture description \n"\
"typedef \n"\
"    struct _Texture \n"\
"    { \n"\
"        // Width, height and depth \n"\
"        int w; \n"\
"        int h; \n"\
"        int d; \n"\
"        // Offset in texture data array \n"\
"        int dataoffset; \n"\
"        // Format \n"\
"        int fmt; \n"\
"        int extra; \n"\
"    } Texture; \n"\
" \n"\
"/// To simplify a bit \n"\
"#define TEXTURE_ARG_LIST __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARG_LIST_IDX(x) int x, __global Texture const* textures, __global char const* texturedata \n"\
"#define TEXTURE_ARGS textures, texturedata \n"\
"#define TEXTURE_ARGS_IDX(x) x, textures, texturedata \n"\
" \n"\
"/// Sample 2D texture \n"\
"float4 Texture_Sample2D(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int x0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int y0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    // Calculate samples for linear filtering \n"\
"    int x1 = clamp(x0 + 1, 0,  width - 1); \n"\
"    int y1 = clamp(y0 + 1, 0, height - 1); \n"\
" \n"\
"    // Calculate weights for linear filtering \n"\
"    float wx = uv.x * width - floor(uv.x * width); \n"\
"    float wy = uv.y * height - floor(uv.y * height); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"        case RGBA32: \n"\
"        { \n"\
"            __global float4 const* mydataf = (__global float4 const*)mydata; \n"\
" \n"\
"            // Get 4 values for linear filtering \n"\
"            float4 val00 = *(mydataf + width * y0 + x0); \n"\
"            float4 val01 = *(mydataf + width * y0 + x1); \n"\
"            float4 val10 = *(mydataf + width * y1 + x0); \n"\
"            float4 val11 = *(mydataf + width * y1 + x1); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA16: \n"\
"        { \n"\
"            __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"            // Get 4 values \n"\
"            float4 val00 = vload_half4(width * y0 + x0, mydatah); \n"\
"            float4 val01 = vload_half4(width * y0 + x1, mydatah); \n"\
"            float4 val10 = vload_half4(width * y1 + x0, mydatah); \n"\
"            float4 val11 = vload_half4(width * y1 + x1, mydatah); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        case RGBA8: \n"\
"        { \n"\
"            __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"            // Get 4 values and convert to float \n"\
"            uchar4 valu00 = *(mydatac + width * y0 + x0); \n"\
"            uchar4 valu01 = *(mydatac + width * y0 + x1); \n"\
"            uchar4 valu10 = *(mydatac + width * y1 + x0); \n"\
"            uchar4 valu11 = *(mydatac + width * y1 + x1); \n"\
" \n"\
"            float4 val00 = make_float4((float)valu00.x / 255.f, (float)valu00.y / 255.f, (float)valu00.z / 255.f, (float)valu00.w / 255.f); \n"\
"            float4 val01 = make_float4((float)valu01.x / 255.f, (float)valu01.y / 255.f, (float)valu01.z / 255.f, (float)valu01.w / 255.f); \n"\
"            float4 val10 = make_float4((float)valu10.x / 255.f, (float)valu10.y / 255.f, (float)valu10.z / 255.f, (float)valu10.w / 255.f); \n"\
"            float4 val11 = make_float4((float)valu11.x / 255.f, (float)valu11.y / 255.f, (float)valu11.z / 255.f, (float)valu11.w / 255.f); \n"\
" \n"\
"            // Filter and return the result \n"\
"            return lerp(lerp(val00, val01, wx), lerp(val10, val11, wx), wy); \n"\
"        } \n"\
" \n"\
"        default: \n"\
"        { \n"\
"            return make_float4(0.f, 0.f, 0.f, 0.f); \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Sample lattitue-longitude environment map using 3d vector \n"\
"float3 Texture_SampleEnvMap(float3 d, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Transform to spherical coords \n"\
"    float r, phi, theta; \n"\
"    CartesianToSpherical(d, &r, &phi, &theta); \n"\
" \n"\
"    // Map to [0,1]x[0,1] range and reverse Y axis \n"\
"    float2 uv; \n"\
"    uv.x = phi / (2*PI); \n"\
"    uv.y = 1.f - theta / PI; \n"\
" \n"\
"    // Sample the texture \n"\
"    return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float3 Texture_GetValue3f( \n"\
"                // Value \n"\
"                float3 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).xyz, 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float4 Texture_GetValue4f( \n"\
"                // Value \n"\
"                float4 v, \n"\
"                // Texture coordinate \n"\
"                float2 uv, \n"\
"                // Texture args \n"\
"                TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return native_powr(Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)), 2.2f); \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Get data from parameter value or texture \n"\
"float Texture_GetValue1f( \n"\
"                        // Value \n"\
"                        float v, \n"\
"                        // Texture coordinate \n"\
"                        float2 uv, \n"\
"                        // Texture args \n"\
"                        TEXTURE_ARG_LIST_IDX(texidx) \n"\
"                        ) \n"\
"{ \n"\
"    // If texture present sample from texture \n"\
"    if (texidx != -1) \n"\
"    { \n"\
"        // Sample texture \n"\
"        return Texture_Sample2D(uv, TEXTURE_ARGS_IDX(texidx)).x; \n"\
"    } \n"\
" \n"\
"    // Return fixed color otherwise \n"\
"    return v; \n"\
"} \n"\
" \n"\
"/// Sample 2D texture \n"\
"float3 Texture_SampleBump(float2 uv, TEXTURE_ARG_LIST_IDX(texidx)) \n"\
"{ \n"\
"    // Get width and height \n"\
"    int width = textures[texidx].w; \n"\
"    int height = textures[texidx].h; \n"\
" \n"\
"    // Find the origin of the data in the pool \n"\
"    __global char const* mydata = texturedata + textures[texidx].dataoffset; \n"\
" \n"\
"    // Handle UV wrap \n"\
"    // TODO: need UV mode support \n"\
"    uv -= floor(uv); \n"\
" \n"\
"    // Reverse Y: \n"\
"    // it is needed as textures are loaded with Y axis going top to down \n"\
"    // and our axis goes from down to top \n"\
"    uv.y = 1.f - uv.y; \n"\
" \n"\
"    // Calculate integer coordinates \n"\
"    int s0 = clamp((int)floor(uv.x * width), 0, width - 1); \n"\
"    int t0 = clamp((int)floor(uv.y * height), 0, height - 1); \n"\
" \n"\
"    switch (textures[texidx].fmt) \n"\
"    { \n"\
"    case RGBA32: \n"\
"    { \n"\
"        __global float3 const* mydataf = (__global float3 const*)mydata; \n"\
" \n"\
"        // Sobel filter \n"\
"        const float tex00 = (*(mydataf + width * (t0 - 1) + (s0-1))).x; \n"\
"        const float tex10 = (*(mydataf + width * (t0 - 1) + (s0))).x; \n"\
"        const float tex20 = (*(mydataf + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex01 = (*(mydataf + width * (t0) + (s0 - 1))).x; \n"\
"        const float tex21 = (*(mydataf + width * (t0) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex02 = (*(mydataf + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const float tex12 = (*(mydataf + width * (t0 + 1) + (s0))).x; \n"\
"        const float tex22 = (*(mydataf + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA16: \n"\
"    { \n"\
"        __global half const* mydatah = (__global half const*)mydata; \n"\
" \n"\
"        const float tex00 = vload_half4(width * (t0 - 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex10 = vload_half4(width * (t0 - 1) + (s0), mydatah).x; \n"\
"        const float tex20 = vload_half4(width * (t0 - 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex01 = vload_half4(width * (t0)+(s0 - 1), mydatah).x; \n"\
"        const float tex21 = vload_half4(width * (t0)+(s0 + 1), mydatah).x; \n"\
" \n"\
"        const float tex02 = vload_half4(width * (t0 + 1) + (s0 - 1), mydatah).x; \n"\
"        const float tex12 = vload_half4(width * (t0 + 1) + (s0), mydatah).x; \n"\
"        const float tex22 = vload_half4(width * (t0 + 1) + (s0 + 1), mydatah).x; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    case RGBA8: \n"\
"    { \n"\
"        __global uchar4 const* mydatac = (__global uchar4 const*)mydata; \n"\
" \n"\
"        const uchar utex00 = (*(mydatac + width * (t0 - 1) + (s0 - 1))).x; \n"\
"        const uchar utex10 = (*(mydatac + width * (t0 - 1) + (s0))).x; \n"\
"        const uchar utex20 = (*(mydatac + width * (t0 - 1) + (s0 + 1))).x; \n"\
" \n"\
"        const uchar utex01 = (*(mydatac + width * (t0)+(s0 - 1))).x; \n"\
"        const uchar utex21 = (*(mydatac + width * (t0)+(s0 + 1))).x; \n"\
" \n"\
"        const uchar utex02 = (*(mydatac + width * (t0 + 1) + (s0 - 1))).x; \n"\
"        const uchar utex12 = (*(mydatac + width * (t0 + 1) + (s0))).x; \n"\
"        const uchar utex22 = (*(mydatac + width * (t0 + 1) + (s0 + 1))).x; \n"\
" \n"\
"        const float tex00 = (float)utex00 / 255.f; \n"\
"        const float tex10 = (float)utex10 / 255.f; \n"\
"        const float tex20 = (float)utex20 / 255.f; \n"\
" \n"\
"        const float tex01 = (float)utex01 / 255.f; \n"\
"        const float tex21 = (float)utex21 / 255.f; \n"\
" \n"\
"        const float tex02 = (float)utex02 / 255.f; \n"\
"        const float tex12 = (float)utex12 / 255.f; \n"\
"        const float tex22 = (float)utex22 / 255.f; \n"\
" \n"\
"        const float Gx = tex00 - tex20 + 2.0f * tex01 - 2.0f * tex21 + tex02 - tex22; \n"\
"        const float Gy = tex00 + 2.0f * tex10 + tex20 - tex02 - 2.0f * tex12 - tex22; \n"\
"        const float3 n = make_float3(Gx, Gy, 1.f); \n"\
" \n"\
"        return 0.5f * normalize(n) + make_float3(0.5f, 0.5f, 0.5f); \n"\
"    } \n"\
" \n"\
"    default: \n"\
"    { \n"\
"        return make_float3(0.f, 0.f, 0.f); \n"\
"    } \n"\
"    } \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // TEXTURE_CL \n"\
;
static const char g_utils_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef UTILS_CL \n"\
"#define UTILS_CL \n"\
" \n"\
"#define PI 3.14159265358979323846f \n"\
" \n"\
"// 2D distribution function \n"\
"typedef struct __Distribution2D \n"\
"{ \n"\
"    int w; \n"\
"    int h; \n"\
"    __global float const* data; \n"\
"} Distribution2D; \n"\
" \n"\
"#ifndef APPLE \n"\
"/// These functions are defined on OSX already \n"\
"float4 make_float4(float x, float y, float z, float w) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    res.w = w; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float3 make_float3(float x, float y, float z) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    res.z = z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"float2 make_float2(float x, float y) \n"\
"{ \n"\
"    float2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"int2 make_int2(int x, int y) \n"\
"{ \n"\
"    int2 res; \n"\
"    res.x = x; \n"\
"    res.y = y; \n"\
"    return res; \n"\
"} \n"\
"#endif \n"\
" \n"\
" \n"\
"/// Transform point with transformation matrix. \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Transform vector with transformation matrix (no translation involved) \n"\
"/// m0...m3 are matrix rows \n"\
"float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n"\
"{ \n"\
"    float3 res; \n"\
"    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n"\
"    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n"\
"    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Multiply two quaternions \n"\
"float4 quaternion_mul(float4 q1, float4 q2) \n"\
"{ \n"\
"    float4 res; \n"\
"    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n"\
"    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n"\
"    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n"\
"    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n"\
"    return res; \n"\
"} \n"\
" \n"\
"/// Calculate conjugate quaternion \n"\
"float4 quaternion_conjugate(float4 q) \n"\
"{ \n"\
"    return make_float4(-q.x, -q.y, -q.z, q.w); \n"\
"} \n"\
" \n"\
" \n"\
"/// Inverse quaternion \n"\
"float4 quaternion_inverse(float4 q) \n"\
"{ \n"\
"    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n"\
" \n"\
"    /// Check if it is singular \n"\
"    if (sqnorm != 0.f) \n"\
"    { \n"\
"        return quaternion_conjugate(q) / sqnorm; \n"\
"    } \n"\
"    else \n"\
"    { \n"\
"        return make_float4(0.f, 0.f, 0.f, 1.f); \n"\
"    } \n"\
"} \n"\
" \n"\
"/// Rotate a vector using quaternion \n"\
"float3 rotate_vector(float3 v, float4 q) \n"\
"{ \n"\
"    // The formula is v' = q * v * q_inv; \n"\
"    float4 qinv = quaternion_inverse(q); \n"\
"    float4 vv = make_float4(v.x, v.y, v.z, 0); \n"\
"    return quaternion_mul(q, quaternion_mul(vv, qinv)).xyz; \n"\
"} \n"\
" \n"\
"/// Linearly interpolate between two values \n"\
"float4 lerp(float4 a, float4 b, float w) \n"\
"{ \n"\
"    return a + w*(b-a); \n"\
"} \n"\
" \n"\
"/// Translate cartesian coordinates to spherical system \n"\
"void CartesianToSpherical ( float3 cart, float* r, float* phi, float* theta ) \n"\
"{ \n"\
"    float temp = atan2(cart.x, cart.z); \n"\
"    *r = sqrt(cart.x*cart.x + cart.y*cart.y + cart.z*cart.z); \n"\
"    // Account for discontinuity \n"\
"    *phi = (float)((temp >= 0)?temp:(temp + 2*PI)); \n"\
"    *theta = acos(cart.y/ *r); \n"\
"} \n"\
" \n"\
"/// Get vector orthogonal to a given one \n"\
"float3 GetOrthoVector(float3 n) \n"\
"{ \n"\
"    float3 p; \n"\
" \n"\
"    if (fabs(n.z) > 0.f) { \n"\
"        float k = sqrt(n.y*n.y + n.z*n.z); \n"\
"        p.x = 0; p.y = -n.z/k; p.z = n.y/k; \n"\
"    } \n"\
"    else { \n"\
"        float k = sqrt(n.x*n.x + n.y*n.y); \n"\
"        p.x = n.y/k; p.y = -n.x/k; p.z = 0; \n"\
"    } \n"\
" \n"\
"    return normalize(p); \n"\
"} \n"\
" \n"\
"float2 Distribution2D_Sample(Distribution2D const* dist, float2 sample, float* pdf) \n"\
"{ \n"\
"    return make_float2(0.f, 0.f); \n"\
"} \n"\
" \n"\
"float Distribution2D_GetPdf(Distribution2D const* dist, float2 sample) \n"\
"{ \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"uint upper_power_of_two(uint v) \n"\
"{ \n"\
"    v--; \n"\
"    v |= v >> 1; \n"\
"    v |= v >> 2; \n"\
"    v |= v >> 4; \n"\
"    v |= v >> 8; \n"\
"    v |= v >> 16; \n"\
"    v++; \n"\
"    return v; \n"\
"} \n"\
" \n"\
" \n"\
"#endif // UTILS_CL \n"\
;
static const char g_volumetrics_opencl[]= \
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef VOLUMETRICS_CL \n"\
"#define VOLUMETRICS_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PATH_CL \n"\
"#define PATH_CL \n"\
" \n"\
"/********************************************************************** \n"\
"Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n"\
" \n"\
"Permission is hereby granted, free of charge, to any person obtaining a copy \n"\
"of this software and associated documentation files (the \"Software\"), to deal \n"\
"in the Software without restriction, including without limitation the rights \n"\
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"\
"copies of the Software, and to permit persons to whom the Software is \n"\
"furnished to do so, subject to the following conditions: \n"\
" \n"\
"The above copyright notice and this permission notice shall be included in \n"\
"all copies or substantial portions of the Software. \n"\
" \n"\
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"\
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"\
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \n"\
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"\
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"\
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n"\
"THE SOFTWARE. \n"\
"********************************************************************/ \n"\
"#ifndef PAYLOAD_CL \n"\
"#define PAYLOAD_CL \n"\
"//#define SOBOL \n"\
"#define MULTISCATTER \n"\
" \n"\
"/// Ray descriptor \n"\
"typedef struct _ray \n"\
"{ \n"\
"    /// xyz - origin, w - max range \n"\
"    float4 o; \n"\
"    /// xyz - direction, w - time \n"\
"    float4 d; \n"\
"    /// x - ray mask, y - activity flag \n"\
"    int2 extra; \n"\
"    float2 padding; \n"\
"} ray; \n"\
" \n"\
"/// Intersection data returned by RadeonRays \n"\
"typedef struct _Intersection \n"\
"{ \n"\
"    // id of a shape \n"\
"    int shapeid; \n"\
"    // Primitive index \n"\
"    int primid; \n"\
"    // Padding elements \n"\
"    int padding0; \n"\
"    int padding1; \n"\
" \n"\
"    // uv - hit barycentrics, w - ray distance \n"\
"    float4 uvwt; \n"\
"} Intersection; \n"\
" \n"\
"// Shape description \n"\
"typedef struct _Shape \n"\
"{ \n"\
"    // Shape starting index \n"\
"    int startidx; \n"\
"    // Number of primitives in the shape \n"\
"    int numprims; \n"\
"    // Start vertex \n"\
"    int startvtx; \n"\
"    // Number of vertices \n"\
"    int numvertices; \n"\
"    // Linear motion vector \n"\
"    float3 linearvelocity; \n"\
"    // Angular velocity \n"\
"    float4 angularvelocity; \n"\
"    // Transform in row major format \n"\
"    float4 m0; \n"\
"    float4 m1; \n"\
"    float4 m2; \n"\
"    float4 m3; \n"\
"} Shape; \n"\
" \n"\
"// Emissive object \n"\
"typedef struct _Emissive \n"\
"{ \n"\
"    // Shape index \n"\
"    int shapeidx; \n"\
"    // Polygon index \n"\
"    int primidx; \n"\
"    // Material index \n"\
"    int m; \n"\
"    // \n"\
"    int padding; \n"\
"} Emissive; \n"\
" \n"\
" \n"\
"typedef enum _PathFlags \n"\
"{ \n"\
"    kNone = 0x0, \n"\
"    kKilled = 0x1, \n"\
"    kScattered = 0x2, \n"\
"    kSpecularBounce = 0x4 \n"\
"} PathFlags; \n"\
" \n"\
"// Material description \n"\
"typedef struct _Material \n"\
"{ \n"\
"    // Color: can be diffuse, specular, whatever... \n"\
"    float4 kx; \n"\
"    // Refractive index \n"\
"    float  ni; \n"\
"    // Context dependent parameter: glossiness, etc \n"\
"    float  ns; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Color map index \n"\
"        int kxmapidx; \n"\
"        int brdftopidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Normal map index \n"\
"        int nmapidx; \n"\
"        int brdfbaseidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Parameter map idx \n"\
"        int nsmapidx; \n"\
"    }; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // PDF \n"\
"        float fresnel; \n"\
"    }; \n"\
" \n"\
"    int type; \n"\
"    int twosided; \n"\
" \n"\
"} Material; \n"\
" \n"\
" \n"\
"enum LightType \n"\
"{ \n"\
"    kPoint = 0x1, \n"\
"    kDirectional, \n"\
"    kSpot, \n"\
"    kArea, \n"\
"    kIbl \n"\
"}; \n"\
" \n"\
"typedef struct _Light \n"\
"{ \n"\
"    int type; \n"\
" \n"\
"    union \n"\
"    { \n"\
"        // Area light \n"\
"        struct \n"\
"        { \n"\
"            int shapeidx; \n"\
"            int primidx; \n"\
"            int matidx; \n"\
"        }; \n"\
" \n"\
"        // IBL \n"\
"        struct \n"\
"        { \n"\
"            int tex; \n"\
"            int texdiffuse; \n"\
"            float multiplier; \n"\
"        }; \n"\
"         \n"\
"         \n"\
"        // Spot \n"\
"        struct \n"\
"        { \n"\
"            float ia; \n"\
"            float oa; \n"\
"            float f; \n"\
"        }; \n"\
"    }; \n"\
" \n"\
"    float3 p; \n"\
"    float3 d; \n"\
"    float3 intensity; \n"\
"} Light; \n"\
" \n"\
"typedef struct _Scene \n"\
"{ \n"\
"    // Vertices \n"\
"    __global float3 const* vertices; \n"\
"    // Normals \n"\
"    __global float3 const* normals; \n"\
"    // UVs \n"\
"    __global float2 const* uvs; \n"\
"    // Indices \n"\
"    __global int const* indices; \n"\
"    // Shapes \n"\
"    __global Shape const* shapes; \n"\
"    // Material IDs \n"\
"    __global int const* materialids; \n"\
"    // Materials \n"\
"    __global Material const* materials; \n"\
"    // Emissive objects \n"\
"    __global Light const* lights; \n"\
"    // Envmap idx \n"\
"    int envmapidx; \n"\
"    // Envmap multiplier \n"\
"    float envmapmul; \n"\
"    // Number of emissive objects \n"\
"    int num_lights; \n"\
"} Scene; \n"\
" \n"\
"// Hit data \n"\
"typedef struct _DifferentialGeometry \n"\
"{ \n"\
"    // World space position \n"\
"    float3 p; \n"\
"    // Shading normal \n"\
"    float3 n; \n"\
"    // Geo normal \n"\
"    float3 ng; \n"\
"    // UVs \n"\
"    float2 uv; \n"\
"    // Derivatives \n"\
"    float3 dpdu; \n"\
"    float3 dpdv; \n"\
"    float  area; \n"\
"    // Material \n"\
"    Material mat; \n"\
"} DifferentialGeometry; \n"\
" \n"\
" \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kPixelX = 0, \n"\
"    kPixelY = 1, \n"\
"    kLensX = 2, \n"\
"    kLensY = 3, \n"\
"    kPathBase = 4, \n"\
"    kBrdf = 0, \n"\
"    kLight = 1, \n"\
"    kLightU = 2, \n"\
"    kLightV = 3, \n"\
"    kBrdfU = 4, \n"\
"    kBrdfV = 5, \n"\
"    kIndirectU = 6, \n"\
"    kIndirectV = 7, \n"\
"    kRR = 8, \n"\
"    kVolume = 9, \n"\
"    kVolumeLight = 10, \n"\
"    kVolumeLightU = 11, \n"\
"    kVolumeLightV = 12, \n"\
"    kMaterial = 13, \n"\
"#ifdef MULTISCATTER \n"\
"    kVolumeIndirectU = 14, \n"\
"    kVolumeIndirectV = 15, \n"\
"    kNumPerBounce = 16, \n"\
"#else \n"\
"    kNumPerBounce = 14 \n"\
"#endif \n"\
"}  SampleDim; \n"\
" \n"\
"int GetSampleDim(int pass, SampleDim dim) \n"\
"{ \n"\
"    return kPathBase + pass * kNumPerBounce + dim; \n"\
"} \n"\
" \n"\
"float Intersection_GetDistance(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.w; \n"\
"} \n"\
" \n"\
"float2 Intersection_GetBarycentrics(__global Intersection const* isect) \n"\
"{ \n"\
"    return isect->uvwt.xy; \n"\
"} \n"\
" \n"\
"void Ray_SetInactive(__global ray* r) \n"\
"{ \n"\
"    r->extra.y = 0; \n"\
"} \n"\
" \n"\
"void Ray_SetExtra(__global ray* r, float2 extra) \n"\
"{ \n"\
"    r->padding = extra; \n"\
"} \n"\
" \n"\
"float2 Ray_GetExtra(__global ray const* r) \n"\
"{ \n"\
"    return r->padding; \n"\
"} \n"\
" \n"\
"void Ray_Init(__global ray* r, float3 o, float3 d, float maxt, float time, int mask) \n"\
"{ \n"\
"    // TODO: Check if it generates MTBUF_XYZW write \n"\
"    r->o.xyz = o; \n"\
"    r->d.xyz = d; \n"\
"    r->o.w = maxt; \n"\
"    r->d.w = time; \n"\
"    r->extra.x = mask; \n"\
"    r->extra.y = 0xFFFFFFFF; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif // PAYLOAD_CL \n"\
" \n"\
"typedef struct _Path \n"\
"{ \n"\
"    float3 throughput; \n"\
"    int volume; \n"\
"    int flags; \n"\
"    int active; \n"\
"    int extra1; \n"\
"} Path; \n"\
" \n"\
"bool Path_IsScattered(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kScattered; \n"\
"} \n"\
" \n"\
"bool Path_IsSpecular(__global Path const* path) \n"\
"{ \n"\
"    return path->flags & kSpecularBounce; \n"\
"} \n"\
" \n"\
"bool Path_IsAlive(__global Path const* path) \n"\
"{ \n"\
"    return ((path->flags & kKilled) == 0); \n"\
"} \n"\
" \n"\
"void Path_ClearScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kScattered; \n"\
"} \n"\
" \n"\
"void Path_SetScatterFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kScattered; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_ClearSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags &= ~kSpecularBounce; \n"\
"} \n"\
" \n"\
"void Path_SetSpecularFlag(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kSpecularBounce; \n"\
"} \n"\
" \n"\
" \n"\
"void Path_Restart(__global Path* path) \n"\
"{ \n"\
"    path->flags = 0; \n"\
"} \n"\
" \n"\
"int Path_GetVolumeIdx(__global Path const* path) \n"\
"{ \n"\
"    return path->volume; \n"\
"} \n"\
" \n"\
"float3 Path_GetThroughput(__global Path const* path) \n"\
"{ \n"\
"    float3 t = path->throughput; \n"\
"    return t; \n"\
"} \n"\
" \n"\
"void Path_MulThroughput(__global Path* path, float3 mul) \n"\
"{ \n"\
"    path->throughput *= mul; \n"\
"} \n"\
" \n"\
"void Path_Kill(__global Path* path) \n"\
"{ \n"\
"    path->flags |= kKilled; \n"\
"} \n"\
" \n"\
"void Path_AddContribution(__global Path* path, __global float3* output, int idx, float3 val) \n"\
"{ \n"\
"    output[idx] += Path_GetThroughput(path) * val; \n"\
"} \n"\
" \n"\
" \n"\
" \n"\
"#endif \n"\
" \n"\
"#define FAKE_SHAPE_SENTINEL 0xFFFFFF \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kEmpty, \n"\
"    kHomogeneous, \n"\
"    kHeterogeneous \n"\
"} VolumeType; \n"\
" \n"\
"typedef enum \n"\
"{ \n"\
"    kUniform, \n"\
"    kRayleigh, \n"\
"    kMieMurky, \n"\
"    kMieHazy, \n"\
"    kHG // this one requires one extra coeff \n"\
"} PhaseFunction; \n"\
" \n"\
"typedef struct _Volume \n"\
"{ \n"\
"    VolumeType type; \n"\
"    PhaseFunction phase_func; \n"\
"     \n"\
"    // Id of volume data if present  \n"\
"    int data; \n"\
"    int extra; \n"\
" \n"\
"    // Absorbtion \n"\
"    float3 sigma_a; \n"\
"    // Scattering \n"\
"    float3 sigma_s; \n"\
"    // Emission \n"\
"    float3 sigma_e; \n"\
"} Volume; \n"\
" \n"\
" \n"\
"// The following functions are taken from PBRT \n"\
"float PhaseFunction_Uniform(float3 wi, float3 wo) \n"\
"{ \n"\
"    return 1.f / (4.f * PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_Rayleigh(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return  3.f / (16.f*PI) * (1 + costheta * costheta); \n"\
"} \n"\
" \n"\
"float PhaseFunction_MieHazy(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return (0.5f + 4.5f * native_powr(0.5f * (1.f + costheta), 8.f)) / (4.f*PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_MieMurky(float3 wi, float3 wo) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return (0.5f + 16.5f * native_powr(0.5f * (1.f + costheta), 32.f)) / (4.f*PI); \n"\
"} \n"\
" \n"\
"float PhaseFunction_HG(float3 wi, float3 wo, float g) \n"\
"{ \n"\
"    float costheta = dot(wi, wo); \n"\
"    return 1.f / (4.f * PI) * \n"\
"        (1.f - g*g) / native_powr(1.f + g*g - 2.f * g * costheta, 1.5f); \n"\
"} \n"\
" \n"\
" \n"\
"// Evaluate volume transmittance along the ray [0, dist] segment \n"\
"float3 Volume_Transmittance(__global Volume const* volume, __global ray const* ray, float dist) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // For homogeneous it is e(-sigma * dist) \n"\
"            float3 sigma_t = volume->sigma_a + volume->sigma_s; \n"\
"            return native_exp(-sigma_t * dist); \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return 1.f; \n"\
"} \n"\
" \n"\
"// Evaluate volume selfemission along the ray [0, dist] segment \n"\
"float3 Volume_Emission(__global Volume const* volume, __global ray const* ray, float dist) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // For homogeneous it is simply Tr * Ev (since sigma_e is constant) \n"\
"            return Volume_Transmittance(volume, ray, dist) * volume->sigma_e; \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return 0.f; \n"\
"} \n"\
" \n"\
"// Sample volume in order to find next scattering event \n"\
"float Volume_SampleDistance(__global Volume const* volume, __global ray const* ray, float maxdist, float sample, float* pdf) \n"\
"{ \n"\
"    switch (volume->type) \n"\
"    { \n"\
"        case kHomogeneous: \n"\
"        { \n"\
"            // The PDF = sigma * e(-sigma * x), so the larger sigma the closer we scatter \n"\
"            float sigma = (volume->sigma_s.x + volume->sigma_s.y + volume->sigma_s.z) / 3; \n"\
"            float d = sigma > 0.f ? (-native_log(sample) / sigma) : -1.f; \n"\
"            *pdf = sigma > 0.f ? (sigma * native_exp(-sigma * d)) : 0.f; \n"\
"            return d; \n"\
"        } \n"\
"    } \n"\
"     \n"\
"    return -1.f; \n"\
"} \n"\
" \n"\
"// Apply volume effects (absorbtion and emission) and scatter if needed. \n"\
"// The rays we handling here might intersect something or miss,  \n"\
"// since scattering can happen even for missed rays. \n"\
"// That's why this function is called prior to ray compaction. \n"\
"// In case ray has missed geometry (has shapeid < 0) and has been scattered, \n"\
"// we put FAKE_SHAPE_SENTINEL into shapeid to prevent ray from being compacted away. \n"\
"// \n"\
"__kernel void EvaluateVolume( \n"\
"    // Ray batch \n"\
"    __global ray const* rays, \n"\
"    // Pixel indices \n"\
"    __global int const* pixelindices, \n"\
"    // Number of rays \n"\
"    __global int const* numrays, \n"\
"    // Volumes \n"\
"    __global Volume const* volumes, \n"\
"    // Textures \n"\
"    TEXTURE_ARG_LIST, \n"\
"    // RNG seed \n"\
"    int rngseed, \n"\
"    // Sampler state \n"\
"    __global SobolSampler* samplers, \n"\
"    // Sobol matrices \n"\
"    __global uint const* sobolmat, \n"\
"    // Current bounce  \n"\
"    int bounce, \n"\
"    // Intersection data \n"\
"    __global Intersection* isects, \n"\
"    // Current paths \n"\
"    __global Path* paths, \n"\
"    // Output \n"\
"    __global float3* output \n"\
"    ) \n"\
"{ \n"\
"    int globalid = get_global_id(0); \n"\
"     \n"\
"    // Only handle active rays \n"\
"    if (globalid < *numrays) \n"\
"    { \n"\
"        int pixelidx = pixelindices[globalid]; \n"\
"         \n"\
"        __global Path* path = paths + pixelidx; \n"\
" \n"\
"        // Path can be dead here since compaction step has not  \n"\
"        // yet been applied \n"\
"        if (!Path_IsAlive(path)) \n"\
"            return; \n"\
" \n"\
"        int volidx = Path_GetVolumeIdx(path); \n"\
" \n"\
"        // Check if we are inside some volume \n"\
"        if (volidx != -1) \n"\
"        { \n"\
"#ifdef SOBOL \n"\
"            __global SobolSampler* sampler = samplers + pixelidx; \n"\
"            float sample = SobolSampler_Sample1D(sampler->seq, GetSampleDim(bounce, kVolume), sampler->s0, sobolmat); \n"\
"#else \n"\
"            Rng rng; \n"\
"            InitRng(rngseed + (globalid << 2) * 157 + 13, &rng); \n"\
"            float sample = UniformSampler_Sample2D(&rng).x; \n"\
"#endif \n"\
"            // Try sampling volume for a next scattering event \n"\
"            float pdf = 0.f; \n"\
"            float maxdist = Intersection_GetDistance(isects + globalid); \n"\
"            float d = Volume_SampleDistance(&volumes[volidx], &rays[globalid], maxdist, sample, &pdf); \n"\
"             \n"\
"            // Check if we shall skip the event (it is either outside of a volume or not happened at all) \n"\
"            bool skip = d < 0 || d > maxdist || pdf <= 0.f; \n"\
" \n"\
"            if (skip) \n"\
"            { \n"\
"                // In case we skip we just need to apply volume absorbtion and emission for the segment we went through \n"\
"                // and clear scatter flag \n"\
"                Path_ClearScatterFlag(path); \n"\
"                // Emission contribution accounting for a throughput we have so far \n"\
"                Path_AddContribution(path, output, pixelidx, Volume_Emission(&volumes[volidx], &rays[globalid], maxdist)); \n"\
"                // And finally update the throughput \n"\
"                Path_MulThroughput(path, Volume_Transmittance(&volumes[volidx], &rays[globalid], maxdist)); \n"\
"            } \n"\
"            else \n"\
"            { \n"\
"                // Set scattering flag to notify ShadeVolume kernel to handle this path \n"\
"                Path_SetScatterFlag(path); \n"\
"                // Emission contribution accounting for a throughput we have so far \n"\
"                Path_AddContribution(path, output, pixelidx, Volume_Emission(&volumes[volidx], &rays[globalid], d) / pdf); \n"\
"                // Update the throughput \n"\
"                Path_MulThroughput(path, (Volume_Transmittance(&volumes[volidx], &rays[globalid], d) / pdf)); \n"\
"                // Put fake shape to prevent from being compacted away \n"\
"                isects[globalid].shapeid = FAKE_SHAPE_SENTINEL; \n"\
"                // And keep scattering distance around as well \n"\
"                isects[globalid].uvwt.w = d; \n"\
"            } \n"\
"        } \n"\
"    } \n"\
"} \n"\
" \n"\
"#endif // VOLUMETRICS_CL \n"\
;
